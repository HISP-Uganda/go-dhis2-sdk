/*
DHIS2 API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.40
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package models

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiEventHookAddCollectionItemRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiEventHookAddCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.EventHookAddCollectionItemExecute(r)
}

/*
EventHookAddCollectionItem Method for EventHookAddCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiEventHookAddCollectionItemRequest
*/
func (a *DefaultAPIService) EventHookAddCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiEventHookAddCollectionItemRequest {
	return ApiEventHookAddCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DefaultAPIService) EventHookAddCollectionItemExecute(r ApiEventHookAddCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EventHookAddCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventHooks/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventHookBulkSharingRequest struct {
	ctx                context.Context
	ApiService         *DefaultAPIService
	atomic             *bool
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	bulkJsonPatch      *BulkJsonPatch
}

// [no description yet]
func (r ApiEventHookBulkSharingRequest) Atomic(atomic bool) ApiEventHookBulkSharingRequest {
	r.atomic = &atomic
	return r
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiEventHookBulkSharingRequest) AtomicMode(atomicMode string) ApiEventHookBulkSharingRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiEventHookBulkSharingRequest) FlushMode(flushMode string) ApiEventHookBulkSharingRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiEventHookBulkSharingRequest) Identifier(identifier string) ApiEventHookBulkSharingRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiEventHookBulkSharingRequest) ImportMode(importMode string) ApiEventHookBulkSharingRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiEventHookBulkSharingRequest) ImportReportMode(importReportMode string) ApiEventHookBulkSharingRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiEventHookBulkSharingRequest) ImportStrategy(importStrategy string) ApiEventHookBulkSharingRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiEventHookBulkSharingRequest) MergeMode(mergeMode string) ApiEventHookBulkSharingRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiEventHookBulkSharingRequest) MetadataSyncImport(metadataSyncImport bool) ApiEventHookBulkSharingRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiEventHookBulkSharingRequest) Page(page int32) ApiEventHookBulkSharingRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiEventHookBulkSharingRequest) PageSize(pageSize int32) ApiEventHookBulkSharingRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiEventHookBulkSharingRequest) Paging(paging bool) ApiEventHookBulkSharingRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiEventHookBulkSharingRequest) PreheatMode(preheatMode string) ApiEventHookBulkSharingRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiEventHookBulkSharingRequest) RootJunction(rootJunction string) ApiEventHookBulkSharingRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiEventHookBulkSharingRequest) SkipSharing(skipSharing bool) ApiEventHookBulkSharingRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiEventHookBulkSharingRequest) SkipTranslation(skipTranslation bool) ApiEventHookBulkSharingRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiEventHookBulkSharingRequest) SkipValidation(skipValidation bool) ApiEventHookBulkSharingRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiEventHookBulkSharingRequest) UserOverrideMode(userOverrideMode string) ApiEventHookBulkSharingRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiEventHookBulkSharingRequest) BulkJsonPatch(bulkJsonPatch BulkJsonPatch) ApiEventHookBulkSharingRequest {
	r.bulkJsonPatch = &bulkJsonPatch
	return r
}

func (r ApiEventHookBulkSharingRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.EventHookBulkSharingExecute(r)
}

/*
EventHookBulkSharing Method for EventHookBulkSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEventHookBulkSharingRequest
*/
func (a *DefaultAPIService) EventHookBulkSharing(ctx context.Context) ApiEventHookBulkSharingRequest {
	return ApiEventHookBulkSharingRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DefaultAPIService) EventHookBulkSharingExecute(r ApiEventHookBulkSharingRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EventHookBulkSharing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventHooks/sharing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomic", r.atomic, "")
	} else {
		var defaultValue bool = false
		r.atomic = &defaultValue
	}
	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkJsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventHookDeleteCollectionItemRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiEventHookDeleteCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.EventHookDeleteCollectionItemExecute(r)
}

/*
EventHookDeleteCollectionItem Method for EventHookDeleteCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiEventHookDeleteCollectionItemRequest
*/
func (a *DefaultAPIService) EventHookDeleteCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiEventHookDeleteCollectionItemRequest {
	return ApiEventHookDeleteCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DefaultAPIService) EventHookDeleteCollectionItemExecute(r ApiEventHookDeleteCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EventHookDeleteCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventHooks/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventHookDeleteObjectRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	uid        string
}

func (r ApiEventHookDeleteObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.EventHookDeleteObjectExecute(r)
}

/*
EventHookDeleteObject Method for EventHookDeleteObject

Deletes the EventHook provided by ID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiEventHookDeleteObjectRequest
*/
func (a *DefaultAPIService) EventHookDeleteObject(ctx context.Context, uid string) ApiEventHookDeleteObjectRequest {
	return ApiEventHookDeleteObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DefaultAPIService) EventHookDeleteObjectExecute(r ApiEventHookDeleteObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EventHookDeleteObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventHooks/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventHookGetObjectRequest struct {
	ctx          context.Context
	ApiService   *DefaultAPIService
	uid          string
	fields       *[]string
	filter       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiEventHookGetObjectRequest) Fields(fields []string) ApiEventHookGetObjectRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiEventHookGetObjectRequest) Filter(filter []string) ApiEventHookGetObjectRequest {
	r.filter = &filter
	return r
}

// Defines which page number to return.
func (r ApiEventHookGetObjectRequest) Page(page int32) ApiEventHookGetObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiEventHookGetObjectRequest) PageSize(pageSize int32) ApiEventHookGetObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiEventHookGetObjectRequest) Paging(paging bool) ApiEventHookGetObjectRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiEventHookGetObjectRequest) RootJunction(rootJunction string) ApiEventHookGetObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiEventHookGetObjectRequest) Execute() (*EventHook, *http.Response, error) {
	return r.ApiService.EventHookGetObjectExecute(r)
}

/*
EventHookGetObject Method for EventHookGetObject

View a EventHook

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiEventHookGetObjectRequest
*/
func (a *DefaultAPIService) EventHookGetObject(ctx context.Context, uid string) ApiEventHookGetObjectRequest {
	return ApiEventHookGetObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return EventHook
func (a *DefaultAPIService) EventHookGetObjectExecute(r ApiEventHookGetObjectRequest) (*EventHook, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EventHook
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EventHookGetObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventHooks/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventHookGetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DefaultAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiEventHookGetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiEventHookGetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiEventHookGetObjectGistAsCsvRequest) Auto(auto string) ApiEventHookGetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiEventHookGetObjectGistAsCsvRequest) Describe(describe bool) ApiEventHookGetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiEventHookGetObjectGistAsCsvRequest) Fields(fields string) ApiEventHookGetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiEventHookGetObjectGistAsCsvRequest) Filter(filter string) ApiEventHookGetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiEventHookGetObjectGistAsCsvRequest) Headless(headless bool) ApiEventHookGetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiEventHookGetObjectGistAsCsvRequest) Inverse(inverse bool) ApiEventHookGetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiEventHookGetObjectGistAsCsvRequest) Locale(locale string) ApiEventHookGetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiEventHookGetObjectGistAsCsvRequest) Order(order string) ApiEventHookGetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiEventHookGetObjectGistAsCsvRequest) Page(page int32) ApiEventHookGetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiEventHookGetObjectGistAsCsvRequest) PageListName(pageListName string) ApiEventHookGetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiEventHookGetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiEventHookGetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiEventHookGetObjectGistAsCsvRequest) References(references bool) ApiEventHookGetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiEventHookGetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiEventHookGetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiEventHookGetObjectGistAsCsvRequest) Total(total bool) ApiEventHookGetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiEventHookGetObjectGistAsCsvRequest) Translate(translate bool) ApiEventHookGetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiEventHookGetObjectGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.EventHookGetObjectGistAsCsvExecute(r)
}

/*
EventHookGetObjectGistAsCsv Method for EventHookGetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiEventHookGetObjectGistAsCsvRequest
*/
func (a *DefaultAPIService) EventHookGetObjectGistAsCsv(ctx context.Context, uid string) ApiEventHookGetObjectGistAsCsvRequest {
	return ApiEventHookGetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *DefaultAPIService) EventHookGetObjectGistAsCsvExecute(r ApiEventHookGetObjectGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EventHookGetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventHooks/{uid}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventHookGetObjectListRequest struct {
	ctx          context.Context
	ApiService   *DefaultAPIService
	fields       *[]string
	filter       *[]string
	orders       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// &#x60;&lt;field-name&gt;[,&lt;field-name&gt;...]&#x60;
func (r ApiEventHookGetObjectListRequest) Fields(fields []string) ApiEventHookGetObjectListRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiEventHookGetObjectListRequest) Filter(filter []string) ApiEventHookGetObjectListRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiEventHookGetObjectListRequest) Orders(orders []string) ApiEventHookGetObjectListRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiEventHookGetObjectListRequest) Page(page int32) ApiEventHookGetObjectListRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiEventHookGetObjectListRequest) PageSize(pageSize int32) ApiEventHookGetObjectListRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiEventHookGetObjectListRequest) Paging(paging bool) ApiEventHookGetObjectListRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiEventHookGetObjectListRequest) RootJunction(rootJunction string) ApiEventHookGetObjectListRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiEventHookGetObjectListRequest) Execute() (*EventHookGetObjectList200Response, *http.Response, error) {
	return r.ApiService.EventHookGetObjectListExecute(r)
}

/*
EventHookGetObjectList Method for EventHookGetObjectList

List all EventHooks

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEventHookGetObjectListRequest
*/
func (a *DefaultAPIService) EventHookGetObjectList(ctx context.Context) ApiEventHookGetObjectListRequest {
	return ApiEventHookGetObjectListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return EventHookGetObjectList200Response
func (a *DefaultAPIService) EventHookGetObjectListExecute(r ApiEventHookGetObjectListRequest) (*EventHookGetObjectList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EventHookGetObjectList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EventHookGetObjectList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventHooks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventHookGetObjectListCsvRequest struct {
	ctx            context.Context
	ApiService     *DefaultAPIService
	arraySeparator *string
	fields         *[]string
	filter         *[]string
	orders         *[]string
	page           *int32
	pageSize       *int32
	paging         *bool
	rootJunction   *string
	separator      *string
	skipHeader     *bool
}

// [no description yet]
func (r ApiEventHookGetObjectListCsvRequest) ArraySeparator(arraySeparator string) ApiEventHookGetObjectListCsvRequest {
	r.arraySeparator = &arraySeparator
	return r
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiEventHookGetObjectListCsvRequest) Fields(fields []string) ApiEventHookGetObjectListCsvRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiEventHookGetObjectListCsvRequest) Filter(filter []string) ApiEventHookGetObjectListCsvRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiEventHookGetObjectListCsvRequest) Orders(orders []string) ApiEventHookGetObjectListCsvRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiEventHookGetObjectListCsvRequest) Page(page int32) ApiEventHookGetObjectListCsvRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiEventHookGetObjectListCsvRequest) PageSize(pageSize int32) ApiEventHookGetObjectListCsvRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiEventHookGetObjectListCsvRequest) Paging(paging bool) ApiEventHookGetObjectListCsvRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiEventHookGetObjectListCsvRequest) RootJunction(rootJunction string) ApiEventHookGetObjectListCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiEventHookGetObjectListCsvRequest) Separator(separator string) ApiEventHookGetObjectListCsvRequest {
	r.separator = &separator
	return r
}

// [no description yet]
func (r ApiEventHookGetObjectListCsvRequest) SkipHeader(skipHeader bool) ApiEventHookGetObjectListCsvRequest {
	r.skipHeader = &skipHeader
	return r
}

func (r ApiEventHookGetObjectListCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.EventHookGetObjectListCsvExecute(r)
}

/*
EventHookGetObjectListCsv Method for EventHookGetObjectListCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEventHookGetObjectListCsvRequest
*/
func (a *DefaultAPIService) EventHookGetObjectListCsv(ctx context.Context) ApiEventHookGetObjectListCsvRequest {
	return ApiEventHookGetObjectListCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *DefaultAPIService) EventHookGetObjectListCsvExecute(r ApiEventHookGetObjectListCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EventHookGetObjectListCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventHooks/#getObjectListCsv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.arraySeparator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arraySeparator", r.arraySeparator, "")
	} else {
		var defaultValue string = ";"
		r.arraySeparator = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.separator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "separator", r.separator, "")
	} else {
		var defaultValue string = ","
		r.separator = &defaultValue
	}
	if r.skipHeader != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipHeader", r.skipHeader, "")
	} else {
		var defaultValue bool = false
		r.skipHeader = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/text", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventHookGetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DefaultAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiEventHookGetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiEventHookGetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiEventHookGetObjectListGistAsCsvRequest) Auto(auto string) ApiEventHookGetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiEventHookGetObjectListGistAsCsvRequest) Describe(describe bool) ApiEventHookGetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiEventHookGetObjectListGistAsCsvRequest) Fields(fields string) ApiEventHookGetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiEventHookGetObjectListGistAsCsvRequest) Filter(filter string) ApiEventHookGetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiEventHookGetObjectListGistAsCsvRequest) Headless(headless bool) ApiEventHookGetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiEventHookGetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiEventHookGetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiEventHookGetObjectListGistAsCsvRequest) Locale(locale string) ApiEventHookGetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiEventHookGetObjectListGistAsCsvRequest) Order(order string) ApiEventHookGetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiEventHookGetObjectListGistAsCsvRequest) Page(page int32) ApiEventHookGetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiEventHookGetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiEventHookGetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiEventHookGetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiEventHookGetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiEventHookGetObjectListGistAsCsvRequest) References(references bool) ApiEventHookGetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiEventHookGetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiEventHookGetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiEventHookGetObjectListGistAsCsvRequest) Total(total bool) ApiEventHookGetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiEventHookGetObjectListGistAsCsvRequest) Translate(translate bool) ApiEventHookGetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiEventHookGetObjectListGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.EventHookGetObjectListGistAsCsvExecute(r)
}

/*
EventHookGetObjectListGistAsCsv Method for EventHookGetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEventHookGetObjectListGistAsCsvRequest
*/
func (a *DefaultAPIService) EventHookGetObjectListGistAsCsv(ctx context.Context) ApiEventHookGetObjectListGistAsCsvRequest {
	return ApiEventHookGetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *DefaultAPIService) EventHookGetObjectListGistAsCsvExecute(r ApiEventHookGetObjectListGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EventHookGetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventHooks/gist.csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventHookGetObjectPropertyRequest struct {
	ctx          context.Context
	ApiService   *DefaultAPIService
	property     string
	uid          string
	fields       *[]string
	locale       *string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
	translate    *bool
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiEventHookGetObjectPropertyRequest) Fields(fields []string) ApiEventHookGetObjectPropertyRequest {
	r.fields = &fields
	return r
}

// [no description yet]
func (r ApiEventHookGetObjectPropertyRequest) Locale(locale string) ApiEventHookGetObjectPropertyRequest {
	r.locale = &locale
	return r
}

// Defines which page number to return.
func (r ApiEventHookGetObjectPropertyRequest) Page(page int32) ApiEventHookGetObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiEventHookGetObjectPropertyRequest) PageSize(pageSize int32) ApiEventHookGetObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiEventHookGetObjectPropertyRequest) Paging(paging bool) ApiEventHookGetObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiEventHookGetObjectPropertyRequest) RootJunction(rootJunction string) ApiEventHookGetObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiEventHookGetObjectPropertyRequest) Translate(translate bool) ApiEventHookGetObjectPropertyRequest {
	r.translate = &translate
	return r
}

func (r ApiEventHookGetObjectPropertyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.EventHookGetObjectPropertyExecute(r)
}

/*
EventHookGetObjectProperty Method for EventHookGetObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiEventHookGetObjectPropertyRequest
*/
func (a *DefaultAPIService) EventHookGetObjectProperty(ctx context.Context, property string, uid string) ApiEventHookGetObjectPropertyRequest {
	return ApiEventHookGetObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *DefaultAPIService) EventHookGetObjectPropertyExecute(r ApiEventHookGetObjectPropertyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EventHookGetObjectProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventHooks/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventHookGetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DefaultAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiEventHookGetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiEventHookGetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiEventHookGetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiEventHookGetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiEventHookGetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiEventHookGetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiEventHookGetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiEventHookGetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiEventHookGetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiEventHookGetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiEventHookGetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiEventHookGetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiEventHookGetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiEventHookGetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiEventHookGetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiEventHookGetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiEventHookGetObjectPropertyGistAsCsvRequest) Order(order string) ApiEventHookGetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiEventHookGetObjectPropertyGistAsCsvRequest) Page(page int32) ApiEventHookGetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiEventHookGetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiEventHookGetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiEventHookGetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiEventHookGetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiEventHookGetObjectPropertyGistAsCsvRequest) References(references bool) ApiEventHookGetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiEventHookGetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiEventHookGetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiEventHookGetObjectPropertyGistAsCsvRequest) Total(total bool) ApiEventHookGetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiEventHookGetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiEventHookGetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiEventHookGetObjectPropertyGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.EventHookGetObjectPropertyGistAsCsvExecute(r)
}

/*
EventHookGetObjectPropertyGistAsCsv Method for EventHookGetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiEventHookGetObjectPropertyGistAsCsvRequest
*/
func (a *DefaultAPIService) EventHookGetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiEventHookGetObjectPropertyGistAsCsvRequest {
	return ApiEventHookGetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *DefaultAPIService) EventHookGetObjectPropertyGistAsCsvExecute(r ApiEventHookGetObjectPropertyGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EventHookGetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventHooks/{uid}/{property}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventHookPatchObjectRequest struct {
	ctx                context.Context
	ApiService         *DefaultAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	jsonPatch          *JsonPatch
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiEventHookPatchObjectRequest) AtomicMode(atomicMode string) ApiEventHookPatchObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiEventHookPatchObjectRequest) FlushMode(flushMode string) ApiEventHookPatchObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiEventHookPatchObjectRequest) Identifier(identifier string) ApiEventHookPatchObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiEventHookPatchObjectRequest) ImportMode(importMode string) ApiEventHookPatchObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiEventHookPatchObjectRequest) ImportReportMode(importReportMode string) ApiEventHookPatchObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiEventHookPatchObjectRequest) ImportStrategy(importStrategy string) ApiEventHookPatchObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiEventHookPatchObjectRequest) MergeMode(mergeMode string) ApiEventHookPatchObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiEventHookPatchObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiEventHookPatchObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiEventHookPatchObjectRequest) Page(page int32) ApiEventHookPatchObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiEventHookPatchObjectRequest) PageSize(pageSize int32) ApiEventHookPatchObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiEventHookPatchObjectRequest) Paging(paging bool) ApiEventHookPatchObjectRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiEventHookPatchObjectRequest) PreheatMode(preheatMode string) ApiEventHookPatchObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiEventHookPatchObjectRequest) RootJunction(rootJunction string) ApiEventHookPatchObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiEventHookPatchObjectRequest) SkipSharing(skipSharing bool) ApiEventHookPatchObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiEventHookPatchObjectRequest) SkipTranslation(skipTranslation bool) ApiEventHookPatchObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiEventHookPatchObjectRequest) SkipValidation(skipValidation bool) ApiEventHookPatchObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiEventHookPatchObjectRequest) UserOverrideMode(userOverrideMode string) ApiEventHookPatchObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiEventHookPatchObjectRequest) JsonPatch(jsonPatch JsonPatch) ApiEventHookPatchObjectRequest {
	r.jsonPatch = &jsonPatch
	return r
}

func (r ApiEventHookPatchObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.EventHookPatchObjectExecute(r)
}

/*
EventHookPatchObject Method for EventHookPatchObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiEventHookPatchObjectRequest
*/
func (a *DefaultAPIService) EventHookPatchObject(ctx context.Context, uid string) ApiEventHookPatchObjectRequest {
	return ApiEventHookPatchObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DefaultAPIService) EventHookPatchObjectExecute(r ApiEventHookPatchObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EventHookPatchObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventHooks/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventHookRemoveAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	uid        string
}

func (r ApiEventHookRemoveAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.EventHookRemoveAsFavoriteExecute(r)
}

/*
EventHookRemoveAsFavorite Method for EventHookRemoveAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiEventHookRemoveAsFavoriteRequest
*/
func (a *DefaultAPIService) EventHookRemoveAsFavorite(ctx context.Context, uid string) ApiEventHookRemoveAsFavoriteRequest {
	return ApiEventHookRemoveAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DefaultAPIService) EventHookRemoveAsFavoriteExecute(r ApiEventHookRemoveAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EventHookRemoveAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventHooks/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventHookReplaceTranslationsRequest struct {
	ctx                                             context.Context
	ApiService                                      *DefaultAPIService
	uid                                             string
	aggregateDataExchangeReplaceTranslationsRequest *AggregateDataExchangeReplaceTranslationsRequest
}

// [no description yet]
func (r ApiEventHookReplaceTranslationsRequest) AggregateDataExchangeReplaceTranslationsRequest(aggregateDataExchangeReplaceTranslationsRequest AggregateDataExchangeReplaceTranslationsRequest) ApiEventHookReplaceTranslationsRequest {
	r.aggregateDataExchangeReplaceTranslationsRequest = &aggregateDataExchangeReplaceTranslationsRequest
	return r
}

func (r ApiEventHookReplaceTranslationsRequest) Execute() (*http.Response, error) {
	return r.ApiService.EventHookReplaceTranslationsExecute(r)
}

/*
EventHookReplaceTranslations Method for EventHookReplaceTranslations

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiEventHookReplaceTranslationsRequest
*/
func (a *DefaultAPIService) EventHookReplaceTranslations(ctx context.Context, uid string) ApiEventHookReplaceTranslationsRequest {
	return ApiEventHookReplaceTranslationsRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) EventHookReplaceTranslationsExecute(r ApiEventHookReplaceTranslationsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EventHookReplaceTranslations")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventHooks/{uid}/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateDataExchangeReplaceTranslationsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEventHookSetAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	uid        string
}

func (r ApiEventHookSetAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.EventHookSetAsFavoriteExecute(r)
}

/*
EventHookSetAsFavorite Method for EventHookSetAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiEventHookSetAsFavoriteRequest
*/
func (a *DefaultAPIService) EventHookSetAsFavorite(ctx context.Context, uid string) ApiEventHookSetAsFavoriteRequest {
	return ApiEventHookSetAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DefaultAPIService) EventHookSetAsFavoriteExecute(r ApiEventHookSetAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EventHookSetAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventHooks/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventHookSetSharingRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	uid        string
	sharing    *Sharing
}

// [no description yet]
func (r ApiEventHookSetSharingRequest) Sharing(sharing Sharing) ApiEventHookSetSharingRequest {
	r.sharing = &sharing
	return r
}

func (r ApiEventHookSetSharingRequest) Execute() (*http.Response, error) {
	return r.ApiService.EventHookSetSharingExecute(r)
}

/*
EventHookSetSharing Method for EventHookSetSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiEventHookSetSharingRequest
*/
func (a *DefaultAPIService) EventHookSetSharing(ctx context.Context, uid string) ApiEventHookSetSharingRequest {
	return ApiEventHookSetSharingRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) EventHookSetSharingExecute(r ApiEventHookSetSharingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EventHookSetSharing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventHooks/{uid}/sharing"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharing
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEventHookSubscribeRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	uid        string
}

func (r ApiEventHookSubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.EventHookSubscribeExecute(r)
}

/*
EventHookSubscribe Method for EventHookSubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiEventHookSubscribeRequest
*/
func (a *DefaultAPIService) EventHookSubscribe(ctx context.Context, uid string) ApiEventHookSubscribeRequest {
	return ApiEventHookSubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DefaultAPIService) EventHookSubscribeExecute(r ApiEventHookSubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EventHookSubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventHooks/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventHookUnsubscribeRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	uid        string
}

func (r ApiEventHookUnsubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.EventHookUnsubscribeExecute(r)
}

/*
EventHookUnsubscribe Method for EventHookUnsubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiEventHookUnsubscribeRequest
*/
func (a *DefaultAPIService) EventHookUnsubscribe(ctx context.Context, uid string) ApiEventHookUnsubscribeRequest {
	return ApiEventHookUnsubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DefaultAPIService) EventHookUnsubscribeExecute(r ApiEventHookUnsubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EventHookUnsubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventHooks/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventHookUpdateObjectPropertyRequest struct {
	ctx                context.Context
	ApiService         *DefaultAPIService
	property           string
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	eventHook          *EventHook
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiEventHookUpdateObjectPropertyRequest) AtomicMode(atomicMode string) ApiEventHookUpdateObjectPropertyRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiEventHookUpdateObjectPropertyRequest) FlushMode(flushMode string) ApiEventHookUpdateObjectPropertyRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiEventHookUpdateObjectPropertyRequest) Identifier(identifier string) ApiEventHookUpdateObjectPropertyRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiEventHookUpdateObjectPropertyRequest) ImportMode(importMode string) ApiEventHookUpdateObjectPropertyRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiEventHookUpdateObjectPropertyRequest) ImportReportMode(importReportMode string) ApiEventHookUpdateObjectPropertyRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiEventHookUpdateObjectPropertyRequest) ImportStrategy(importStrategy string) ApiEventHookUpdateObjectPropertyRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiEventHookUpdateObjectPropertyRequest) MergeMode(mergeMode string) ApiEventHookUpdateObjectPropertyRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiEventHookUpdateObjectPropertyRequest) MetadataSyncImport(metadataSyncImport bool) ApiEventHookUpdateObjectPropertyRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiEventHookUpdateObjectPropertyRequest) Page(page int32) ApiEventHookUpdateObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiEventHookUpdateObjectPropertyRequest) PageSize(pageSize int32) ApiEventHookUpdateObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiEventHookUpdateObjectPropertyRequest) Paging(paging bool) ApiEventHookUpdateObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiEventHookUpdateObjectPropertyRequest) PreheatMode(preheatMode string) ApiEventHookUpdateObjectPropertyRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiEventHookUpdateObjectPropertyRequest) RootJunction(rootJunction string) ApiEventHookUpdateObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiEventHookUpdateObjectPropertyRequest) SkipSharing(skipSharing bool) ApiEventHookUpdateObjectPropertyRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiEventHookUpdateObjectPropertyRequest) SkipTranslation(skipTranslation bool) ApiEventHookUpdateObjectPropertyRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiEventHookUpdateObjectPropertyRequest) SkipValidation(skipValidation bool) ApiEventHookUpdateObjectPropertyRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiEventHookUpdateObjectPropertyRequest) UserOverrideMode(userOverrideMode string) ApiEventHookUpdateObjectPropertyRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiEventHookUpdateObjectPropertyRequest) EventHook(eventHook EventHook) ApiEventHookUpdateObjectPropertyRequest {
	r.eventHook = &eventHook
	return r
}

func (r ApiEventHookUpdateObjectPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EventHookUpdateObjectPropertyExecute(r)
}

/*
EventHookUpdateObjectProperty Method for EventHookUpdateObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiEventHookUpdateObjectPropertyRequest
*/
func (a *DefaultAPIService) EventHookUpdateObjectProperty(ctx context.Context, property string, uid string) ApiEventHookUpdateObjectPropertyRequest {
	return ApiEventHookUpdateObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) EventHookUpdateObjectPropertyExecute(r ApiEventHookUpdateObjectPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EventHookUpdateObjectProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventHooks/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.eventHook
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPingPingRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiPingPingRequest) Execute() (*http.Response, error) {
	return r.ApiService.PingPingExecute(r)
}

/*
PingPing Method for PingPing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPingPingRequest
*/
func (a *DefaultAPIService) PingPing(ctx context.Context) ApiPingPingRequest {
	return ApiPingPingRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) PingPingExecute(r ApiPingPingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PingPing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPublicKeysGetKeysRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	clientId   string
}

func (r ApiPublicKeysGetKeysRequest) Execute() (map[string]map[string]interface{}, *http.Response, error) {
	return r.ApiService.PublicKeysGetKeysExecute(r)
}

/*
PublicKeysGetKeys Method for PublicKeysGetKeys

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clientId [no description yet]
	@return ApiPublicKeysGetKeysRequest
*/
func (a *DefaultAPIService) PublicKeysGetKeys(ctx context.Context, clientId string) ApiPublicKeysGetKeysRequest {
	return ApiPublicKeysGetKeysRequest{
		ApiService: a,
		ctx:        ctx,
		clientId:   clientId,
	}
}

// Execute executes the request
//
//	@return map[string]map[string]interface{}
func (a *DefaultAPIService) PublicKeysGetKeysExecute(r ApiPublicKeysGetKeysRequest) (map[string]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PublicKeysGetKeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/publicKeys/{clientId}/jwks.json"
	localVarPath = strings.Replace(localVarPath, "{"+"clientId"+"}", url.PathEscape(parameterValueToString(r.clientId, "clientId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
