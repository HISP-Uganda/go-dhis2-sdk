/*
DHIS2 API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.40
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package models

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"reflect"
	"strings"
	"time"
)

// DataAPIService DataAPI service
type DataAPIService service

type ApiAggregateDataExchangeAddCollectionItemRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiAggregateDataExchangeAddCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.AggregateDataExchangeAddCollectionItemExecute(r)
}

/*
AggregateDataExchangeAddCollectionItem Method for AggregateDataExchangeAddCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiAggregateDataExchangeAddCollectionItemRequest
*/
func (a *DataAPIService) AggregateDataExchangeAddCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiAggregateDataExchangeAddCollectionItemRequest {
	return ApiAggregateDataExchangeAddCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) AggregateDataExchangeAddCollectionItemExecute(r ApiAggregateDataExchangeAddCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeAddCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeAddCollectionItemsJsonaddCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *DataAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiAggregateDataExchangeAddCollectionItemsJsonaddCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiAggregateDataExchangeAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiAggregateDataExchangeAddCollectionItemsJsonaddCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.AggregateDataExchangeAddCollectionItemsJsonaddCollectionItemsXmlExecute(r)
}

/*
AggregateDataExchangeAddCollectionItemsJsonaddCollectionItemsXml Method for AggregateDataExchangeAddCollectionItemsJsonaddCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiAggregateDataExchangeAddCollectionItemsJsonaddCollectionItemsXmlRequest
*/
func (a *DataAPIService) AggregateDataExchangeAddCollectionItemsJsonaddCollectionItemsXml(ctx context.Context, property string, uid string) ApiAggregateDataExchangeAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	return ApiAggregateDataExchangeAddCollectionItemsJsonaddCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) AggregateDataExchangeAddCollectionItemsJsonaddCollectionItemsXmlExecute(r ApiAggregateDataExchangeAddCollectionItemsJsonaddCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeAddCollectionItemsJsonaddCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeBulkSharingRequest struct {
	ctx                context.Context
	ApiService         *DataAPIService
	atomic             *bool
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	bulkJsonPatch      *BulkJsonPatch
}

// [no description yet]
func (r ApiAggregateDataExchangeBulkSharingRequest) Atomic(atomic bool) ApiAggregateDataExchangeBulkSharingRequest {
	r.atomic = &atomic
	return r
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiAggregateDataExchangeBulkSharingRequest) AtomicMode(atomicMode string) ApiAggregateDataExchangeBulkSharingRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiAggregateDataExchangeBulkSharingRequest) FlushMode(flushMode string) ApiAggregateDataExchangeBulkSharingRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiAggregateDataExchangeBulkSharingRequest) Identifier(identifier string) ApiAggregateDataExchangeBulkSharingRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiAggregateDataExchangeBulkSharingRequest) ImportMode(importMode string) ApiAggregateDataExchangeBulkSharingRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiAggregateDataExchangeBulkSharingRequest) ImportReportMode(importReportMode string) ApiAggregateDataExchangeBulkSharingRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiAggregateDataExchangeBulkSharingRequest) ImportStrategy(importStrategy string) ApiAggregateDataExchangeBulkSharingRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiAggregateDataExchangeBulkSharingRequest) MergeMode(mergeMode string) ApiAggregateDataExchangeBulkSharingRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangeBulkSharingRequest) MetadataSyncImport(metadataSyncImport bool) ApiAggregateDataExchangeBulkSharingRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiAggregateDataExchangeBulkSharingRequest) Page(page int32) ApiAggregateDataExchangeBulkSharingRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiAggregateDataExchangeBulkSharingRequest) PageSize(pageSize int32) ApiAggregateDataExchangeBulkSharingRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiAggregateDataExchangeBulkSharingRequest) Paging(paging bool) ApiAggregateDataExchangeBulkSharingRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiAggregateDataExchangeBulkSharingRequest) PreheatMode(preheatMode string) ApiAggregateDataExchangeBulkSharingRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiAggregateDataExchangeBulkSharingRequest) RootJunction(rootJunction string) ApiAggregateDataExchangeBulkSharingRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiAggregateDataExchangeBulkSharingRequest) SkipSharing(skipSharing bool) ApiAggregateDataExchangeBulkSharingRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangeBulkSharingRequest) SkipTranslation(skipTranslation bool) ApiAggregateDataExchangeBulkSharingRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiAggregateDataExchangeBulkSharingRequest) SkipValidation(skipValidation bool) ApiAggregateDataExchangeBulkSharingRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiAggregateDataExchangeBulkSharingRequest) UserOverrideMode(userOverrideMode string) ApiAggregateDataExchangeBulkSharingRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangeBulkSharingRequest) BulkJsonPatch(bulkJsonPatch BulkJsonPatch) ApiAggregateDataExchangeBulkSharingRequest {
	r.bulkJsonPatch = &bulkJsonPatch
	return r
}

func (r ApiAggregateDataExchangeBulkSharingRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.AggregateDataExchangeBulkSharingExecute(r)
}

/*
AggregateDataExchangeBulkSharing Method for AggregateDataExchangeBulkSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAggregateDataExchangeBulkSharingRequest
*/
func (a *DataAPIService) AggregateDataExchangeBulkSharing(ctx context.Context) ApiAggregateDataExchangeBulkSharingRequest {
	return ApiAggregateDataExchangeBulkSharingRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) AggregateDataExchangeBulkSharingExecute(r ApiAggregateDataExchangeBulkSharingRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeBulkSharing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/sharing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomic", r.atomic, "")
	} else {
		var defaultValue bool = false
		r.atomic = &defaultValue
	}
	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkJsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeDeleteCollectionItemRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiAggregateDataExchangeDeleteCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.AggregateDataExchangeDeleteCollectionItemExecute(r)
}

/*
AggregateDataExchangeDeleteCollectionItem Method for AggregateDataExchangeDeleteCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiAggregateDataExchangeDeleteCollectionItemRequest
*/
func (a *DataAPIService) AggregateDataExchangeDeleteCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiAggregateDataExchangeDeleteCollectionItemRequest {
	return ApiAggregateDataExchangeDeleteCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) AggregateDataExchangeDeleteCollectionItemExecute(r ApiAggregateDataExchangeDeleteCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeDeleteCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *DataAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiAggregateDataExchangeDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiAggregateDataExchangeDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiAggregateDataExchangeDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.AggregateDataExchangeDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r)
}

/*
AggregateDataExchangeDeleteCollectionItemsJsondeleteCollectionItemsXml Method for AggregateDataExchangeDeleteCollectionItemsJsondeleteCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiAggregateDataExchangeDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest
*/
func (a *DataAPIService) AggregateDataExchangeDeleteCollectionItemsJsondeleteCollectionItemsXml(ctx context.Context, property string, uid string) ApiAggregateDataExchangeDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	return ApiAggregateDataExchangeDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) AggregateDataExchangeDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r ApiAggregateDataExchangeDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeDeleteCollectionItemsJsondeleteCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeDeleteObjectRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
}

func (r ApiAggregateDataExchangeDeleteObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.AggregateDataExchangeDeleteObjectExecute(r)
}

/*
AggregateDataExchangeDeleteObject Method for AggregateDataExchangeDeleteObject

Deletes the AggregateDataExchange provided by ID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiAggregateDataExchangeDeleteObjectRequest
*/
func (a *DataAPIService) AggregateDataExchangeDeleteObject(ctx context.Context, uid string) ApiAggregateDataExchangeDeleteObjectRequest {
	return ApiAggregateDataExchangeDeleteObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) AggregateDataExchangeDeleteObjectExecute(r ApiAggregateDataExchangeDeleteObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeDeleteObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeGetObjectRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	uid          string
	fields       *[]string
	filter       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiAggregateDataExchangeGetObjectRequest) Fields(fields []string) ApiAggregateDataExchangeGetObjectRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiAggregateDataExchangeGetObjectRequest) Filter(filter []string) ApiAggregateDataExchangeGetObjectRequest {
	r.filter = &filter
	return r
}

// Defines which page number to return.
func (r ApiAggregateDataExchangeGetObjectRequest) Page(page int32) ApiAggregateDataExchangeGetObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiAggregateDataExchangeGetObjectRequest) PageSize(pageSize int32) ApiAggregateDataExchangeGetObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiAggregateDataExchangeGetObjectRequest) Paging(paging bool) ApiAggregateDataExchangeGetObjectRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiAggregateDataExchangeGetObjectRequest) RootJunction(rootJunction string) ApiAggregateDataExchangeGetObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiAggregateDataExchangeGetObjectRequest) Execute() (*AggregateDataExchange, *http.Response, error) {
	return r.ApiService.AggregateDataExchangeGetObjectExecute(r)
}

/*
AggregateDataExchangeGetObject Method for AggregateDataExchangeGetObject

View a AggregateDataExchange

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiAggregateDataExchangeGetObjectRequest
*/
func (a *DataAPIService) AggregateDataExchangeGetObject(ctx context.Context, uid string) ApiAggregateDataExchangeGetObjectRequest {
	return ApiAggregateDataExchangeGetObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return AggregateDataExchange
func (a *DataAPIService) AggregateDataExchangeGetObjectExecute(r ApiAggregateDataExchangeGetObjectRequest) (*AggregateDataExchange, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AggregateDataExchange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeGetObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeGetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiAggregateDataExchangeGetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiAggregateDataExchangeGetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiAggregateDataExchangeGetObjectGistAsCsvRequest) Auto(auto string) ApiAggregateDataExchangeGetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiAggregateDataExchangeGetObjectGistAsCsvRequest) Describe(describe bool) ApiAggregateDataExchangeGetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiAggregateDataExchangeGetObjectGistAsCsvRequest) Fields(fields string) ApiAggregateDataExchangeGetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiAggregateDataExchangeGetObjectGistAsCsvRequest) Filter(filter string) ApiAggregateDataExchangeGetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiAggregateDataExchangeGetObjectGistAsCsvRequest) Headless(headless bool) ApiAggregateDataExchangeGetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiAggregateDataExchangeGetObjectGistAsCsvRequest) Inverse(inverse bool) ApiAggregateDataExchangeGetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiAggregateDataExchangeGetObjectGistAsCsvRequest) Locale(locale string) ApiAggregateDataExchangeGetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiAggregateDataExchangeGetObjectGistAsCsvRequest) Order(order string) ApiAggregateDataExchangeGetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiAggregateDataExchangeGetObjectGistAsCsvRequest) Page(page int32) ApiAggregateDataExchangeGetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangeGetObjectGistAsCsvRequest) PageListName(pageListName string) ApiAggregateDataExchangeGetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiAggregateDataExchangeGetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiAggregateDataExchangeGetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiAggregateDataExchangeGetObjectGistAsCsvRequest) References(references bool) ApiAggregateDataExchangeGetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiAggregateDataExchangeGetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiAggregateDataExchangeGetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiAggregateDataExchangeGetObjectGistAsCsvRequest) Total(total bool) ApiAggregateDataExchangeGetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiAggregateDataExchangeGetObjectGistAsCsvRequest) Translate(translate bool) ApiAggregateDataExchangeGetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiAggregateDataExchangeGetObjectGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.AggregateDataExchangeGetObjectGistAsCsvExecute(r)
}

/*
AggregateDataExchangeGetObjectGistAsCsv Method for AggregateDataExchangeGetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiAggregateDataExchangeGetObjectGistAsCsvRequest
*/
func (a *DataAPIService) AggregateDataExchangeGetObjectGistAsCsv(ctx context.Context, uid string) ApiAggregateDataExchangeGetObjectGistAsCsvRequest {
	return ApiAggregateDataExchangeGetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *DataAPIService) AggregateDataExchangeGetObjectGistAsCsvExecute(r ApiAggregateDataExchangeGetObjectGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeGetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/{uid}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest) Auto(auto string) ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest) Describe(describe bool) ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest) Fields(fields string) ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest) Filter(filter string) ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest) Headless(headless bool) ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest) Inverse(inverse bool) ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest) Locale(locale string) ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest) Order(order string) ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest) Page(page int32) ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest) PageListName(pageListName string) ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest) References(references bool) ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest) Total(total bool) ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest) Translate(translate bool) ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AggregateDataExchangeGetObjectGistgetObjectGistAsCsvExecute(r)
}

/*
AggregateDataExchangeGetObjectGistgetObjectGistAsCsv Method for AggregateDataExchangeGetObjectGistgetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest
*/
func (a *DataAPIService) AggregateDataExchangeGetObjectGistgetObjectGistAsCsv(ctx context.Context, uid string) ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest {
	return ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *DataAPIService) AggregateDataExchangeGetObjectGistgetObjectGistAsCsvExecute(r ApiAggregateDataExchangeGetObjectGistgetObjectGistAsCsvRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeGetObjectGistgetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/{uid}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeGetObjectListRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	fields       *[]string
	filter       *[]string
	orders       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// &#x60;&lt;field-name&gt;[,&lt;field-name&gt;...]&#x60;
func (r ApiAggregateDataExchangeGetObjectListRequest) Fields(fields []string) ApiAggregateDataExchangeGetObjectListRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiAggregateDataExchangeGetObjectListRequest) Filter(filter []string) ApiAggregateDataExchangeGetObjectListRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangeGetObjectListRequest) Orders(orders []string) ApiAggregateDataExchangeGetObjectListRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiAggregateDataExchangeGetObjectListRequest) Page(page int32) ApiAggregateDataExchangeGetObjectListRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiAggregateDataExchangeGetObjectListRequest) PageSize(pageSize int32) ApiAggregateDataExchangeGetObjectListRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiAggregateDataExchangeGetObjectListRequest) Paging(paging bool) ApiAggregateDataExchangeGetObjectListRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiAggregateDataExchangeGetObjectListRequest) RootJunction(rootJunction string) ApiAggregateDataExchangeGetObjectListRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiAggregateDataExchangeGetObjectListRequest) Execute() (*AggregateDataExchangeGetObjectList200Response, *http.Response, error) {
	return r.ApiService.AggregateDataExchangeGetObjectListExecute(r)
}

/*
AggregateDataExchangeGetObjectList Method for AggregateDataExchangeGetObjectList

List all AggregateDataExchanges

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAggregateDataExchangeGetObjectListRequest
*/
func (a *DataAPIService) AggregateDataExchangeGetObjectList(ctx context.Context) ApiAggregateDataExchangeGetObjectListRequest {
	return ApiAggregateDataExchangeGetObjectListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AggregateDataExchangeGetObjectList200Response
func (a *DataAPIService) AggregateDataExchangeGetObjectListExecute(r ApiAggregateDataExchangeGetObjectListRequest) (*AggregateDataExchangeGetObjectList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AggregateDataExchangeGetObjectList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeGetObjectList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeGetObjectListCsvRequest struct {
	ctx            context.Context
	ApiService     *DataAPIService
	arraySeparator *string
	fields         *[]string
	filter         *[]string
	orders         *[]string
	page           *int32
	pageSize       *int32
	paging         *bool
	rootJunction   *string
	separator      *string
	skipHeader     *bool
}

// [no description yet]
func (r ApiAggregateDataExchangeGetObjectListCsvRequest) ArraySeparator(arraySeparator string) ApiAggregateDataExchangeGetObjectListCsvRequest {
	r.arraySeparator = &arraySeparator
	return r
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiAggregateDataExchangeGetObjectListCsvRequest) Fields(fields []string) ApiAggregateDataExchangeGetObjectListCsvRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiAggregateDataExchangeGetObjectListCsvRequest) Filter(filter []string) ApiAggregateDataExchangeGetObjectListCsvRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangeGetObjectListCsvRequest) Orders(orders []string) ApiAggregateDataExchangeGetObjectListCsvRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiAggregateDataExchangeGetObjectListCsvRequest) Page(page int32) ApiAggregateDataExchangeGetObjectListCsvRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiAggregateDataExchangeGetObjectListCsvRequest) PageSize(pageSize int32) ApiAggregateDataExchangeGetObjectListCsvRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiAggregateDataExchangeGetObjectListCsvRequest) Paging(paging bool) ApiAggregateDataExchangeGetObjectListCsvRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiAggregateDataExchangeGetObjectListCsvRequest) RootJunction(rootJunction string) ApiAggregateDataExchangeGetObjectListCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangeGetObjectListCsvRequest) Separator(separator string) ApiAggregateDataExchangeGetObjectListCsvRequest {
	r.separator = &separator
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangeGetObjectListCsvRequest) SkipHeader(skipHeader bool) ApiAggregateDataExchangeGetObjectListCsvRequest {
	r.skipHeader = &skipHeader
	return r
}

func (r ApiAggregateDataExchangeGetObjectListCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.AggregateDataExchangeGetObjectListCsvExecute(r)
}

/*
AggregateDataExchangeGetObjectListCsv Method for AggregateDataExchangeGetObjectListCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAggregateDataExchangeGetObjectListCsvRequest
*/
func (a *DataAPIService) AggregateDataExchangeGetObjectListCsv(ctx context.Context) ApiAggregateDataExchangeGetObjectListCsvRequest {
	return ApiAggregateDataExchangeGetObjectListCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *DataAPIService) AggregateDataExchangeGetObjectListCsvExecute(r ApiAggregateDataExchangeGetObjectListCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeGetObjectListCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/#getObjectListCsv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.arraySeparator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arraySeparator", r.arraySeparator, "")
	} else {
		var defaultValue string = ";"
		r.arraySeparator = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.separator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "separator", r.separator, "")
	} else {
		var defaultValue string = ","
		r.separator = &defaultValue
	}
	if r.skipHeader != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipHeader", r.skipHeader, "")
	} else {
		var defaultValue bool = false
		r.skipHeader = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/text", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeGetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiAggregateDataExchangeGetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiAggregateDataExchangeGetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiAggregateDataExchangeGetObjectListGistAsCsvRequest) Auto(auto string) ApiAggregateDataExchangeGetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiAggregateDataExchangeGetObjectListGistAsCsvRequest) Describe(describe bool) ApiAggregateDataExchangeGetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiAggregateDataExchangeGetObjectListGistAsCsvRequest) Fields(fields string) ApiAggregateDataExchangeGetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiAggregateDataExchangeGetObjectListGistAsCsvRequest) Filter(filter string) ApiAggregateDataExchangeGetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiAggregateDataExchangeGetObjectListGistAsCsvRequest) Headless(headless bool) ApiAggregateDataExchangeGetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiAggregateDataExchangeGetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiAggregateDataExchangeGetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiAggregateDataExchangeGetObjectListGistAsCsvRequest) Locale(locale string) ApiAggregateDataExchangeGetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiAggregateDataExchangeGetObjectListGistAsCsvRequest) Order(order string) ApiAggregateDataExchangeGetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiAggregateDataExchangeGetObjectListGistAsCsvRequest) Page(page int32) ApiAggregateDataExchangeGetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangeGetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiAggregateDataExchangeGetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiAggregateDataExchangeGetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiAggregateDataExchangeGetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiAggregateDataExchangeGetObjectListGistAsCsvRequest) References(references bool) ApiAggregateDataExchangeGetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiAggregateDataExchangeGetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiAggregateDataExchangeGetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiAggregateDataExchangeGetObjectListGistAsCsvRequest) Total(total bool) ApiAggregateDataExchangeGetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiAggregateDataExchangeGetObjectListGistAsCsvRequest) Translate(translate bool) ApiAggregateDataExchangeGetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiAggregateDataExchangeGetObjectListGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.AggregateDataExchangeGetObjectListGistAsCsvExecute(r)
}

/*
AggregateDataExchangeGetObjectListGistAsCsv Method for AggregateDataExchangeGetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAggregateDataExchangeGetObjectListGistAsCsvRequest
*/
func (a *DataAPIService) AggregateDataExchangeGetObjectListGistAsCsv(ctx context.Context) ApiAggregateDataExchangeGetObjectListGistAsCsvRequest {
	return ApiAggregateDataExchangeGetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *DataAPIService) AggregateDataExchangeGetObjectListGistAsCsvExecute(r ApiAggregateDataExchangeGetObjectListGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeGetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/gist.csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest) Auto(auto string) ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest) Describe(describe bool) ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest) Fields(fields string) ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest) Filter(filter string) ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest) Headless(headless bool) ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest) Locale(locale string) ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest) Order(order string) ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest) Page(page int32) ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest) References(references bool) ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest) Total(total bool) ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest) Translate(translate bool) ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest) Execute() (*AggregateDataExchangeGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.AggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvExecute(r)
}

/*
AggregateDataExchangeGetObjectListGistgetObjectListGistAsCsv Method for AggregateDataExchangeGetObjectListGistgetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest
*/
func (a *DataAPIService) AggregateDataExchangeGetObjectListGistgetObjectListGistAsCsv(ctx context.Context) ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest {
	return ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AggregateDataExchangeGetObjectListGistGetObjectListGistAsCsv200Response
func (a *DataAPIService) AggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvExecute(r ApiAggregateDataExchangeGetObjectListGistgetObjectListGistAsCsvRequest) (*AggregateDataExchangeGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AggregateDataExchangeGetObjectListGistGetObjectListGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeGetObjectListGistgetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/gist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeGetObjectPropertyRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	property     string
	uid          string
	fields       *[]string
	locale       *string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
	translate    *bool
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiAggregateDataExchangeGetObjectPropertyRequest) Fields(fields []string) ApiAggregateDataExchangeGetObjectPropertyRequest {
	r.fields = &fields
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangeGetObjectPropertyRequest) Locale(locale string) ApiAggregateDataExchangeGetObjectPropertyRequest {
	r.locale = &locale
	return r
}

// Defines which page number to return.
func (r ApiAggregateDataExchangeGetObjectPropertyRequest) Page(page int32) ApiAggregateDataExchangeGetObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiAggregateDataExchangeGetObjectPropertyRequest) PageSize(pageSize int32) ApiAggregateDataExchangeGetObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiAggregateDataExchangeGetObjectPropertyRequest) Paging(paging bool) ApiAggregateDataExchangeGetObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiAggregateDataExchangeGetObjectPropertyRequest) RootJunction(rootJunction string) ApiAggregateDataExchangeGetObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangeGetObjectPropertyRequest) Translate(translate bool) ApiAggregateDataExchangeGetObjectPropertyRequest {
	r.translate = &translate
	return r
}

func (r ApiAggregateDataExchangeGetObjectPropertyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AggregateDataExchangeGetObjectPropertyExecute(r)
}

/*
AggregateDataExchangeGetObjectProperty Method for AggregateDataExchangeGetObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiAggregateDataExchangeGetObjectPropertyRequest
*/
func (a *DataAPIService) AggregateDataExchangeGetObjectProperty(ctx context.Context, property string, uid string) ApiAggregateDataExchangeGetObjectPropertyRequest {
	return ApiAggregateDataExchangeGetObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *DataAPIService) AggregateDataExchangeGetObjectPropertyExecute(r ApiAggregateDataExchangeGetObjectPropertyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeGetObjectProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest) Order(order string) ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest) Page(page int32) ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest) References(references bool) ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest) Total(total bool) ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.AggregateDataExchangeGetObjectPropertyGistAsCsvExecute(r)
}

/*
AggregateDataExchangeGetObjectPropertyGistAsCsv Method for AggregateDataExchangeGetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest
*/
func (a *DataAPIService) AggregateDataExchangeGetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest {
	return ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *DataAPIService) AggregateDataExchangeGetObjectPropertyGistAsCsvExecute(r ApiAggregateDataExchangeGetObjectPropertyGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeGetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/{uid}/{property}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Order(order string) ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Page(page int32) ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) References(references bool) ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Total(total bool) ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Execute() (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.AggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r)
}

/*
AggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsv Method for AggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest
*/
func (a *DataAPIService) AggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	return ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
func (a *DataAPIService) AggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r ApiAggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeGetObjectPropertyGistgetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/{uid}/{property}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeGetSourceDataRequest struct {
	ctx            context.Context
	ApiService     *DataAPIService
	uid            string
	outputIdScheme *string
}

// [no description yet]
func (r ApiAggregateDataExchangeGetSourceDataRequest) OutputIdScheme(outputIdScheme string) ApiAggregateDataExchangeGetSourceDataRequest {
	r.outputIdScheme = &outputIdScheme
	return r
}

func (r ApiAggregateDataExchangeGetSourceDataRequest) Execute() ([]Grid, *http.Response, error) {
	return r.ApiService.AggregateDataExchangeGetSourceDataExecute(r)
}

/*
AggregateDataExchangeGetSourceData Method for AggregateDataExchangeGetSourceData

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiAggregateDataExchangeGetSourceDataRequest
*/
func (a *DataAPIService) AggregateDataExchangeGetSourceData(ctx context.Context, uid string) ApiAggregateDataExchangeGetSourceDataRequest {
	return ApiAggregateDataExchangeGetSourceDataRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return []Grid
func (a *DataAPIService) AggregateDataExchangeGetSourceDataExecute(r ApiAggregateDataExchangeGetSourceDataRequest) ([]Grid, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Grid
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeGetSourceData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/{uid}/sourceData"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.outputIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputIdScheme", r.outputIdScheme, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeGetSourceDataValueSetsRequest struct {
	ctx            context.Context
	ApiService     *DataAPIService
	uid            string
	outputIdScheme *string
}

// [no description yet]
func (r ApiAggregateDataExchangeGetSourceDataValueSetsRequest) OutputIdScheme(outputIdScheme string) ApiAggregateDataExchangeGetSourceDataValueSetsRequest {
	r.outputIdScheme = &outputIdScheme
	return r
}

func (r ApiAggregateDataExchangeGetSourceDataValueSetsRequest) Execute() ([]DataValueSet, *http.Response, error) {
	return r.ApiService.AggregateDataExchangeGetSourceDataValueSetsExecute(r)
}

/*
AggregateDataExchangeGetSourceDataValueSets Method for AggregateDataExchangeGetSourceDataValueSets

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiAggregateDataExchangeGetSourceDataValueSetsRequest
*/
func (a *DataAPIService) AggregateDataExchangeGetSourceDataValueSets(ctx context.Context, uid string) ApiAggregateDataExchangeGetSourceDataValueSetsRequest {
	return ApiAggregateDataExchangeGetSourceDataValueSetsRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return []DataValueSet
func (a *DataAPIService) AggregateDataExchangeGetSourceDataValueSetsExecute(r ApiAggregateDataExchangeGetSourceDataValueSetsRequest) ([]DataValueSet, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []DataValueSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeGetSourceDataValueSets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/{uid}/sourceDataValueSets"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.outputIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputIdScheme", r.outputIdScheme, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangePatchObjectRequest struct {
	ctx                context.Context
	ApiService         *DataAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	jsonPatch          *JsonPatch
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiAggregateDataExchangePatchObjectRequest) AtomicMode(atomicMode string) ApiAggregateDataExchangePatchObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiAggregateDataExchangePatchObjectRequest) FlushMode(flushMode string) ApiAggregateDataExchangePatchObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiAggregateDataExchangePatchObjectRequest) Identifier(identifier string) ApiAggregateDataExchangePatchObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiAggregateDataExchangePatchObjectRequest) ImportMode(importMode string) ApiAggregateDataExchangePatchObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiAggregateDataExchangePatchObjectRequest) ImportReportMode(importReportMode string) ApiAggregateDataExchangePatchObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiAggregateDataExchangePatchObjectRequest) ImportStrategy(importStrategy string) ApiAggregateDataExchangePatchObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiAggregateDataExchangePatchObjectRequest) MergeMode(mergeMode string) ApiAggregateDataExchangePatchObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangePatchObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiAggregateDataExchangePatchObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiAggregateDataExchangePatchObjectRequest) Page(page int32) ApiAggregateDataExchangePatchObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiAggregateDataExchangePatchObjectRequest) PageSize(pageSize int32) ApiAggregateDataExchangePatchObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiAggregateDataExchangePatchObjectRequest) Paging(paging bool) ApiAggregateDataExchangePatchObjectRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiAggregateDataExchangePatchObjectRequest) PreheatMode(preheatMode string) ApiAggregateDataExchangePatchObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiAggregateDataExchangePatchObjectRequest) RootJunction(rootJunction string) ApiAggregateDataExchangePatchObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiAggregateDataExchangePatchObjectRequest) SkipSharing(skipSharing bool) ApiAggregateDataExchangePatchObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangePatchObjectRequest) SkipTranslation(skipTranslation bool) ApiAggregateDataExchangePatchObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiAggregateDataExchangePatchObjectRequest) SkipValidation(skipValidation bool) ApiAggregateDataExchangePatchObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiAggregateDataExchangePatchObjectRequest) UserOverrideMode(userOverrideMode string) ApiAggregateDataExchangePatchObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangePatchObjectRequest) JsonPatch(jsonPatch JsonPatch) ApiAggregateDataExchangePatchObjectRequest {
	r.jsonPatch = &jsonPatch
	return r
}

func (r ApiAggregateDataExchangePatchObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.AggregateDataExchangePatchObjectExecute(r)
}

/*
AggregateDataExchangePatchObject Method for AggregateDataExchangePatchObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiAggregateDataExchangePatchObjectRequest
*/
func (a *DataAPIService) AggregateDataExchangePatchObject(ctx context.Context, uid string) ApiAggregateDataExchangePatchObjectRequest {
	return ApiAggregateDataExchangePatchObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) AggregateDataExchangePatchObjectExecute(r ApiAggregateDataExchangePatchObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangePatchObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest struct {
	ctx                   context.Context
	ApiService            *DataAPIService
	atomicMode            *string
	flushMode             *string
	identifier            *string
	importMode            *string
	importReportMode      *string
	importStrategy        *string
	mergeMode             *string
	metadataSyncImport    *bool
	preheatMode           *string
	skipSharing           *bool
	skipTranslation       *bool
	skipValidation        *bool
	userOverrideMode      *string
	aggregateDataExchange *AggregateDataExchange
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest) AtomicMode(atomicMode string) ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest) FlushMode(flushMode string) ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest) Identifier(identifier string) ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest) ImportMode(importMode string) ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest) ImportReportMode(importReportMode string) ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest) ImportStrategy(importStrategy string) ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest) MergeMode(mergeMode string) ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest) PreheatMode(preheatMode string) ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest) SkipSharing(skipSharing bool) ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest) SkipValidation(skipValidation bool) ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest) AggregateDataExchange(aggregateDataExchange AggregateDataExchange) ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest {
	r.aggregateDataExchange = &aggregateDataExchange
	return r
}

func (r ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.AggregateDataExchangePostJsonObjectpostXmlObjectExecute(r)
}

/*
AggregateDataExchangePostJsonObjectpostXmlObject Method for AggregateDataExchangePostJsonObjectpostXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest
*/
func (a *DataAPIService) AggregateDataExchangePostJsonObjectpostXmlObject(ctx context.Context) ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest {
	return ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) AggregateDataExchangePostJsonObjectpostXmlObjectExecute(r ApiAggregateDataExchangePostJsonObjectpostXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangePostJsonObjectpostXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateDataExchange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest struct {
	ctx                   context.Context
	ApiService            *DataAPIService
	uid                   string
	atomicMode            *string
	flushMode             *string
	identifier            *string
	importMode            *string
	importReportMode      *string
	importStrategy        *string
	mergeMode             *string
	metadataSyncImport    *bool
	preheatMode           *string
	skipSharing           *bool
	skipTranslation       *bool
	skipValidation        *bool
	userOverrideMode      *string
	aggregateDataExchange *AggregateDataExchange
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest) AtomicMode(atomicMode string) ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest) FlushMode(flushMode string) ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest) Identifier(identifier string) ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest) ImportMode(importMode string) ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest) ImportReportMode(importReportMode string) ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest) ImportStrategy(importStrategy string) ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest) MergeMode(mergeMode string) ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest) PreheatMode(preheatMode string) ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest) SkipSharing(skipSharing bool) ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest) SkipValidation(skipValidation bool) ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest) AggregateDataExchange(aggregateDataExchange AggregateDataExchange) ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest {
	r.aggregateDataExchange = &aggregateDataExchange
	return r
}

func (r ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.AggregateDataExchangePutJsonObjectputXmlObjectExecute(r)
}

/*
AggregateDataExchangePutJsonObjectputXmlObject Method for AggregateDataExchangePutJsonObjectputXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest
*/
func (a *DataAPIService) AggregateDataExchangePutJsonObjectputXmlObject(ctx context.Context, uid string) ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest {
	return ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) AggregateDataExchangePutJsonObjectputXmlObjectExecute(r ApiAggregateDataExchangePutJsonObjectputXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangePutJsonObjectputXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateDataExchange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeRemoveAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
}

func (r ApiAggregateDataExchangeRemoveAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.AggregateDataExchangeRemoveAsFavoriteExecute(r)
}

/*
AggregateDataExchangeRemoveAsFavorite Method for AggregateDataExchangeRemoveAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiAggregateDataExchangeRemoveAsFavoriteRequest
*/
func (a *DataAPIService) AggregateDataExchangeRemoveAsFavorite(ctx context.Context, uid string) ApiAggregateDataExchangeRemoveAsFavoriteRequest {
	return ApiAggregateDataExchangeRemoveAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) AggregateDataExchangeRemoveAsFavoriteExecute(r ApiAggregateDataExchangeRemoveAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeRemoveAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *DataAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiAggregateDataExchangeReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiAggregateDataExchangeReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiAggregateDataExchangeReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.AggregateDataExchangeReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r)
}

/*
AggregateDataExchangeReplaceCollectionItemsJsonreplaceCollectionItemsXml Method for AggregateDataExchangeReplaceCollectionItemsJsonreplaceCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiAggregateDataExchangeReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest
*/
func (a *DataAPIService) AggregateDataExchangeReplaceCollectionItemsJsonreplaceCollectionItemsXml(ctx context.Context, property string, uid string) ApiAggregateDataExchangeReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	return ApiAggregateDataExchangeReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) AggregateDataExchangeReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r ApiAggregateDataExchangeReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeReplaceCollectionItemsJsonreplaceCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeReplaceTranslationsRequest struct {
	ctx                                             context.Context
	ApiService                                      *DataAPIService
	uid                                             string
	aggregateDataExchangeReplaceTranslationsRequest *AggregateDataExchangeReplaceTranslationsRequest
}

// [no description yet]
func (r ApiAggregateDataExchangeReplaceTranslationsRequest) AggregateDataExchangeReplaceTranslationsRequest(aggregateDataExchangeReplaceTranslationsRequest AggregateDataExchangeReplaceTranslationsRequest) ApiAggregateDataExchangeReplaceTranslationsRequest {
	r.aggregateDataExchangeReplaceTranslationsRequest = &aggregateDataExchangeReplaceTranslationsRequest
	return r
}

func (r ApiAggregateDataExchangeReplaceTranslationsRequest) Execute() (*http.Response, error) {
	return r.ApiService.AggregateDataExchangeReplaceTranslationsExecute(r)
}

/*
AggregateDataExchangeReplaceTranslations Method for AggregateDataExchangeReplaceTranslations

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiAggregateDataExchangeReplaceTranslationsRequest
*/
func (a *DataAPIService) AggregateDataExchangeReplaceTranslations(ctx context.Context, uid string) ApiAggregateDataExchangeReplaceTranslationsRequest {
	return ApiAggregateDataExchangeReplaceTranslationsRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *DataAPIService) AggregateDataExchangeReplaceTranslationsExecute(r ApiAggregateDataExchangeReplaceTranslationsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeReplaceTranslations")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/{uid}/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateDataExchangeReplaceTranslationsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeRunDataExchangeRequest struct {
	ctx                   context.Context
	ApiService            *DataAPIService
	aggregateDataExchange *AggregateDataExchange
}

// [no description yet]
func (r ApiAggregateDataExchangeRunDataExchangeRequest) AggregateDataExchange(aggregateDataExchange AggregateDataExchange) ApiAggregateDataExchangeRunDataExchangeRequest {
	r.aggregateDataExchange = &aggregateDataExchange
	return r
}

func (r ApiAggregateDataExchangeRunDataExchangeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.AggregateDataExchangeRunDataExchangeExecute(r)
}

/*
AggregateDataExchangeRunDataExchange Method for AggregateDataExchangeRunDataExchange

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAggregateDataExchangeRunDataExchangeRequest
*/
func (a *DataAPIService) AggregateDataExchangeRunDataExchange(ctx context.Context) ApiAggregateDataExchangeRunDataExchangeRequest {
	return ApiAggregateDataExchangeRunDataExchangeRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) AggregateDataExchangeRunDataExchangeExecute(r ApiAggregateDataExchangeRunDataExchangeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeRunDataExchange")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/exchange"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aggregateDataExchange == nil {
		return localVarReturnValue, nil, reportError("aggregateDataExchange is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateDataExchange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeRunDataExchangeByUidRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
}

func (r ApiAggregateDataExchangeRunDataExchangeByUidRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.AggregateDataExchangeRunDataExchangeByUidExecute(r)
}

/*
AggregateDataExchangeRunDataExchangeByUid Method for AggregateDataExchangeRunDataExchangeByUid

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiAggregateDataExchangeRunDataExchangeByUidRequest
*/
func (a *DataAPIService) AggregateDataExchangeRunDataExchangeByUid(ctx context.Context, uid string) ApiAggregateDataExchangeRunDataExchangeByUidRequest {
	return ApiAggregateDataExchangeRunDataExchangeByUidRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) AggregateDataExchangeRunDataExchangeByUidExecute(r ApiAggregateDataExchangeRunDataExchangeByUidRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeRunDataExchangeByUid")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/{uid}/exchange"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeSetAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
}

func (r ApiAggregateDataExchangeSetAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.AggregateDataExchangeSetAsFavoriteExecute(r)
}

/*
AggregateDataExchangeSetAsFavorite Method for AggregateDataExchangeSetAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiAggregateDataExchangeSetAsFavoriteRequest
*/
func (a *DataAPIService) AggregateDataExchangeSetAsFavorite(ctx context.Context, uid string) ApiAggregateDataExchangeSetAsFavoriteRequest {
	return ApiAggregateDataExchangeSetAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) AggregateDataExchangeSetAsFavoriteExecute(r ApiAggregateDataExchangeSetAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeSetAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeSetSharingRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
	sharing    *Sharing
}

// [no description yet]
func (r ApiAggregateDataExchangeSetSharingRequest) Sharing(sharing Sharing) ApiAggregateDataExchangeSetSharingRequest {
	r.sharing = &sharing
	return r
}

func (r ApiAggregateDataExchangeSetSharingRequest) Execute() (*http.Response, error) {
	return r.ApiService.AggregateDataExchangeSetSharingExecute(r)
}

/*
AggregateDataExchangeSetSharing Method for AggregateDataExchangeSetSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiAggregateDataExchangeSetSharingRequest
*/
func (a *DataAPIService) AggregateDataExchangeSetSharing(ctx context.Context, uid string) ApiAggregateDataExchangeSetSharingRequest {
	return ApiAggregateDataExchangeSetSharingRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *DataAPIService) AggregateDataExchangeSetSharingExecute(r ApiAggregateDataExchangeSetSharingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeSetSharing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/{uid}/sharing"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharing
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeSubscribeRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
}

func (r ApiAggregateDataExchangeSubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.AggregateDataExchangeSubscribeExecute(r)
}

/*
AggregateDataExchangeSubscribe Method for AggregateDataExchangeSubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiAggregateDataExchangeSubscribeRequest
*/
func (a *DataAPIService) AggregateDataExchangeSubscribe(ctx context.Context, uid string) ApiAggregateDataExchangeSubscribeRequest {
	return ApiAggregateDataExchangeSubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) AggregateDataExchangeSubscribeExecute(r ApiAggregateDataExchangeSubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeSubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeUnsubscribeRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
}

func (r ApiAggregateDataExchangeUnsubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.AggregateDataExchangeUnsubscribeExecute(r)
}

/*
AggregateDataExchangeUnsubscribe Method for AggregateDataExchangeUnsubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiAggregateDataExchangeUnsubscribeRequest
*/
func (a *DataAPIService) AggregateDataExchangeUnsubscribe(ctx context.Context, uid string) ApiAggregateDataExchangeUnsubscribeRequest {
	return ApiAggregateDataExchangeUnsubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) AggregateDataExchangeUnsubscribeExecute(r ApiAggregateDataExchangeUnsubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeUnsubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAggregateDataExchangeUpdateObjectPropertyRequest struct {
	ctx                   context.Context
	ApiService            *DataAPIService
	property              string
	uid                   string
	atomicMode            *string
	flushMode             *string
	identifier            *string
	importMode            *string
	importReportMode      *string
	importStrategy        *string
	mergeMode             *string
	metadataSyncImport    *bool
	page                  *int32
	pageSize              *int32
	paging                *bool
	preheatMode           *string
	rootJunction          *string
	skipSharing           *bool
	skipTranslation       *bool
	skipValidation        *bool
	userOverrideMode      *string
	aggregateDataExchange *AggregateDataExchange
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiAggregateDataExchangeUpdateObjectPropertyRequest) AtomicMode(atomicMode string) ApiAggregateDataExchangeUpdateObjectPropertyRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiAggregateDataExchangeUpdateObjectPropertyRequest) FlushMode(flushMode string) ApiAggregateDataExchangeUpdateObjectPropertyRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiAggregateDataExchangeUpdateObjectPropertyRequest) Identifier(identifier string) ApiAggregateDataExchangeUpdateObjectPropertyRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiAggregateDataExchangeUpdateObjectPropertyRequest) ImportMode(importMode string) ApiAggregateDataExchangeUpdateObjectPropertyRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiAggregateDataExchangeUpdateObjectPropertyRequest) ImportReportMode(importReportMode string) ApiAggregateDataExchangeUpdateObjectPropertyRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiAggregateDataExchangeUpdateObjectPropertyRequest) ImportStrategy(importStrategy string) ApiAggregateDataExchangeUpdateObjectPropertyRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiAggregateDataExchangeUpdateObjectPropertyRequest) MergeMode(mergeMode string) ApiAggregateDataExchangeUpdateObjectPropertyRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangeUpdateObjectPropertyRequest) MetadataSyncImport(metadataSyncImport bool) ApiAggregateDataExchangeUpdateObjectPropertyRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiAggregateDataExchangeUpdateObjectPropertyRequest) Page(page int32) ApiAggregateDataExchangeUpdateObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiAggregateDataExchangeUpdateObjectPropertyRequest) PageSize(pageSize int32) ApiAggregateDataExchangeUpdateObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiAggregateDataExchangeUpdateObjectPropertyRequest) Paging(paging bool) ApiAggregateDataExchangeUpdateObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiAggregateDataExchangeUpdateObjectPropertyRequest) PreheatMode(preheatMode string) ApiAggregateDataExchangeUpdateObjectPropertyRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiAggregateDataExchangeUpdateObjectPropertyRequest) RootJunction(rootJunction string) ApiAggregateDataExchangeUpdateObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiAggregateDataExchangeUpdateObjectPropertyRequest) SkipSharing(skipSharing bool) ApiAggregateDataExchangeUpdateObjectPropertyRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangeUpdateObjectPropertyRequest) SkipTranslation(skipTranslation bool) ApiAggregateDataExchangeUpdateObjectPropertyRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiAggregateDataExchangeUpdateObjectPropertyRequest) SkipValidation(skipValidation bool) ApiAggregateDataExchangeUpdateObjectPropertyRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiAggregateDataExchangeUpdateObjectPropertyRequest) UserOverrideMode(userOverrideMode string) ApiAggregateDataExchangeUpdateObjectPropertyRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiAggregateDataExchangeUpdateObjectPropertyRequest) AggregateDataExchange(aggregateDataExchange AggregateDataExchange) ApiAggregateDataExchangeUpdateObjectPropertyRequest {
	r.aggregateDataExchange = &aggregateDataExchange
	return r
}

func (r ApiAggregateDataExchangeUpdateObjectPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.AggregateDataExchangeUpdateObjectPropertyExecute(r)
}

/*
AggregateDataExchangeUpdateObjectProperty Method for AggregateDataExchangeUpdateObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiAggregateDataExchangeUpdateObjectPropertyRequest
*/
func (a *DataAPIService) AggregateDataExchangeUpdateObjectProperty(ctx context.Context, property string, uid string) ApiAggregateDataExchangeUpdateObjectPropertyRequest {
	return ApiAggregateDataExchangeUpdateObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
func (a *DataAPIService) AggregateDataExchangeUpdateObjectPropertyExecute(r ApiAggregateDataExchangeUpdateObjectPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AggregateDataExchangeUpdateObjectProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aggregateDataExchanges/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateDataExchange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAuditGetAggregateDataValueAuditRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	auditType  *[]string
	cc         *string
	co         *string
	de         *AuditGetAggregateDataValueAuditDeParameter
	ds         *AuditGetAggregateDataValueAuditDsParameter
	ou         *AuditGetDataApprovalAuditOuParameter
	page       *int32
	pageSize   *int32
	paging     *bool
	pe         *[]string
	skipPaging *bool
}

// [no description yet]
func (r ApiAuditGetAggregateDataValueAuditRequest) AuditType(auditType []string) ApiAuditGetAggregateDataValueAuditRequest {
	r.auditType = &auditType
	return r
}

// [no description yet]
func (r ApiAuditGetAggregateDataValueAuditRequest) Cc(cc string) ApiAuditGetAggregateDataValueAuditRequest {
	r.cc = &cc
	return r
}

// [no description yet]
func (r ApiAuditGetAggregateDataValueAuditRequest) Co(co string) ApiAuditGetAggregateDataValueAuditRequest {
	r.co = &co
	return r
}

// [no description yet]
func (r ApiAuditGetAggregateDataValueAuditRequest) De(de AuditGetAggregateDataValueAuditDeParameter) ApiAuditGetAggregateDataValueAuditRequest {
	r.de = &de
	return r
}

// [no description yet]
func (r ApiAuditGetAggregateDataValueAuditRequest) Ds(ds AuditGetAggregateDataValueAuditDsParameter) ApiAuditGetAggregateDataValueAuditRequest {
	r.ds = &ds
	return r
}

// [no description yet]
func (r ApiAuditGetAggregateDataValueAuditRequest) Ou(ou AuditGetDataApprovalAuditOuParameter) ApiAuditGetAggregateDataValueAuditRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiAuditGetAggregateDataValueAuditRequest) Page(page int32) ApiAuditGetAggregateDataValueAuditRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiAuditGetAggregateDataValueAuditRequest) PageSize(pageSize int32) ApiAuditGetAggregateDataValueAuditRequest {
	r.pageSize = &pageSize
	return r
}

// [no description yet]
func (r ApiAuditGetAggregateDataValueAuditRequest) Paging(paging bool) ApiAuditGetAggregateDataValueAuditRequest {
	r.paging = &paging
	return r
}

// [no description yet]
func (r ApiAuditGetAggregateDataValueAuditRequest) Pe(pe []string) ApiAuditGetAggregateDataValueAuditRequest {
	r.pe = &pe
	return r
}

// [no description yet]
func (r ApiAuditGetAggregateDataValueAuditRequest) SkipPaging(skipPaging bool) ApiAuditGetAggregateDataValueAuditRequest {
	r.skipPaging = &skipPaging
	return r
}

func (r ApiAuditGetAggregateDataValueAuditRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AuditGetAggregateDataValueAuditExecute(r)
}

/*
AuditGetAggregateDataValueAudit Method for AuditGetAggregateDataValueAudit

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAuditGetAggregateDataValueAuditRequest
*/
func (a *DataAPIService) AuditGetAggregateDataValueAudit(ctx context.Context) ApiAuditGetAggregateDataValueAuditRequest {
	return ApiAuditGetAggregateDataValueAuditRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *DataAPIService) AuditGetAggregateDataValueAuditExecute(r ApiAuditGetAggregateDataValueAuditRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AuditGetAggregateDataValueAudit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audits/dataValue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.auditType != nil {
		t := *r.auditType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auditType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auditType", t, "multi")
		}
	}
	if r.cc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cc", r.cc, "")
	}
	if r.co != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "co", r.co, "")
	}
	if r.de != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "de", r.de, "")
	}
	if r.ds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ds", r.ds, "")
	}
	if r.ou != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.pe != nil {
		t := *r.pe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pe", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pe", t, "multi")
		}
	}
	if r.skipPaging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipPaging", r.skipPaging, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuditGetDataApprovalAuditRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	aoc        *AuditGetDataApprovalAuditAocParameter
	dal        *AuditGetDataApprovalAuditDalParameter
	endDate    *time.Time
	ou         *AuditGetDataApprovalAuditOuParameter
	page       *int32
	pageSize   *int32
	paging     *bool
	skipPaging *bool
	startDate  *time.Time
	wf         *AuditGetDataApprovalAuditWfParameter
}

// [no description yet]
func (r ApiAuditGetDataApprovalAuditRequest) Aoc(aoc AuditGetDataApprovalAuditAocParameter) ApiAuditGetDataApprovalAuditRequest {
	r.aoc = &aoc
	return r
}

// [no description yet]
func (r ApiAuditGetDataApprovalAuditRequest) Dal(dal AuditGetDataApprovalAuditDalParameter) ApiAuditGetDataApprovalAuditRequest {
	r.dal = &dal
	return r
}

// [no description yet]
func (r ApiAuditGetDataApprovalAuditRequest) EndDate(endDate time.Time) ApiAuditGetDataApprovalAuditRequest {
	r.endDate = &endDate
	return r
}

// [no description yet]
func (r ApiAuditGetDataApprovalAuditRequest) Ou(ou AuditGetDataApprovalAuditOuParameter) ApiAuditGetDataApprovalAuditRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiAuditGetDataApprovalAuditRequest) Page(page int32) ApiAuditGetDataApprovalAuditRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiAuditGetDataApprovalAuditRequest) PageSize(pageSize int32) ApiAuditGetDataApprovalAuditRequest {
	r.pageSize = &pageSize
	return r
}

// [no description yet]
func (r ApiAuditGetDataApprovalAuditRequest) Paging(paging bool) ApiAuditGetDataApprovalAuditRequest {
	r.paging = &paging
	return r
}

// [no description yet]
func (r ApiAuditGetDataApprovalAuditRequest) SkipPaging(skipPaging bool) ApiAuditGetDataApprovalAuditRequest {
	r.skipPaging = &skipPaging
	return r
}

// [no description yet]
func (r ApiAuditGetDataApprovalAuditRequest) StartDate(startDate time.Time) ApiAuditGetDataApprovalAuditRequest {
	r.startDate = &startDate
	return r
}

// [no description yet]
func (r ApiAuditGetDataApprovalAuditRequest) Wf(wf AuditGetDataApprovalAuditWfParameter) ApiAuditGetDataApprovalAuditRequest {
	r.wf = &wf
	return r
}

func (r ApiAuditGetDataApprovalAuditRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AuditGetDataApprovalAuditExecute(r)
}

/*
AuditGetDataApprovalAudit Method for AuditGetDataApprovalAudit

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAuditGetDataApprovalAuditRequest
*/
func (a *DataAPIService) AuditGetDataApprovalAudit(ctx context.Context) ApiAuditGetDataApprovalAuditRequest {
	return ApiAuditGetDataApprovalAuditRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *DataAPIService) AuditGetDataApprovalAuditExecute(r ApiAuditGetDataApprovalAuditRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AuditGetDataApprovalAudit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audits/dataApproval"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.aoc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aoc", r.aoc, "")
	}
	if r.dal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dal", r.dal, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.ou != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.skipPaging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipPaging", r.skipPaging, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.wf != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wf", r.wf, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuditGetFileAuditRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
}

func (r ApiAuditGetFileAuditRequest) Execute() (*http.Response, error) {
	return r.ApiService.AuditGetFileAuditExecute(r)
}

/*
AuditGetFileAudit Method for AuditGetFileAudit

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiAuditGetFileAuditRequest
*/
func (a *DataAPIService) AuditGetFileAudit(ctx context.Context, uid string) ApiAuditGetFileAuditRequest {
	return ApiAuditGetFileAuditRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *DataAPIService) AuditGetFileAuditExecute(r ApiAuditGetFileAuditRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AuditGetFileAudit")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audits/files/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAuditGetTrackedEnityInstanceAuditRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	auditType  *[]string
	endDate    *time.Time
	page       *int32
	pageSize   *int32
	paging     *bool
	skipPaging *bool
	startDate  *time.Time
	tei        *AuditGetTrackedEntityAttributeValueAuditTeiParameter
	user       *AuditGetTrackedEnityInstanceAuditUserParameter
}

// [no description yet]
func (r ApiAuditGetTrackedEnityInstanceAuditRequest) AuditType(auditType []string) ApiAuditGetTrackedEnityInstanceAuditRequest {
	r.auditType = &auditType
	return r
}

// [no description yet]
func (r ApiAuditGetTrackedEnityInstanceAuditRequest) EndDate(endDate time.Time) ApiAuditGetTrackedEnityInstanceAuditRequest {
	r.endDate = &endDate
	return r
}

// [no description yet]
func (r ApiAuditGetTrackedEnityInstanceAuditRequest) Page(page int32) ApiAuditGetTrackedEnityInstanceAuditRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiAuditGetTrackedEnityInstanceAuditRequest) PageSize(pageSize int32) ApiAuditGetTrackedEnityInstanceAuditRequest {
	r.pageSize = &pageSize
	return r
}

// [no description yet]
func (r ApiAuditGetTrackedEnityInstanceAuditRequest) Paging(paging bool) ApiAuditGetTrackedEnityInstanceAuditRequest {
	r.paging = &paging
	return r
}

// [no description yet]
func (r ApiAuditGetTrackedEnityInstanceAuditRequest) SkipPaging(skipPaging bool) ApiAuditGetTrackedEnityInstanceAuditRequest {
	r.skipPaging = &skipPaging
	return r
}

// [no description yet]
func (r ApiAuditGetTrackedEnityInstanceAuditRequest) StartDate(startDate time.Time) ApiAuditGetTrackedEnityInstanceAuditRequest {
	r.startDate = &startDate
	return r
}

// [no description yet]
func (r ApiAuditGetTrackedEnityInstanceAuditRequest) Tei(tei AuditGetTrackedEntityAttributeValueAuditTeiParameter) ApiAuditGetTrackedEnityInstanceAuditRequest {
	r.tei = &tei
	return r
}

// [no description yet]
func (r ApiAuditGetTrackedEnityInstanceAuditRequest) User(user AuditGetTrackedEnityInstanceAuditUserParameter) ApiAuditGetTrackedEnityInstanceAuditRequest {
	r.user = &user
	return r
}

func (r ApiAuditGetTrackedEnityInstanceAuditRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AuditGetTrackedEnityInstanceAuditExecute(r)
}

/*
AuditGetTrackedEnityInstanceAudit Method for AuditGetTrackedEnityInstanceAudit

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAuditGetTrackedEnityInstanceAuditRequest
*/
func (a *DataAPIService) AuditGetTrackedEnityInstanceAudit(ctx context.Context) ApiAuditGetTrackedEnityInstanceAuditRequest {
	return ApiAuditGetTrackedEnityInstanceAuditRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *DataAPIService) AuditGetTrackedEnityInstanceAuditExecute(r ApiAuditGetTrackedEnityInstanceAuditRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AuditGetTrackedEnityInstanceAudit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audits/trackedEntityInstance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.auditType != nil {
		t := *r.auditType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auditType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auditType", t, "multi")
		}
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.skipPaging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipPaging", r.skipPaging, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.tei != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tei", r.tei, "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuditGetTrackedEntityAttributeValueAuditRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	auditType  *[]string
	page       *int32
	pageSize   *int32
	paging     *bool
	skipPaging *bool
	tea        *AuditGetTrackedEntityAttributeValueAuditTeaParameter
	tei        *AuditGetTrackedEntityAttributeValueAuditTeiParameter
}

// [no description yet]
func (r ApiAuditGetTrackedEntityAttributeValueAuditRequest) AuditType(auditType []string) ApiAuditGetTrackedEntityAttributeValueAuditRequest {
	r.auditType = &auditType
	return r
}

// [no description yet]
func (r ApiAuditGetTrackedEntityAttributeValueAuditRequest) Page(page int32) ApiAuditGetTrackedEntityAttributeValueAuditRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiAuditGetTrackedEntityAttributeValueAuditRequest) PageSize(pageSize int32) ApiAuditGetTrackedEntityAttributeValueAuditRequest {
	r.pageSize = &pageSize
	return r
}

// [no description yet]
func (r ApiAuditGetTrackedEntityAttributeValueAuditRequest) Paging(paging bool) ApiAuditGetTrackedEntityAttributeValueAuditRequest {
	r.paging = &paging
	return r
}

// [no description yet]
func (r ApiAuditGetTrackedEntityAttributeValueAuditRequest) SkipPaging(skipPaging bool) ApiAuditGetTrackedEntityAttributeValueAuditRequest {
	r.skipPaging = &skipPaging
	return r
}

// [no description yet]
func (r ApiAuditGetTrackedEntityAttributeValueAuditRequest) Tea(tea AuditGetTrackedEntityAttributeValueAuditTeaParameter) ApiAuditGetTrackedEntityAttributeValueAuditRequest {
	r.tea = &tea
	return r
}

// [no description yet]
func (r ApiAuditGetTrackedEntityAttributeValueAuditRequest) Tei(tei AuditGetTrackedEntityAttributeValueAuditTeiParameter) ApiAuditGetTrackedEntityAttributeValueAuditRequest {
	r.tei = &tei
	return r
}

func (r ApiAuditGetTrackedEntityAttributeValueAuditRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AuditGetTrackedEntityAttributeValueAuditExecute(r)
}

/*
AuditGetTrackedEntityAttributeValueAudit Method for AuditGetTrackedEntityAttributeValueAudit

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAuditGetTrackedEntityAttributeValueAuditRequest
*/
func (a *DataAPIService) AuditGetTrackedEntityAttributeValueAudit(ctx context.Context) ApiAuditGetTrackedEntityAttributeValueAuditRequest {
	return ApiAuditGetTrackedEntityAttributeValueAuditRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *DataAPIService) AuditGetTrackedEntityAttributeValueAuditExecute(r ApiAuditGetTrackedEntityAttributeValueAuditRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AuditGetTrackedEntityAttributeValueAudit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audits/trackedEntityAttributeValue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.auditType != nil {
		t := *r.auditType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auditType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auditType", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.skipPaging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipPaging", r.skipPaging, "")
	}
	if r.tea != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tea", r.tea, "")
	}
	if r.tei != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tei", r.tei, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuditGetTrackedEntityDataValueAuditRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	auditType  *[]string
	de         *AuditGetAggregateDataValueAuditDeParameter
	endDate    *time.Time
	ou         *AuditGetDataApprovalAuditOuParameter
	ouMode     *string
	page       *int32
	pageSize   *int32
	paging     *bool
	ps         *AuditGetTrackedEntityDataValueAuditPsParameter
	psi        *AuditGetTrackedEntityDataValueAuditPsiParameter
	skipPaging *bool
	startDate  *time.Time
}

// [no description yet]
func (r ApiAuditGetTrackedEntityDataValueAuditRequest) AuditType(auditType []string) ApiAuditGetTrackedEntityDataValueAuditRequest {
	r.auditType = &auditType
	return r
}

// [no description yet]
func (r ApiAuditGetTrackedEntityDataValueAuditRequest) De(de AuditGetAggregateDataValueAuditDeParameter) ApiAuditGetTrackedEntityDataValueAuditRequest {
	r.de = &de
	return r
}

// [no description yet]
func (r ApiAuditGetTrackedEntityDataValueAuditRequest) EndDate(endDate time.Time) ApiAuditGetTrackedEntityDataValueAuditRequest {
	r.endDate = &endDate
	return r
}

// [no description yet]
func (r ApiAuditGetTrackedEntityDataValueAuditRequest) Ou(ou AuditGetDataApprovalAuditOuParameter) ApiAuditGetTrackedEntityDataValueAuditRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiAuditGetTrackedEntityDataValueAuditRequest) OuMode(ouMode string) ApiAuditGetTrackedEntityDataValueAuditRequest {
	r.ouMode = &ouMode
	return r
}

// [no description yet]
func (r ApiAuditGetTrackedEntityDataValueAuditRequest) Page(page int32) ApiAuditGetTrackedEntityDataValueAuditRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiAuditGetTrackedEntityDataValueAuditRequest) PageSize(pageSize int32) ApiAuditGetTrackedEntityDataValueAuditRequest {
	r.pageSize = &pageSize
	return r
}

// [no description yet]
func (r ApiAuditGetTrackedEntityDataValueAuditRequest) Paging(paging bool) ApiAuditGetTrackedEntityDataValueAuditRequest {
	r.paging = &paging
	return r
}

// [no description yet]
func (r ApiAuditGetTrackedEntityDataValueAuditRequest) Ps(ps AuditGetTrackedEntityDataValueAuditPsParameter) ApiAuditGetTrackedEntityDataValueAuditRequest {
	r.ps = &ps
	return r
}

// [no description yet]
func (r ApiAuditGetTrackedEntityDataValueAuditRequest) Psi(psi AuditGetTrackedEntityDataValueAuditPsiParameter) ApiAuditGetTrackedEntityDataValueAuditRequest {
	r.psi = &psi
	return r
}

// [no description yet]
func (r ApiAuditGetTrackedEntityDataValueAuditRequest) SkipPaging(skipPaging bool) ApiAuditGetTrackedEntityDataValueAuditRequest {
	r.skipPaging = &skipPaging
	return r
}

// [no description yet]
func (r ApiAuditGetTrackedEntityDataValueAuditRequest) StartDate(startDate time.Time) ApiAuditGetTrackedEntityDataValueAuditRequest {
	r.startDate = &startDate
	return r
}

func (r ApiAuditGetTrackedEntityDataValueAuditRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AuditGetTrackedEntityDataValueAuditExecute(r)
}

/*
AuditGetTrackedEntityDataValueAudit Method for AuditGetTrackedEntityDataValueAudit

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAuditGetTrackedEntityDataValueAuditRequest
*/
func (a *DataAPIService) AuditGetTrackedEntityDataValueAudit(ctx context.Context) ApiAuditGetTrackedEntityDataValueAuditRequest {
	return ApiAuditGetTrackedEntityDataValueAuditRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *DataAPIService) AuditGetTrackedEntityDataValueAuditExecute(r ApiAuditGetTrackedEntityDataValueAuditRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.AuditGetTrackedEntityDataValueAudit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audits/trackedEntityDataValue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.auditType != nil {
		t := *r.auditType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auditType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auditType", t, "multi")
		}
	}
	if r.de != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "de", r.de, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.ou != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	}
	if r.ouMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ouMode", r.ouMode, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.ps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ps", r.ps, "")
	}
	if r.psi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "psi", r.psi, "")
	}
	if r.skipPaging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipPaging", r.skipPaging, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCompleteDataSetRegistrationDeleteCompleteDataSetRegistrationRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	ds         *[]string
	ou         *string
	pe         *string
	cc         *string
	cp         *string
	multiOu    *bool
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationDeleteCompleteDataSetRegistrationRequest) Ds(ds []string) ApiCompleteDataSetRegistrationDeleteCompleteDataSetRegistrationRequest {
	r.ds = &ds
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationDeleteCompleteDataSetRegistrationRequest) Ou(ou string) ApiCompleteDataSetRegistrationDeleteCompleteDataSetRegistrationRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationDeleteCompleteDataSetRegistrationRequest) Pe(pe string) ApiCompleteDataSetRegistrationDeleteCompleteDataSetRegistrationRequest {
	r.pe = &pe
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationDeleteCompleteDataSetRegistrationRequest) Cc(cc string) ApiCompleteDataSetRegistrationDeleteCompleteDataSetRegistrationRequest {
	r.cc = &cc
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationDeleteCompleteDataSetRegistrationRequest) Cp(cp string) ApiCompleteDataSetRegistrationDeleteCompleteDataSetRegistrationRequest {
	r.cp = &cp
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationDeleteCompleteDataSetRegistrationRequest) MultiOu(multiOu bool) ApiCompleteDataSetRegistrationDeleteCompleteDataSetRegistrationRequest {
	r.multiOu = &multiOu
	return r
}

func (r ApiCompleteDataSetRegistrationDeleteCompleteDataSetRegistrationRequest) Execute() (*http.Response, error) {
	return r.ApiService.CompleteDataSetRegistrationDeleteCompleteDataSetRegistrationExecute(r)
}

/*
CompleteDataSetRegistrationDeleteCompleteDataSetRegistration Method for CompleteDataSetRegistrationDeleteCompleteDataSetRegistration

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCompleteDataSetRegistrationDeleteCompleteDataSetRegistrationRequest
*/
func (a *DataAPIService) CompleteDataSetRegistrationDeleteCompleteDataSetRegistration(ctx context.Context) ApiCompleteDataSetRegistrationDeleteCompleteDataSetRegistrationRequest {
	return ApiCompleteDataSetRegistrationDeleteCompleteDataSetRegistrationRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) CompleteDataSetRegistrationDeleteCompleteDataSetRegistrationExecute(r ApiCompleteDataSetRegistrationDeleteCompleteDataSetRegistrationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.CompleteDataSetRegistrationDeleteCompleteDataSetRegistration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/completeDataSetRegistrations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ds == nil {
		return nil, reportError("ds is required and must be specified")
	}
	if r.ou == nil {
		return nil, reportError("ou is required and must be specified")
	}
	if r.pe == nil {
		return nil, reportError("pe is required and must be specified")
	}

	if r.cc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cc", r.cc, "")
	}
	if r.cp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cp", r.cp, "")
	}
	{
		t := *r.ds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ds", t, "multi")
		}
	}
	if r.multiOu != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "multiOu", r.multiOu, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pe", r.pe, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest struct {
	ctx             context.Context
	ApiService      *DataAPIService
	dataSet         *[]string
	children        *bool
	created         *time.Time
	createdDuration *string
	endDate         *time.Time
	idScheme        *string
	limit           *int32
	orgUnit         *[]string
	orgUnitGroup    *[]string
	period          *[]string
	startDate       *time.Time
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest) DataSet(dataSet []string) ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest {
	r.dataSet = &dataSet
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest) Children(children bool) ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest {
	r.children = &children
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest) Created(created time.Time) ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest {
	r.created = &created
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest) CreatedDuration(createdDuration string) ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest {
	r.createdDuration = &createdDuration
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest) EndDate(endDate time.Time) ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest {
	r.endDate = &endDate
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest) IdScheme(idScheme string) ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest {
	r.idScheme = &idScheme
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest) Limit(limit int32) ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest {
	r.limit = &limit
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest) OrgUnit(orgUnit []string) ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest {
	r.orgUnit = &orgUnit
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest) OrgUnitGroup(orgUnitGroup []string) ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest {
	r.orgUnitGroup = &orgUnitGroup
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest) Period(period []string) ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest {
	r.period = &period
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest) StartDate(startDate time.Time) ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest {
	r.startDate = &startDate
	return r
}

func (r ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest) Execute() (*http.Response, error) {
	return r.ApiService.CompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonExecute(r)
}

/*
CompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJson Method for CompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJson

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest
*/
func (a *DataAPIService) CompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJson(ctx context.Context) ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest {
	return ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) CompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonExecute(r ApiCompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJsonRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.CompleteDataSetRegistrationGetCompleteRegistrationsXmlgetCompleteRegistrationsJson")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/completeDataSetRegistrations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataSet == nil {
		return nil, reportError("dataSet is required and must be specified")
	}

	if r.children != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "children", r.children, "")
	}
	if r.created != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created", r.created, "")
	}
	if r.createdDuration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdDuration", r.createdDuration, "")
	}
	{
		t := *r.dataSet
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dataSet", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dataSet", t, "multi")
		}
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.idScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idScheme", r.idScheme, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.orgUnit != nil {
		t := *r.orgUnit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orgUnit", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orgUnit", t, "multi")
		}
	}
	if r.orgUnitGroup != nil {
		t := *r.orgUnitGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orgUnitGroup", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orgUnitGroup", t, "multi")
		}
	}
	if r.period != nil {
		t := *r.period
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "period", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "period", t, "multi")
		}
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest struct {
	ctx                            context.Context
	ApiService                     *DataAPIService
	async                          *bool
	categoryIdScheme               *string
	categoryOptionComboIdScheme    *string
	categoryOptionIdScheme         *string
	dataElementIdScheme            *string
	dataSet                        *string
	dataSetIdScheme                *string
	datasetAllowsPeriods           *bool
	dryRun                         *bool
	eventIdScheme                  *string
	filename                       *string
	firstRowIsHeader               *bool
	force                          *bool
	idScheme                       *string
	ignoreEmptyCollection          *bool
	importStrategy                 *string
	mergeDataValues                *bool
	mergeMode                      *string
	notificationLevel              *string
	orgUnitIdScheme                *string
	preheatCache                   *bool
	programIdScheme                *string
	programStageIdScheme           *string
	reportMode                     *string
	requireAttributeOptionCombo    *bool
	requireCategoryOptionCombo     *bool
	sharing                        *bool
	skipAudit                      *bool
	skipCache                      *bool
	skipExistingCheck              *bool
	skipLastUpdated                *bool
	skipNotifications              *bool
	skipPatternValidation          *bool
	strictAttributeOptionCombos    *bool
	strictCategoryOptionCombos     *bool
	strictDataElements             *bool
	strictDataSetApproval          *bool
	strictDataSetInputPeriods      *bool
	strictDataSetLocking           *bool
	strictOrganisationUnits        *bool
	strictPeriods                  *bool
	trackedEntityAttributeIdScheme *string
	trackedEntityIdScheme          *string
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) Async(async bool) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.async = &async
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) CategoryIdScheme(categoryIdScheme string) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.categoryIdScheme = &categoryIdScheme
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) CategoryOptionComboIdScheme(categoryOptionComboIdScheme string) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.categoryOptionComboIdScheme = &categoryOptionComboIdScheme
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) CategoryOptionIdScheme(categoryOptionIdScheme string) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.categoryOptionIdScheme = &categoryOptionIdScheme
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) DataElementIdScheme(dataElementIdScheme string) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.dataElementIdScheme = &dataElementIdScheme
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) DataSet(dataSet string) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.dataSet = &dataSet
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) DataSetIdScheme(dataSetIdScheme string) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.dataSetIdScheme = &dataSetIdScheme
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) DatasetAllowsPeriods(datasetAllowsPeriods bool) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.datasetAllowsPeriods = &datasetAllowsPeriods
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) DryRun(dryRun bool) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.dryRun = &dryRun
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) EventIdScheme(eventIdScheme string) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.eventIdScheme = &eventIdScheme
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) Filename(filename string) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.filename = &filename
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) FirstRowIsHeader(firstRowIsHeader bool) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.firstRowIsHeader = &firstRowIsHeader
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) Force(force bool) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.force = &force
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) IdScheme(idScheme string) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.idScheme = &idScheme
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) IgnoreEmptyCollection(ignoreEmptyCollection bool) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.ignoreEmptyCollection = &ignoreEmptyCollection
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) ImportStrategy(importStrategy string) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.importStrategy = &importStrategy
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) MergeDataValues(mergeDataValues bool) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.mergeDataValues = &mergeDataValues
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) MergeMode(mergeMode string) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) NotificationLevel(notificationLevel string) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.notificationLevel = &notificationLevel
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) OrgUnitIdScheme(orgUnitIdScheme string) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.orgUnitIdScheme = &orgUnitIdScheme
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) PreheatCache(preheatCache bool) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.preheatCache = &preheatCache
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) ProgramIdScheme(programIdScheme string) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.programIdScheme = &programIdScheme
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) ProgramStageIdScheme(programStageIdScheme string) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.programStageIdScheme = &programStageIdScheme
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) ReportMode(reportMode string) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.reportMode = &reportMode
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) RequireAttributeOptionCombo(requireAttributeOptionCombo bool) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.requireAttributeOptionCombo = &requireAttributeOptionCombo
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) RequireCategoryOptionCombo(requireCategoryOptionCombo bool) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.requireCategoryOptionCombo = &requireCategoryOptionCombo
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) Sharing(sharing bool) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.sharing = &sharing
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) SkipAudit(skipAudit bool) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.skipAudit = &skipAudit
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) SkipCache(skipCache bool) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.skipCache = &skipCache
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) SkipExistingCheck(skipExistingCheck bool) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.skipExistingCheck = &skipExistingCheck
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) SkipLastUpdated(skipLastUpdated bool) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.skipLastUpdated = &skipLastUpdated
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) SkipNotifications(skipNotifications bool) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.skipNotifications = &skipNotifications
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) SkipPatternValidation(skipPatternValidation bool) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.skipPatternValidation = &skipPatternValidation
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) StrictAttributeOptionCombos(strictAttributeOptionCombos bool) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.strictAttributeOptionCombos = &strictAttributeOptionCombos
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) StrictCategoryOptionCombos(strictCategoryOptionCombos bool) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.strictCategoryOptionCombos = &strictCategoryOptionCombos
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) StrictDataElements(strictDataElements bool) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.strictDataElements = &strictDataElements
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) StrictDataSetApproval(strictDataSetApproval bool) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.strictDataSetApproval = &strictDataSetApproval
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) StrictDataSetInputPeriods(strictDataSetInputPeriods bool) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.strictDataSetInputPeriods = &strictDataSetInputPeriods
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) StrictDataSetLocking(strictDataSetLocking bool) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.strictDataSetLocking = &strictDataSetLocking
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) StrictOrganisationUnits(strictOrganisationUnits bool) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.strictOrganisationUnits = &strictOrganisationUnits
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) StrictPeriods(strictPeriods bool) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.strictPeriods = &strictPeriods
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) TrackedEntityAttributeIdScheme(trackedEntityAttributeIdScheme string) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.trackedEntityAttributeIdScheme = &trackedEntityAttributeIdScheme
	return r
}

// [no description yet]
func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) TrackedEntityIdScheme(trackedEntityIdScheme string) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	r.trackedEntityIdScheme = &trackedEntityIdScheme
	return r
}

func (r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.CompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonExecute(r)
}

/*
CompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJson Method for CompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJson

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest
*/
func (a *DataAPIService) CompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJson(ctx context.Context) ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest {
	return ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) CompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonExecute(r ApiCompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJsonRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.CompleteDataSetRegistrationPostCompleteRegistrationsXmlpostCompleteRegistrationsJson")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/completeDataSetRegistrations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	if r.categoryIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIdScheme", r.categoryIdScheme, "")
	}
	if r.categoryOptionComboIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryOptionComboIdScheme", r.categoryOptionComboIdScheme, "")
	}
	if r.categoryOptionIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryOptionIdScheme", r.categoryOptionIdScheme, "")
	}
	if r.dataElementIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataElementIdScheme", r.dataElementIdScheme, "")
	}
	if r.dataSet != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSet", r.dataSet, "")
	}
	if r.dataSetIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSetIdScheme", r.dataSetIdScheme, "")
	}
	if r.datasetAllowsPeriods != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "datasetAllowsPeriods", r.datasetAllowsPeriods, "")
	} else {
		var defaultValue bool = false
		r.datasetAllowsPeriods = &defaultValue
	}
	if r.dryRun != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dryRun", r.dryRun, "")
	} else {
		var defaultValue bool = false
		r.dryRun = &defaultValue
	}
	if r.eventIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventIdScheme", r.eventIdScheme, "")
	}
	if r.filename != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filename", r.filename, "")
	}
	if r.firstRowIsHeader != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstRowIsHeader", r.firstRowIsHeader, "")
	} else {
		var defaultValue bool = true
		r.firstRowIsHeader = &defaultValue
	}
	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	} else {
		var defaultValue bool = false
		r.force = &defaultValue
	}
	if r.idScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idScheme", r.idScheme, "")
	}
	if r.ignoreEmptyCollection != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignoreEmptyCollection", r.ignoreEmptyCollection, "")
	} else {
		var defaultValue bool = false
		r.ignoreEmptyCollection = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeDataValues != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeDataValues", r.mergeDataValues, "")
	} else {
		var defaultValue bool = false
		r.mergeDataValues = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.notificationLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notificationLevel", r.notificationLevel, "")
	}
	if r.orgUnitIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orgUnitIdScheme", r.orgUnitIdScheme, "")
	}
	if r.preheatCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatCache", r.preheatCache, "")
	}
	if r.programIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "programIdScheme", r.programIdScheme, "")
	}
	if r.programStageIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "programStageIdScheme", r.programStageIdScheme, "")
	}
	if r.reportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reportMode", r.reportMode, "")
	} else {
		var defaultValue string = "FULL"
		r.reportMode = &defaultValue
	}
	if r.requireAttributeOptionCombo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireAttributeOptionCombo", r.requireAttributeOptionCombo, "")
	} else {
		var defaultValue bool = false
		r.requireAttributeOptionCombo = &defaultValue
	}
	if r.requireCategoryOptionCombo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireCategoryOptionCombo", r.requireCategoryOptionCombo, "")
	} else {
		var defaultValue bool = false
		r.requireCategoryOptionCombo = &defaultValue
	}
	if r.sharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sharing", r.sharing, "")
	} else {
		var defaultValue bool = false
		r.sharing = &defaultValue
	}
	if r.skipAudit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipAudit", r.skipAudit, "")
	} else {
		var defaultValue bool = false
		r.skipAudit = &defaultValue
	}
	if r.skipCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipCache", r.skipCache, "")
	} else {
		var defaultValue bool = false
		r.skipCache = &defaultValue
	}
	if r.skipExistingCheck != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipExistingCheck", r.skipExistingCheck, "")
	} else {
		var defaultValue bool = false
		r.skipExistingCheck = &defaultValue
	}
	if r.skipLastUpdated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipLastUpdated", r.skipLastUpdated, "")
	} else {
		var defaultValue bool = false
		r.skipLastUpdated = &defaultValue
	}
	if r.skipNotifications != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipNotifications", r.skipNotifications, "")
	} else {
		var defaultValue bool = false
		r.skipNotifications = &defaultValue
	}
	if r.skipPatternValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipPatternValidation", r.skipPatternValidation, "")
	} else {
		var defaultValue bool = false
		r.skipPatternValidation = &defaultValue
	}
	if r.strictAttributeOptionCombos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strictAttributeOptionCombos", r.strictAttributeOptionCombos, "")
	} else {
		var defaultValue bool = false
		r.strictAttributeOptionCombos = &defaultValue
	}
	if r.strictCategoryOptionCombos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strictCategoryOptionCombos", r.strictCategoryOptionCombos, "")
	} else {
		var defaultValue bool = false
		r.strictCategoryOptionCombos = &defaultValue
	}
	if r.strictDataElements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strictDataElements", r.strictDataElements, "")
	} else {
		var defaultValue bool = false
		r.strictDataElements = &defaultValue
	}
	if r.strictDataSetApproval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strictDataSetApproval", r.strictDataSetApproval, "")
	} else {
		var defaultValue bool = false
		r.strictDataSetApproval = &defaultValue
	}
	if r.strictDataSetInputPeriods != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strictDataSetInputPeriods", r.strictDataSetInputPeriods, "")
	} else {
		var defaultValue bool = false
		r.strictDataSetInputPeriods = &defaultValue
	}
	if r.strictDataSetLocking != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strictDataSetLocking", r.strictDataSetLocking, "")
	} else {
		var defaultValue bool = false
		r.strictDataSetLocking = &defaultValue
	}
	if r.strictOrganisationUnits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strictOrganisationUnits", r.strictOrganisationUnits, "")
	} else {
		var defaultValue bool = false
		r.strictOrganisationUnits = &defaultValue
	}
	if r.strictPeriods != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strictPeriods", r.strictPeriods, "")
	} else {
		var defaultValue bool = false
		r.strictPeriods = &defaultValue
	}
	if r.trackedEntityAttributeIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trackedEntityAttributeIdScheme", r.trackedEntityAttributeIdScheme, "")
	}
	if r.trackedEntityIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trackedEntityIdScheme", r.trackedEntityIdScheme, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/xml;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCustomDataEntryFormGetFormRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
}

func (r ApiCustomDataEntryFormGetFormRequest) Execute() (*CustomDataEntryFormDto, *http.Response, error) {
	return r.ApiService.CustomDataEntryFormGetFormExecute(r)
}

/*
CustomDataEntryFormGetForm Method for CustomDataEntryFormGetForm

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiCustomDataEntryFormGetFormRequest
*/
func (a *DataAPIService) CustomDataEntryFormGetForm(ctx context.Context, uid string) ApiCustomDataEntryFormGetFormRequest {
	return ApiCustomDataEntryFormGetFormRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return CustomDataEntryFormDto
func (a *DataAPIService) CustomDataEntryFormGetFormExecute(r ApiCustomDataEntryFormGetFormRequest) (*CustomDataEntryFormDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CustomDataEntryFormDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.CustomDataEntryFormGetForm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataEntry/customForms/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataAnalysisGetCSVReportRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
}

func (r ApiDataAnalysisGetCSVReportRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataAnalysisGetCSVReportExecute(r)
}

/*
DataAnalysisGetCSVReport Method for DataAnalysisGetCSVReport

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataAnalysisGetCSVReportRequest
*/
func (a *DataAPIService) DataAnalysisGetCSVReport(ctx context.Context) ApiDataAnalysisGetCSVReportRequest {
	return ApiDataAnalysisGetCSVReportRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) DataAnalysisGetCSVReportExecute(r ApiDataAnalysisGetCSVReportRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataAnalysisGetCSVReport")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataAnalysis/report.csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataAnalysisGetPdfReportRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
}

func (r ApiDataAnalysisGetPdfReportRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataAnalysisGetPdfReportExecute(r)
}

/*
DataAnalysisGetPdfReport Method for DataAnalysisGetPdfReport

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataAnalysisGetPdfReportRequest
*/
func (a *DataAPIService) DataAnalysisGetPdfReport(ctx context.Context) ApiDataAnalysisGetPdfReportRequest {
	return ApiDataAnalysisGetPdfReportRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) DataAnalysisGetPdfReportExecute(r ApiDataAnalysisGetPdfReportRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataAnalysisGetPdfReport")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataAnalysis/report.pdf"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataAnalysisGetValidationRuleExpressionDetialsRequest struct {
	ctx                    context.Context
	ApiService             *DataAPIService
	organisationUnitId     *string
	periodId               *string
	validationRuleId       *string
	attributeOptionComboId *string
}

// [no description yet]
func (r ApiDataAnalysisGetValidationRuleExpressionDetialsRequest) OrganisationUnitId(organisationUnitId string) ApiDataAnalysisGetValidationRuleExpressionDetialsRequest {
	r.organisationUnitId = &organisationUnitId
	return r
}

// [no description yet]
func (r ApiDataAnalysisGetValidationRuleExpressionDetialsRequest) PeriodId(periodId string) ApiDataAnalysisGetValidationRuleExpressionDetialsRequest {
	r.periodId = &periodId
	return r
}

// [no description yet]
func (r ApiDataAnalysisGetValidationRuleExpressionDetialsRequest) ValidationRuleId(validationRuleId string) ApiDataAnalysisGetValidationRuleExpressionDetialsRequest {
	r.validationRuleId = &validationRuleId
	return r
}

// [no description yet]
func (r ApiDataAnalysisGetValidationRuleExpressionDetialsRequest) AttributeOptionComboId(attributeOptionComboId string) ApiDataAnalysisGetValidationRuleExpressionDetialsRequest {
	r.attributeOptionComboId = &attributeOptionComboId
	return r
}

func (r ApiDataAnalysisGetValidationRuleExpressionDetialsRequest) Execute() (*ValidationRuleExpressionDetails, *http.Response, error) {
	return r.ApiService.DataAnalysisGetValidationRuleExpressionDetialsExecute(r)
}

/*
DataAnalysisGetValidationRuleExpressionDetials Method for DataAnalysisGetValidationRuleExpressionDetials

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataAnalysisGetValidationRuleExpressionDetialsRequest
*/
func (a *DataAPIService) DataAnalysisGetValidationRuleExpressionDetials(ctx context.Context) ApiDataAnalysisGetValidationRuleExpressionDetialsRequest {
	return ApiDataAnalysisGetValidationRuleExpressionDetialsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ValidationRuleExpressionDetails
func (a *DataAPIService) DataAnalysisGetValidationRuleExpressionDetialsExecute(r ApiDataAnalysisGetValidationRuleExpressionDetialsRequest) (*ValidationRuleExpressionDetails, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ValidationRuleExpressionDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataAnalysisGetValidationRuleExpressionDetials")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataAnalysis/validationRulesExpression"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.organisationUnitId == nil {
		return localVarReturnValue, nil, reportError("organisationUnitId is required and must be specified")
	}
	if strlen(*r.organisationUnitId) < 11 {
		return localVarReturnValue, nil, reportError("organisationUnitId must have at least 11 elements")
	}
	if strlen(*r.organisationUnitId) > 11 {
		return localVarReturnValue, nil, reportError("organisationUnitId must have less than 11 elements")
	}
	if r.periodId == nil {
		return localVarReturnValue, nil, reportError("periodId is required and must be specified")
	}
	if r.validationRuleId == nil {
		return localVarReturnValue, nil, reportError("validationRuleId is required and must be specified")
	}
	if strlen(*r.validationRuleId) < 11 {
		return localVarReturnValue, nil, reportError("validationRuleId must have at least 11 elements")
	}
	if strlen(*r.validationRuleId) > 11 {
		return localVarReturnValue, nil, reportError("validationRuleId must have less than 11 elements")
	}

	if r.attributeOptionComboId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attributeOptionComboId", r.attributeOptionComboId, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "organisationUnitId", r.organisationUnitId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "periodId", r.periodId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "validationRuleId", r.validationRuleId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataAnalysisGetValidationRulesCSVReportRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
}

func (r ApiDataAnalysisGetValidationRulesCSVReportRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataAnalysisGetValidationRulesCSVReportExecute(r)
}

/*
DataAnalysisGetValidationRulesCSVReport Method for DataAnalysisGetValidationRulesCSVReport

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataAnalysisGetValidationRulesCSVReportRequest
*/
func (a *DataAPIService) DataAnalysisGetValidationRulesCSVReport(ctx context.Context) ApiDataAnalysisGetValidationRulesCSVReportRequest {
	return ApiDataAnalysisGetValidationRulesCSVReportRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) DataAnalysisGetValidationRulesCSVReportExecute(r ApiDataAnalysisGetValidationRulesCSVReportRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataAnalysisGetValidationRulesCSVReport")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataAnalysis/validationRules/report.csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataAnalysisGetValidationRulesPdfReportRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
}

func (r ApiDataAnalysisGetValidationRulesPdfReportRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataAnalysisGetValidationRulesPdfReportExecute(r)
}

/*
DataAnalysisGetValidationRulesPdfReport Method for DataAnalysisGetValidationRulesPdfReport

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataAnalysisGetValidationRulesPdfReportRequest
*/
func (a *DataAPIService) DataAnalysisGetValidationRulesPdfReport(ctx context.Context) ApiDataAnalysisGetValidationRulesPdfReportRequest {
	return ApiDataAnalysisGetValidationRulesPdfReportRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) DataAnalysisGetValidationRulesPdfReportExecute(r ApiDataAnalysisGetValidationRulesPdfReportRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataAnalysisGetValidationRulesPdfReport")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataAnalysis/validationRules/report.pdf"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataAnalysisGetValidationRulesXlsReportRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
}

func (r ApiDataAnalysisGetValidationRulesXlsReportRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataAnalysisGetValidationRulesXlsReportExecute(r)
}

/*
DataAnalysisGetValidationRulesXlsReport Method for DataAnalysisGetValidationRulesXlsReport

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataAnalysisGetValidationRulesXlsReportRequest
*/
func (a *DataAPIService) DataAnalysisGetValidationRulesXlsReport(ctx context.Context) ApiDataAnalysisGetValidationRulesXlsReportRequest {
	return ApiDataAnalysisGetValidationRulesXlsReportRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) DataAnalysisGetValidationRulesXlsReportExecute(r ApiDataAnalysisGetValidationRulesXlsReportRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataAnalysisGetValidationRulesXlsReport")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataAnalysis/validationRules/report.xls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataAnalysisGetXlsReportRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
}

func (r ApiDataAnalysisGetXlsReportRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataAnalysisGetXlsReportExecute(r)
}

/*
DataAnalysisGetXlsReport Method for DataAnalysisGetXlsReport

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataAnalysisGetXlsReportRequest
*/
func (a *DataAPIService) DataAnalysisGetXlsReport(ctx context.Context) ApiDataAnalysisGetXlsReportRequest {
	return ApiDataAnalysisGetXlsReportRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) DataAnalysisGetXlsReportExecute(r ApiDataAnalysisGetXlsReportRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataAnalysisGetXlsReport")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataAnalysis/report.xls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataAnalysisMarkDataValuesRequest struct {
	ctx                                context.Context
	ApiService                         *DataAPIService
	updateFollowUpForDataValuesRequest *UpdateFollowUpForDataValuesRequest
}

// [no description yet]
func (r ApiDataAnalysisMarkDataValuesRequest) UpdateFollowUpForDataValuesRequest(updateFollowUpForDataValuesRequest UpdateFollowUpForDataValuesRequest) ApiDataAnalysisMarkDataValuesRequest {
	r.updateFollowUpForDataValuesRequest = &updateFollowUpForDataValuesRequest
	return r
}

func (r ApiDataAnalysisMarkDataValuesRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataAnalysisMarkDataValuesExecute(r)
}

/*
DataAnalysisMarkDataValues Method for DataAnalysisMarkDataValues

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataAnalysisMarkDataValuesRequest
*/
func (a *DataAPIService) DataAnalysisMarkDataValues(ctx context.Context) ApiDataAnalysisMarkDataValuesRequest {
	return ApiDataAnalysisMarkDataValuesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) DataAnalysisMarkDataValuesExecute(r ApiDataAnalysisMarkDataValuesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataAnalysisMarkDataValues")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataAnalysis/followup/mark"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFollowUpForDataValuesRequest == nil {
		return nil, reportError("updateFollowUpForDataValuesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFollowUpForDataValuesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataAnalysisPerformFollowupAnalysisRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	coc        *[]string
	de         *[]string
	ds         *[]string
	endDate    *time.Time
	maxResults *int32
	ou         *[]string
	pe         *string
	startDate  *time.Time
}

// [no description yet]
func (r ApiDataAnalysisPerformFollowupAnalysisRequest) Coc(coc []string) ApiDataAnalysisPerformFollowupAnalysisRequest {
	r.coc = &coc
	return r
}

// [no description yet]
func (r ApiDataAnalysisPerformFollowupAnalysisRequest) De(de []string) ApiDataAnalysisPerformFollowupAnalysisRequest {
	r.de = &de
	return r
}

// [no description yet]
func (r ApiDataAnalysisPerformFollowupAnalysisRequest) Ds(ds []string) ApiDataAnalysisPerformFollowupAnalysisRequest {
	r.ds = &ds
	return r
}

// [no description yet]
func (r ApiDataAnalysisPerformFollowupAnalysisRequest) EndDate(endDate time.Time) ApiDataAnalysisPerformFollowupAnalysisRequest {
	r.endDate = &endDate
	return r
}

// [no description yet]
func (r ApiDataAnalysisPerformFollowupAnalysisRequest) MaxResults(maxResults int32) ApiDataAnalysisPerformFollowupAnalysisRequest {
	r.maxResults = &maxResults
	return r
}

// [no description yet]
func (r ApiDataAnalysisPerformFollowupAnalysisRequest) Ou(ou []string) ApiDataAnalysisPerformFollowupAnalysisRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiDataAnalysisPerformFollowupAnalysisRequest) Pe(pe string) ApiDataAnalysisPerformFollowupAnalysisRequest {
	r.pe = &pe
	return r
}

// [no description yet]
func (r ApiDataAnalysisPerformFollowupAnalysisRequest) StartDate(startDate time.Time) ApiDataAnalysisPerformFollowupAnalysisRequest {
	r.startDate = &startDate
	return r
}

func (r ApiDataAnalysisPerformFollowupAnalysisRequest) Execute() (*FollowupAnalysisResponse, *http.Response, error) {
	return r.ApiService.DataAnalysisPerformFollowupAnalysisExecute(r)
}

/*
DataAnalysisPerformFollowupAnalysis Method for DataAnalysisPerformFollowupAnalysis

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataAnalysisPerformFollowupAnalysisRequest
*/
func (a *DataAPIService) DataAnalysisPerformFollowupAnalysis(ctx context.Context) ApiDataAnalysisPerformFollowupAnalysisRequest {
	return ApiDataAnalysisPerformFollowupAnalysisRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FollowupAnalysisResponse
func (a *DataAPIService) DataAnalysisPerformFollowupAnalysisExecute(r ApiDataAnalysisPerformFollowupAnalysisRequest) (*FollowupAnalysisResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FollowupAnalysisResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataAnalysisPerformFollowupAnalysis")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataAnalysis/followup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.coc != nil {
		t := *r.coc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "coc", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "coc", t, "multi")
		}
	}
	if r.de != nil {
		t := *r.de
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "de", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "de", t, "multi")
		}
	}
	if r.ds != nil {
		t := *r.ds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ds", t, "multi")
		}
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	} else {
		var defaultValue int32 = 50
		r.maxResults = &defaultValue
	}
	if r.ou != nil {
		t := *r.ou
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ou", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ou", t, "multi")
		}
	}
	if r.pe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pe", r.pe, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataAnalysisPerformFollowupAnalysis2Request struct {
	ctx                context.Context
	ApiService         *DataAPIService
	dataAnalysisParams *DataAnalysisParams
}

// [no description yet]
func (r ApiDataAnalysisPerformFollowupAnalysis2Request) DataAnalysisParams(dataAnalysisParams DataAnalysisParams) ApiDataAnalysisPerformFollowupAnalysis2Request {
	r.dataAnalysisParams = &dataAnalysisParams
	return r
}

func (r ApiDataAnalysisPerformFollowupAnalysis2Request) Execute() ([]DeflatedDataValue, *http.Response, error) {
	return r.ApiService.DataAnalysisPerformFollowupAnalysis2Execute(r)
}

/*
DataAnalysisPerformFollowupAnalysis2 Method for DataAnalysisPerformFollowupAnalysis2

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataAnalysisPerformFollowupAnalysis2Request
*/
func (a *DataAPIService) DataAnalysisPerformFollowupAnalysis2(ctx context.Context) ApiDataAnalysisPerformFollowupAnalysis2Request {
	return ApiDataAnalysisPerformFollowupAnalysis2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []DeflatedDataValue
func (a *DataAPIService) DataAnalysisPerformFollowupAnalysis2Execute(r ApiDataAnalysisPerformFollowupAnalysis2Request) ([]DeflatedDataValue, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []DeflatedDataValue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataAnalysisPerformFollowupAnalysis2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataAnalysis/followup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataAnalysisParams == nil {
		return localVarReturnValue, nil, reportError("dataAnalysisParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataAnalysisParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataAnalysisPerformMinMaxOutlierAnalysisRequest struct {
	ctx                context.Context
	ApiService         *DataAPIService
	dataAnalysisParams *DataAnalysisParams
}

// [no description yet]
func (r ApiDataAnalysisPerformMinMaxOutlierAnalysisRequest) DataAnalysisParams(dataAnalysisParams DataAnalysisParams) ApiDataAnalysisPerformMinMaxOutlierAnalysisRequest {
	r.dataAnalysisParams = &dataAnalysisParams
	return r
}

func (r ApiDataAnalysisPerformMinMaxOutlierAnalysisRequest) Execute() ([]DeflatedDataValue, *http.Response, error) {
	return r.ApiService.DataAnalysisPerformMinMaxOutlierAnalysisExecute(r)
}

/*
DataAnalysisPerformMinMaxOutlierAnalysis Method for DataAnalysisPerformMinMaxOutlierAnalysis

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataAnalysisPerformMinMaxOutlierAnalysisRequest
*/
func (a *DataAPIService) DataAnalysisPerformMinMaxOutlierAnalysis(ctx context.Context) ApiDataAnalysisPerformMinMaxOutlierAnalysisRequest {
	return ApiDataAnalysisPerformMinMaxOutlierAnalysisRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []DeflatedDataValue
func (a *DataAPIService) DataAnalysisPerformMinMaxOutlierAnalysisExecute(r ApiDataAnalysisPerformMinMaxOutlierAnalysisRequest) ([]DeflatedDataValue, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []DeflatedDataValue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataAnalysisPerformMinMaxOutlierAnalysis")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataAnalysis/minMaxOutlier"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataAnalysisParams == nil {
		return localVarReturnValue, nil, reportError("dataAnalysisParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataAnalysisParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataAnalysisPerformStdDevOutlierAnalysisRequest struct {
	ctx                context.Context
	ApiService         *DataAPIService
	dataAnalysisParams *DataAnalysisParams
}

// [no description yet]
func (r ApiDataAnalysisPerformStdDevOutlierAnalysisRequest) DataAnalysisParams(dataAnalysisParams DataAnalysisParams) ApiDataAnalysisPerformStdDevOutlierAnalysisRequest {
	r.dataAnalysisParams = &dataAnalysisParams
	return r
}

func (r ApiDataAnalysisPerformStdDevOutlierAnalysisRequest) Execute() ([]DeflatedDataValue, *http.Response, error) {
	return r.ApiService.DataAnalysisPerformStdDevOutlierAnalysisExecute(r)
}

/*
DataAnalysisPerformStdDevOutlierAnalysis Method for DataAnalysisPerformStdDevOutlierAnalysis

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataAnalysisPerformStdDevOutlierAnalysisRequest
*/
func (a *DataAPIService) DataAnalysisPerformStdDevOutlierAnalysis(ctx context.Context) ApiDataAnalysisPerformStdDevOutlierAnalysisRequest {
	return ApiDataAnalysisPerformStdDevOutlierAnalysisRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []DeflatedDataValue
func (a *DataAPIService) DataAnalysisPerformStdDevOutlierAnalysisExecute(r ApiDataAnalysisPerformStdDevOutlierAnalysisRequest) ([]DeflatedDataValue, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []DeflatedDataValue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataAnalysisPerformStdDevOutlierAnalysis")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataAnalysis/stdDevOutlier"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataAnalysisParams == nil {
		return localVarReturnValue, nil, reportError("dataAnalysisParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataAnalysisParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataAnalysisPerformValidationRulesAnalysisRequest struct {
	ctx                           context.Context
	ApiService                    *DataAPIService
	validationRulesAnalysisParams *ValidationRulesAnalysisParams
}

// [no description yet]
func (r ApiDataAnalysisPerformValidationRulesAnalysisRequest) ValidationRulesAnalysisParams(validationRulesAnalysisParams ValidationRulesAnalysisParams) ApiDataAnalysisPerformValidationRulesAnalysisRequest {
	r.validationRulesAnalysisParams = &validationRulesAnalysisParams
	return r
}

func (r ApiDataAnalysisPerformValidationRulesAnalysisRequest) Execute() ([]ValidationResultView, *http.Response, error) {
	return r.ApiService.DataAnalysisPerformValidationRulesAnalysisExecute(r)
}

/*
DataAnalysisPerformValidationRulesAnalysis Method for DataAnalysisPerformValidationRulesAnalysis

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataAnalysisPerformValidationRulesAnalysisRequest
*/
func (a *DataAPIService) DataAnalysisPerformValidationRulesAnalysis(ctx context.Context) ApiDataAnalysisPerformValidationRulesAnalysisRequest {
	return ApiDataAnalysisPerformValidationRulesAnalysisRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ValidationResultView
func (a *DataAPIService) DataAnalysisPerformValidationRulesAnalysisExecute(r ApiDataAnalysisPerformValidationRulesAnalysisRequest) ([]ValidationResultView, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ValidationResultView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataAnalysisPerformValidationRulesAnalysis")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataAnalysis/validationRules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.validationRulesAnalysisParams == nil {
		return localVarReturnValue, nil, reportError("validationRulesAnalysisParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.validationRulesAnalysisParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataApprovalAcceptApprovalRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	ou         *string
	pe         *string
	aoc        *string
	ds         *string
	wf         *string
}

// [no description yet]
func (r ApiDataApprovalAcceptApprovalRequest) Ou(ou string) ApiDataApprovalAcceptApprovalRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiDataApprovalAcceptApprovalRequest) Pe(pe string) ApiDataApprovalAcceptApprovalRequest {
	r.pe = &pe
	return r
}

// [no description yet]
func (r ApiDataApprovalAcceptApprovalRequest) Aoc(aoc string) ApiDataApprovalAcceptApprovalRequest {
	r.aoc = &aoc
	return r
}

// [no description yet]
func (r ApiDataApprovalAcceptApprovalRequest) Ds(ds string) ApiDataApprovalAcceptApprovalRequest {
	r.ds = &ds
	return r
}

// [no description yet]
func (r ApiDataApprovalAcceptApprovalRequest) Wf(wf string) ApiDataApprovalAcceptApprovalRequest {
	r.wf = &wf
	return r
}

func (r ApiDataApprovalAcceptApprovalRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataApprovalAcceptApprovalExecute(r)
}

/*
DataApprovalAcceptApproval Method for DataApprovalAcceptApproval

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataApprovalAcceptApprovalRequest
*/
func (a *DataAPIService) DataApprovalAcceptApproval(ctx context.Context) ApiDataApprovalAcceptApprovalRequest {
	return ApiDataApprovalAcceptApprovalRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) DataApprovalAcceptApprovalExecute(r ApiDataApprovalAcceptApprovalRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataApprovalAcceptApproval")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataAcceptances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ou == nil {
		return nil, reportError("ou is required and must be specified")
	}
	if strlen(*r.ou) < 11 {
		return nil, reportError("ou must have at least 11 elements")
	}
	if strlen(*r.ou) > 11 {
		return nil, reportError("ou must have less than 11 elements")
	}
	if r.pe == nil {
		return nil, reportError("pe is required and must be specified")
	}

	if r.aoc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aoc", r.aoc, "")
	}
	if r.ds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ds", r.ds, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pe", r.pe, "")
	if r.wf != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wf", r.wf, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataApprovalGetApprovalRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	ds         *AuditGetAggregateDataValueAuditDsParameter
	ou         *AuditGetDataApprovalAuditOuParameter
	children   *bool
	endDate    *time.Time
	pe         *string
	startDate  *time.Time
}

// [no description yet]
func (r ApiDataApprovalGetApprovalRequest) Ds(ds AuditGetAggregateDataValueAuditDsParameter) ApiDataApprovalGetApprovalRequest {
	r.ds = &ds
	return r
}

// [no description yet]
func (r ApiDataApprovalGetApprovalRequest) Ou(ou AuditGetDataApprovalAuditOuParameter) ApiDataApprovalGetApprovalRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiDataApprovalGetApprovalRequest) Children(children bool) ApiDataApprovalGetApprovalRequest {
	r.children = &children
	return r
}

// [no description yet]
func (r ApiDataApprovalGetApprovalRequest) EndDate(endDate time.Time) ApiDataApprovalGetApprovalRequest {
	r.endDate = &endDate
	return r
}

// [no description yet]
func (r ApiDataApprovalGetApprovalRequest) Pe(pe string) ApiDataApprovalGetApprovalRequest {
	r.pe = &pe
	return r
}

// [no description yet]
func (r ApiDataApprovalGetApprovalRequest) StartDate(startDate time.Time) ApiDataApprovalGetApprovalRequest {
	r.startDate = &startDate
	return r
}

func (r ApiDataApprovalGetApprovalRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DataApprovalGetApprovalExecute(r)
}

/*
DataApprovalGetApproval Method for DataApprovalGetApproval

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataApprovalGetApprovalRequest
*/
func (a *DataAPIService) DataApprovalGetApproval(ctx context.Context) ApiDataApprovalGetApprovalRequest {
	return ApiDataApprovalGetApprovalRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *DataAPIService) DataApprovalGetApprovalExecute(r ApiDataApprovalGetApprovalRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataApprovalGetApproval")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataApprovals/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ds == nil {
		return localVarReturnValue, nil, reportError("ds is required and must be specified")
	}
	if r.ou == nil {
		return localVarReturnValue, nil, reportError("ou is required and must be specified")
	}

	if r.children != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "children", r.children, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ds", r.ds, "")
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	if r.pe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pe", r.pe, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataApprovalGetApprovalByCategoryOptionCombosRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	pe         *string
	aoc        *string
	ds         *AuditGetAggregateDataValueAuditDsParameter
	ou         *string
	ouFilter   *string
	wf         *AuditGetDataApprovalAuditWfParameter
}

// [no description yet]
func (r ApiDataApprovalGetApprovalByCategoryOptionCombosRequest) Pe(pe string) ApiDataApprovalGetApprovalByCategoryOptionCombosRequest {
	r.pe = &pe
	return r
}

// [no description yet]
func (r ApiDataApprovalGetApprovalByCategoryOptionCombosRequest) Aoc(aoc string) ApiDataApprovalGetApprovalByCategoryOptionCombosRequest {
	r.aoc = &aoc
	return r
}

// [no description yet]
func (r ApiDataApprovalGetApprovalByCategoryOptionCombosRequest) Ds(ds AuditGetAggregateDataValueAuditDsParameter) ApiDataApprovalGetApprovalByCategoryOptionCombosRequest {
	r.ds = &ds
	return r
}

// [no description yet]
func (r ApiDataApprovalGetApprovalByCategoryOptionCombosRequest) Ou(ou string) ApiDataApprovalGetApprovalByCategoryOptionCombosRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiDataApprovalGetApprovalByCategoryOptionCombosRequest) OuFilter(ouFilter string) ApiDataApprovalGetApprovalByCategoryOptionCombosRequest {
	r.ouFilter = &ouFilter
	return r
}

// [no description yet]
func (r ApiDataApprovalGetApprovalByCategoryOptionCombosRequest) Wf(wf AuditGetDataApprovalAuditWfParameter) ApiDataApprovalGetApprovalByCategoryOptionCombosRequest {
	r.wf = &wf
	return r
}

func (r ApiDataApprovalGetApprovalByCategoryOptionCombosRequest) Execute() ([]map[string]map[string]interface{}, *http.Response, error) {
	return r.ApiService.DataApprovalGetApprovalByCategoryOptionCombosExecute(r)
}

/*
DataApprovalGetApprovalByCategoryOptionCombos Method for DataApprovalGetApprovalByCategoryOptionCombos

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataApprovalGetApprovalByCategoryOptionCombosRequest
*/
func (a *DataAPIService) DataApprovalGetApprovalByCategoryOptionCombos(ctx context.Context) ApiDataApprovalGetApprovalByCategoryOptionCombosRequest {
	return ApiDataApprovalGetApprovalByCategoryOptionCombosRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []map[string]map[string]interface{}
func (a *DataAPIService) DataApprovalGetApprovalByCategoryOptionCombosExecute(r ApiDataApprovalGetApprovalByCategoryOptionCombosRequest) ([]map[string]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataApprovalGetApprovalByCategoryOptionCombos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataApprovals/categoryOptionCombos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pe == nil {
		return localVarReturnValue, nil, reportError("pe is required and must be specified")
	}

	if r.aoc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aoc", r.aoc, "")
	}
	if r.ds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ds", r.ds, "")
	}
	if r.ou != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	}
	if r.ouFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ouFilter", r.ouFilter, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "pe", r.pe, "")
	if r.wf != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wf", r.wf, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataApprovalGetApprovalPermissionsRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	ou         *string
	pe         *string
	aoc        *string
	ds         *string
	wf         *string
}

// [no description yet]
func (r ApiDataApprovalGetApprovalPermissionsRequest) Ou(ou string) ApiDataApprovalGetApprovalPermissionsRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiDataApprovalGetApprovalPermissionsRequest) Pe(pe string) ApiDataApprovalGetApprovalPermissionsRequest {
	r.pe = &pe
	return r
}

// [no description yet]
func (r ApiDataApprovalGetApprovalPermissionsRequest) Aoc(aoc string) ApiDataApprovalGetApprovalPermissionsRequest {
	r.aoc = &aoc
	return r
}

// [no description yet]
func (r ApiDataApprovalGetApprovalPermissionsRequest) Ds(ds string) ApiDataApprovalGetApprovalPermissionsRequest {
	r.ds = &ds
	return r
}

// [no description yet]
func (r ApiDataApprovalGetApprovalPermissionsRequest) Wf(wf string) ApiDataApprovalGetApprovalPermissionsRequest {
	r.wf = &wf
	return r
}

func (r ApiDataApprovalGetApprovalPermissionsRequest) Execute() (*DataApprovalPermissions, *http.Response, error) {
	return r.ApiService.DataApprovalGetApprovalPermissionsExecute(r)
}

/*
DataApprovalGetApprovalPermissions Method for DataApprovalGetApprovalPermissions

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataApprovalGetApprovalPermissionsRequest
*/
func (a *DataAPIService) DataApprovalGetApprovalPermissions(ctx context.Context) ApiDataApprovalGetApprovalPermissionsRequest {
	return ApiDataApprovalGetApprovalPermissionsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DataApprovalPermissions
func (a *DataAPIService) DataApprovalGetApprovalPermissionsExecute(r ApiDataApprovalGetApprovalPermissionsRequest) (*DataApprovalPermissions, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataApprovalPermissions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataApprovalGetApprovalPermissions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataApprovals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ou == nil {
		return localVarReturnValue, nil, reportError("ou is required and must be specified")
	}
	if strlen(*r.ou) < 11 {
		return localVarReturnValue, nil, reportError("ou must have at least 11 elements")
	}
	if strlen(*r.ou) > 11 {
		return localVarReturnValue, nil, reportError("ou must have less than 11 elements")
	}
	if r.pe == nil {
		return localVarReturnValue, nil, reportError("pe is required and must be specified")
	}

	if r.aoc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aoc", r.aoc, "")
	}
	if r.ds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ds", r.ds, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pe", r.pe, "")
	if r.wf != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wf", r.wf, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataApprovalGetMultipleApprovalPermissionsRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	ou         *AuditGetDataApprovalAuditOuParameter
	wf         *AuditGetDataApprovalAuditWfParameter
	aoc        *AuditGetDataApprovalAuditAocParameter
	endDate    *time.Time
	pe         *[]string
	startDate  *time.Time
}

// [no description yet]
func (r ApiDataApprovalGetMultipleApprovalPermissionsRequest) Ou(ou AuditGetDataApprovalAuditOuParameter) ApiDataApprovalGetMultipleApprovalPermissionsRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiDataApprovalGetMultipleApprovalPermissionsRequest) Wf(wf AuditGetDataApprovalAuditWfParameter) ApiDataApprovalGetMultipleApprovalPermissionsRequest {
	r.wf = &wf
	return r
}

// [no description yet]
func (r ApiDataApprovalGetMultipleApprovalPermissionsRequest) Aoc(aoc AuditGetDataApprovalAuditAocParameter) ApiDataApprovalGetMultipleApprovalPermissionsRequest {
	r.aoc = &aoc
	return r
}

// [no description yet]
func (r ApiDataApprovalGetMultipleApprovalPermissionsRequest) EndDate(endDate time.Time) ApiDataApprovalGetMultipleApprovalPermissionsRequest {
	r.endDate = &endDate
	return r
}

// [no description yet]
func (r ApiDataApprovalGetMultipleApprovalPermissionsRequest) Pe(pe []string) ApiDataApprovalGetMultipleApprovalPermissionsRequest {
	r.pe = &pe
	return r
}

// [no description yet]
func (r ApiDataApprovalGetMultipleApprovalPermissionsRequest) StartDate(startDate time.Time) ApiDataApprovalGetMultipleApprovalPermissionsRequest {
	r.startDate = &startDate
	return r
}

func (r ApiDataApprovalGetMultipleApprovalPermissionsRequest) Execute() ([]ApprovalStatusDto, *http.Response, error) {
	return r.ApiService.DataApprovalGetMultipleApprovalPermissionsExecute(r)
}

/*
DataApprovalGetMultipleApprovalPermissions Method for DataApprovalGetMultipleApprovalPermissions

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataApprovalGetMultipleApprovalPermissionsRequest
*/
func (a *DataAPIService) DataApprovalGetMultipleApprovalPermissions(ctx context.Context) ApiDataApprovalGetMultipleApprovalPermissionsRequest {
	return ApiDataApprovalGetMultipleApprovalPermissionsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ApprovalStatusDto
func (a *DataAPIService) DataApprovalGetMultipleApprovalPermissionsExecute(r ApiDataApprovalGetMultipleApprovalPermissionsRequest) ([]ApprovalStatusDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ApprovalStatusDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataApprovalGetMultipleApprovalPermissions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataApprovals/approvals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ou == nil {
		return localVarReturnValue, nil, reportError("ou is required and must be specified")
	}
	if r.wf == nil {
		return localVarReturnValue, nil, reportError("wf is required and must be specified")
	}

	if r.aoc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aoc", r.aoc, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	if r.pe != nil {
		t := *r.pe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pe", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pe", t, "multi")
		}
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "wf", r.wf, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataApprovalGetMultipleApprovalPermissions2Request struct {
	ctx        context.Context
	ApiService *DataAPIService
	ou         *AuditGetDataApprovalAuditOuParameter
	wf         *AuditGetDataApprovalAuditWfParameter
	aoc        *AuditGetDataApprovalAuditAocParameter
	endDate    *time.Time
	pe         *[]string
	startDate  *time.Time
}

// [no description yet]
func (r ApiDataApprovalGetMultipleApprovalPermissions2Request) Ou(ou AuditGetDataApprovalAuditOuParameter) ApiDataApprovalGetMultipleApprovalPermissions2Request {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiDataApprovalGetMultipleApprovalPermissions2Request) Wf(wf AuditGetDataApprovalAuditWfParameter) ApiDataApprovalGetMultipleApprovalPermissions2Request {
	r.wf = &wf
	return r
}

// [no description yet]
func (r ApiDataApprovalGetMultipleApprovalPermissions2Request) Aoc(aoc AuditGetDataApprovalAuditAocParameter) ApiDataApprovalGetMultipleApprovalPermissions2Request {
	r.aoc = &aoc
	return r
}

// [no description yet]
func (r ApiDataApprovalGetMultipleApprovalPermissions2Request) EndDate(endDate time.Time) ApiDataApprovalGetMultipleApprovalPermissions2Request {
	r.endDate = &endDate
	return r
}

// [no description yet]
func (r ApiDataApprovalGetMultipleApprovalPermissions2Request) Pe(pe []string) ApiDataApprovalGetMultipleApprovalPermissions2Request {
	r.pe = &pe
	return r
}

// [no description yet]
func (r ApiDataApprovalGetMultipleApprovalPermissions2Request) StartDate(startDate time.Time) ApiDataApprovalGetMultipleApprovalPermissions2Request {
	r.startDate = &startDate
	return r
}

func (r ApiDataApprovalGetMultipleApprovalPermissions2Request) Execute() ([]ApprovalStatusDto, *http.Response, error) {
	return r.ApiService.DataApprovalGetMultipleApprovalPermissions2Execute(r)
}

/*
DataApprovalGetMultipleApprovalPermissions2 Method for DataApprovalGetMultipleApprovalPermissions2

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataApprovalGetMultipleApprovalPermissions2Request
*/
func (a *DataAPIService) DataApprovalGetMultipleApprovalPermissions2(ctx context.Context) ApiDataApprovalGetMultipleApprovalPermissions2Request {
	return ApiDataApprovalGetMultipleApprovalPermissions2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ApprovalStatusDto
func (a *DataAPIService) DataApprovalGetMultipleApprovalPermissions2Execute(r ApiDataApprovalGetMultipleApprovalPermissions2Request) ([]ApprovalStatusDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ApprovalStatusDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataApprovalGetMultipleApprovalPermissions2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataApprovals/multiple"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ou == nil {
		return localVarReturnValue, nil, reportError("ou is required and must be specified")
	}
	if r.wf == nil {
		return localVarReturnValue, nil, reportError("wf is required and must be specified")
	}

	if r.aoc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aoc", r.aoc, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	if r.pe != nil {
		t := *r.pe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pe", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pe", t, "multi")
		}
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "wf", r.wf, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataApprovalRemoveAcceptancesBatchRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	approvalsDto *ApprovalsDto
}

// [no description yet]
func (r ApiDataApprovalRemoveAcceptancesBatchRequest) ApprovalsDto(approvalsDto ApprovalsDto) ApiDataApprovalRemoveAcceptancesBatchRequest {
	r.approvalsDto = &approvalsDto
	return r
}

func (r ApiDataApprovalRemoveAcceptancesBatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataApprovalRemoveAcceptancesBatchExecute(r)
}

/*
DataApprovalRemoveAcceptancesBatch Method for DataApprovalRemoveAcceptancesBatch

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataApprovalRemoveAcceptancesBatchRequest
*/
func (a *DataAPIService) DataApprovalRemoveAcceptancesBatch(ctx context.Context) ApiDataApprovalRemoveAcceptancesBatchRequest {
	return ApiDataApprovalRemoveAcceptancesBatchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) DataApprovalRemoveAcceptancesBatchExecute(r ApiDataApprovalRemoveAcceptancesBatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataApprovalRemoveAcceptancesBatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataAcceptances/unacceptances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.approvalsDto == nil {
		return nil, reportError("approvalsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.approvalsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataApprovalRemoveApprovalRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	ou         *string
	pe         *string
	aoc        *string
	ds         *AuditGetAggregateDataValueAuditDsParameter
	wf         *AuditGetDataApprovalAuditWfParameter
}

// [no description yet]
func (r ApiDataApprovalRemoveApprovalRequest) Ou(ou string) ApiDataApprovalRemoveApprovalRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiDataApprovalRemoveApprovalRequest) Pe(pe string) ApiDataApprovalRemoveApprovalRequest {
	r.pe = &pe
	return r
}

// [no description yet]
func (r ApiDataApprovalRemoveApprovalRequest) Aoc(aoc string) ApiDataApprovalRemoveApprovalRequest {
	r.aoc = &aoc
	return r
}

// [no description yet]
func (r ApiDataApprovalRemoveApprovalRequest) Ds(ds AuditGetAggregateDataValueAuditDsParameter) ApiDataApprovalRemoveApprovalRequest {
	r.ds = &ds
	return r
}

// [no description yet]
func (r ApiDataApprovalRemoveApprovalRequest) Wf(wf AuditGetDataApprovalAuditWfParameter) ApiDataApprovalRemoveApprovalRequest {
	r.wf = &wf
	return r
}

func (r ApiDataApprovalRemoveApprovalRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataApprovalRemoveApprovalExecute(r)
}

/*
DataApprovalRemoveApproval Method for DataApprovalRemoveApproval

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataApprovalRemoveApprovalRequest
*/
func (a *DataAPIService) DataApprovalRemoveApproval(ctx context.Context) ApiDataApprovalRemoveApprovalRequest {
	return ApiDataApprovalRemoveApprovalRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) DataApprovalRemoveApprovalExecute(r ApiDataApprovalRemoveApprovalRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataApprovalRemoveApproval")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataApprovals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ou == nil {
		return nil, reportError("ou is required and must be specified")
	}
	if strlen(*r.ou) < 11 {
		return nil, reportError("ou must have at least 11 elements")
	}
	if strlen(*r.ou) > 11 {
		return nil, reportError("ou must have less than 11 elements")
	}
	if r.pe == nil {
		return nil, reportError("pe is required and must be specified")
	}

	if r.aoc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aoc", r.aoc, "")
	}
	if r.ds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ds", r.ds, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pe", r.pe, "")
	if r.wf != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wf", r.wf, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataApprovalRemoveApprovalBatchRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	approvalsDto *ApprovalsDto
}

// [no description yet]
func (r ApiDataApprovalRemoveApprovalBatchRequest) ApprovalsDto(approvalsDto ApprovalsDto) ApiDataApprovalRemoveApprovalBatchRequest {
	r.approvalsDto = &approvalsDto
	return r
}

func (r ApiDataApprovalRemoveApprovalBatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataApprovalRemoveApprovalBatchExecute(r)
}

/*
DataApprovalRemoveApprovalBatch Method for DataApprovalRemoveApprovalBatch

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataApprovalRemoveApprovalBatchRequest
*/
func (a *DataAPIService) DataApprovalRemoveApprovalBatch(ctx context.Context) ApiDataApprovalRemoveApprovalBatchRequest {
	return ApiDataApprovalRemoveApprovalBatchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) DataApprovalRemoveApprovalBatchExecute(r ApiDataApprovalRemoveApprovalBatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataApprovalRemoveApprovalBatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataApprovals/unapprovals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.approvalsDto == nil {
		return nil, reportError("approvalsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.approvalsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataApprovalSaveAcceptanceBatchRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	approvalsDto *ApprovalsDto
}

// [no description yet]
func (r ApiDataApprovalSaveAcceptanceBatchRequest) ApprovalsDto(approvalsDto ApprovalsDto) ApiDataApprovalSaveAcceptanceBatchRequest {
	r.approvalsDto = &approvalsDto
	return r
}

func (r ApiDataApprovalSaveAcceptanceBatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataApprovalSaveAcceptanceBatchExecute(r)
}

/*
DataApprovalSaveAcceptanceBatch Method for DataApprovalSaveAcceptanceBatch

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataApprovalSaveAcceptanceBatchRequest
*/
func (a *DataAPIService) DataApprovalSaveAcceptanceBatch(ctx context.Context) ApiDataApprovalSaveAcceptanceBatchRequest {
	return ApiDataApprovalSaveAcceptanceBatchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) DataApprovalSaveAcceptanceBatchExecute(r ApiDataApprovalSaveAcceptanceBatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataApprovalSaveAcceptanceBatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataAcceptances/acceptances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.approvalsDto == nil {
		return nil, reportError("approvalsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.approvalsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataApprovalSaveApprovalRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	ou         *string
	pe         *string
	aoc        *string
	ds         *string
	wf         *string
}

// [no description yet]
func (r ApiDataApprovalSaveApprovalRequest) Ou(ou string) ApiDataApprovalSaveApprovalRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiDataApprovalSaveApprovalRequest) Pe(pe string) ApiDataApprovalSaveApprovalRequest {
	r.pe = &pe
	return r
}

// [no description yet]
func (r ApiDataApprovalSaveApprovalRequest) Aoc(aoc string) ApiDataApprovalSaveApprovalRequest {
	r.aoc = &aoc
	return r
}

// [no description yet]
func (r ApiDataApprovalSaveApprovalRequest) Ds(ds string) ApiDataApprovalSaveApprovalRequest {
	r.ds = &ds
	return r
}

// [no description yet]
func (r ApiDataApprovalSaveApprovalRequest) Wf(wf string) ApiDataApprovalSaveApprovalRequest {
	r.wf = &wf
	return r
}

func (r ApiDataApprovalSaveApprovalRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataApprovalSaveApprovalExecute(r)
}

/*
DataApprovalSaveApproval Method for DataApprovalSaveApproval

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataApprovalSaveApprovalRequest
*/
func (a *DataAPIService) DataApprovalSaveApproval(ctx context.Context) ApiDataApprovalSaveApprovalRequest {
	return ApiDataApprovalSaveApprovalRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) DataApprovalSaveApprovalExecute(r ApiDataApprovalSaveApprovalRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataApprovalSaveApproval")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataApprovals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ou == nil {
		return nil, reportError("ou is required and must be specified")
	}
	if strlen(*r.ou) < 11 {
		return nil, reportError("ou must have at least 11 elements")
	}
	if strlen(*r.ou) > 11 {
		return nil, reportError("ou must have less than 11 elements")
	}
	if r.pe == nil {
		return nil, reportError("pe is required and must be specified")
	}

	if r.aoc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aoc", r.aoc, "")
	}
	if r.ds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ds", r.ds, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pe", r.pe, "")
	if r.wf != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wf", r.wf, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataApprovalSaveApprovalBatchRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	approvalsDto *ApprovalsDto
}

// [no description yet]
func (r ApiDataApprovalSaveApprovalBatchRequest) ApprovalsDto(approvalsDto ApprovalsDto) ApiDataApprovalSaveApprovalBatchRequest {
	r.approvalsDto = &approvalsDto
	return r
}

func (r ApiDataApprovalSaveApprovalBatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataApprovalSaveApprovalBatchExecute(r)
}

/*
DataApprovalSaveApprovalBatch Method for DataApprovalSaveApprovalBatch

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataApprovalSaveApprovalBatchRequest
*/
func (a *DataAPIService) DataApprovalSaveApprovalBatch(ctx context.Context) ApiDataApprovalSaveApprovalBatchRequest {
	return ApiDataApprovalSaveApprovalBatchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) DataApprovalSaveApprovalBatchExecute(r ApiDataApprovalSaveApprovalBatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataApprovalSaveApprovalBatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataApprovals/approvals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.approvalsDto == nil {
		return nil, reportError("approvalsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.approvalsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataApprovalUnacceptApprovalRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	ou         *string
	pe         *string
	aoc        *string
	ds         *string
	wf         *string
}

// [no description yet]
func (r ApiDataApprovalUnacceptApprovalRequest) Ou(ou string) ApiDataApprovalUnacceptApprovalRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiDataApprovalUnacceptApprovalRequest) Pe(pe string) ApiDataApprovalUnacceptApprovalRequest {
	r.pe = &pe
	return r
}

// [no description yet]
func (r ApiDataApprovalUnacceptApprovalRequest) Aoc(aoc string) ApiDataApprovalUnacceptApprovalRequest {
	r.aoc = &aoc
	return r
}

// [no description yet]
func (r ApiDataApprovalUnacceptApprovalRequest) Ds(ds string) ApiDataApprovalUnacceptApprovalRequest {
	r.ds = &ds
	return r
}

// [no description yet]
func (r ApiDataApprovalUnacceptApprovalRequest) Wf(wf string) ApiDataApprovalUnacceptApprovalRequest {
	r.wf = &wf
	return r
}

func (r ApiDataApprovalUnacceptApprovalRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataApprovalUnacceptApprovalExecute(r)
}

/*
DataApprovalUnacceptApproval Method for DataApprovalUnacceptApproval

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataApprovalUnacceptApprovalRequest
*/
func (a *DataAPIService) DataApprovalUnacceptApproval(ctx context.Context) ApiDataApprovalUnacceptApprovalRequest {
	return ApiDataApprovalUnacceptApprovalRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) DataApprovalUnacceptApprovalExecute(r ApiDataApprovalUnacceptApprovalRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataApprovalUnacceptApproval")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataAcceptances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ou == nil {
		return nil, reportError("ou is required and must be specified")
	}
	if strlen(*r.ou) < 11 {
		return nil, reportError("ou must have at least 11 elements")
	}
	if strlen(*r.ou) > 11 {
		return nil, reportError("ou must have less than 11 elements")
	}
	if r.pe == nil {
		return nil, reportError("pe is required and must be specified")
	}

	if r.aoc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aoc", r.aoc, "")
	}
	if r.ds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ds", r.ds, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pe", r.pe, "")
	if r.wf != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wf", r.wf, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataIntegrityGetAvailableChecksRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	checks       *[]string
	programmatic *bool
	section      *string
	slow         *bool
}

// [no description yet]
func (r ApiDataIntegrityGetAvailableChecksRequest) Checks(checks []string) ApiDataIntegrityGetAvailableChecksRequest {
	r.checks = &checks
	return r
}

// [no description yet]
func (r ApiDataIntegrityGetAvailableChecksRequest) Programmatic(programmatic bool) ApiDataIntegrityGetAvailableChecksRequest {
	r.programmatic = &programmatic
	return r
}

// [no description yet]
func (r ApiDataIntegrityGetAvailableChecksRequest) Section(section string) ApiDataIntegrityGetAvailableChecksRequest {
	r.section = &section
	return r
}

// [no description yet]
func (r ApiDataIntegrityGetAvailableChecksRequest) Slow(slow bool) ApiDataIntegrityGetAvailableChecksRequest {
	r.slow = &slow
	return r
}

func (r ApiDataIntegrityGetAvailableChecksRequest) Execute() ([]DataIntegrityCheck, *http.Response, error) {
	return r.ApiService.DataIntegrityGetAvailableChecksExecute(r)
}

/*
DataIntegrityGetAvailableChecks Method for DataIntegrityGetAvailableChecks

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataIntegrityGetAvailableChecksRequest
*/
func (a *DataAPIService) DataIntegrityGetAvailableChecks(ctx context.Context) ApiDataIntegrityGetAvailableChecksRequest {
	return ApiDataIntegrityGetAvailableChecksRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []DataIntegrityCheck
func (a *DataAPIService) DataIntegrityGetAvailableChecksExecute(r ApiDataIntegrityGetAvailableChecksRequest) ([]DataIntegrityCheck, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []DataIntegrityCheck
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataIntegrityGetAvailableChecks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataIntegrity/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.checks != nil {
		t := *r.checks
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "checks", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "checks", t, "multi")
		}
	}
	if r.programmatic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "programmatic", r.programmatic, "")
	}
	if r.section != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "section", r.section, "")
	}
	if r.slow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slow", r.slow, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataIntegrityGetCompletedDetailsChecksRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
}

func (r ApiDataIntegrityGetCompletedDetailsChecksRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.DataIntegrityGetCompletedDetailsChecksExecute(r)
}

/*
DataIntegrityGetCompletedDetailsChecks Method for DataIntegrityGetCompletedDetailsChecks

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataIntegrityGetCompletedDetailsChecksRequest
*/
func (a *DataAPIService) DataIntegrityGetCompletedDetailsChecks(ctx context.Context) ApiDataIntegrityGetCompletedDetailsChecksRequest {
	return ApiDataIntegrityGetCompletedDetailsChecksRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []string
func (a *DataAPIService) DataIntegrityGetCompletedDetailsChecksExecute(r ApiDataIntegrityGetCompletedDetailsChecksRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataIntegrityGetCompletedDetailsChecks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataIntegrity/details/completed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataIntegrityGetCompletedSummaryChecksRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
}

func (r ApiDataIntegrityGetCompletedSummaryChecksRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.DataIntegrityGetCompletedSummaryChecksExecute(r)
}

/*
DataIntegrityGetCompletedSummaryChecks Method for DataIntegrityGetCompletedSummaryChecks

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataIntegrityGetCompletedSummaryChecksRequest
*/
func (a *DataAPIService) DataIntegrityGetCompletedSummaryChecks(ctx context.Context) ApiDataIntegrityGetCompletedSummaryChecksRequest {
	return ApiDataIntegrityGetCompletedSummaryChecksRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []string
func (a *DataAPIService) DataIntegrityGetCompletedSummaryChecksExecute(r ApiDataIntegrityGetCompletedSummaryChecksRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataIntegrityGetCompletedSummaryChecks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataIntegrity/summary/completed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataIntegrityGetDetailsRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	checks     *[]string
	timeout    *int64
}

// [no description yet]
func (r ApiDataIntegrityGetDetailsRequest) Checks(checks []string) ApiDataIntegrityGetDetailsRequest {
	r.checks = &checks
	return r
}

// [no description yet]
func (r ApiDataIntegrityGetDetailsRequest) Timeout(timeout int64) ApiDataIntegrityGetDetailsRequest {
	r.timeout = &timeout
	return r
}

func (r ApiDataIntegrityGetDetailsRequest) Execute() (*map[string]DataIntegrityDetails, *http.Response, error) {
	return r.ApiService.DataIntegrityGetDetailsExecute(r)
}

/*
DataIntegrityGetDetails Method for DataIntegrityGetDetails

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataIntegrityGetDetailsRequest
*/
func (a *DataAPIService) DataIntegrityGetDetails(ctx context.Context) ApiDataIntegrityGetDetailsRequest {
	return ApiDataIntegrityGetDetailsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]DataIntegrityDetails
func (a *DataAPIService) DataIntegrityGetDetailsExecute(r ApiDataIntegrityGetDetailsRequest) (*map[string]DataIntegrityDetails, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *map[string]DataIntegrityDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataIntegrityGetDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataIntegrity/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.checks != nil {
		t := *r.checks
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "checks", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "checks", t, "multi")
		}
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	} else {
		var defaultValue int64 = 0
		r.timeout = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataIntegrityGetDetails2Request struct {
	ctx        context.Context
	ApiService *DataAPIService
	check      string
	timeout    *int64
}

// [no description yet]
func (r ApiDataIntegrityGetDetails2Request) Timeout(timeout int64) ApiDataIntegrityGetDetails2Request {
	r.timeout = &timeout
	return r
}

func (r ApiDataIntegrityGetDetails2Request) Execute() (*DataIntegrityDetails, *http.Response, error) {
	return r.ApiService.DataIntegrityGetDetails2Execute(r)
}

/*
DataIntegrityGetDetails2 Method for DataIntegrityGetDetails2

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param check [no description yet]
	@return ApiDataIntegrityGetDetails2Request
*/
func (a *DataAPIService) DataIntegrityGetDetails2(ctx context.Context, check string) ApiDataIntegrityGetDetails2Request {
	return ApiDataIntegrityGetDetails2Request{
		ApiService: a,
		ctx:        ctx,
		check:      check,
	}
}

// Execute executes the request
//
//	@return DataIntegrityDetails
func (a *DataAPIService) DataIntegrityGetDetails2Execute(r ApiDataIntegrityGetDetails2Request) (*DataIntegrityDetails, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataIntegrityDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataIntegrityGetDetails2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataIntegrity/{check}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"check"+"}", url.PathEscape(parameterValueToString(r.check, "check")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	} else {
		var defaultValue int64 = 0
		r.timeout = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataIntegrityGetRunningDetailsChecksRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
}

func (r ApiDataIntegrityGetRunningDetailsChecksRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.DataIntegrityGetRunningDetailsChecksExecute(r)
}

/*
DataIntegrityGetRunningDetailsChecks Method for DataIntegrityGetRunningDetailsChecks

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataIntegrityGetRunningDetailsChecksRequest
*/
func (a *DataAPIService) DataIntegrityGetRunningDetailsChecks(ctx context.Context) ApiDataIntegrityGetRunningDetailsChecksRequest {
	return ApiDataIntegrityGetRunningDetailsChecksRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []string
func (a *DataAPIService) DataIntegrityGetRunningDetailsChecksExecute(r ApiDataIntegrityGetRunningDetailsChecksRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataIntegrityGetRunningDetailsChecks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataIntegrity/details/running"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataIntegrityGetRunningSummaryChecksRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
}

func (r ApiDataIntegrityGetRunningSummaryChecksRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.DataIntegrityGetRunningSummaryChecksExecute(r)
}

/*
DataIntegrityGetRunningSummaryChecks Method for DataIntegrityGetRunningSummaryChecks

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataIntegrityGetRunningSummaryChecksRequest
*/
func (a *DataAPIService) DataIntegrityGetRunningSummaryChecks(ctx context.Context) ApiDataIntegrityGetRunningSummaryChecksRequest {
	return ApiDataIntegrityGetRunningSummaryChecksRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []string
func (a *DataAPIService) DataIntegrityGetRunningSummaryChecksExecute(r ApiDataIntegrityGetRunningSummaryChecksRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataIntegrityGetRunningSummaryChecks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataIntegrity/summary/running"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataIntegrityGetSummariesRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	checks     *[]string
	timeout    *int64
}

// [no description yet]
func (r ApiDataIntegrityGetSummariesRequest) Checks(checks []string) ApiDataIntegrityGetSummariesRequest {
	r.checks = &checks
	return r
}

// [no description yet]
func (r ApiDataIntegrityGetSummariesRequest) Timeout(timeout int64) ApiDataIntegrityGetSummariesRequest {
	r.timeout = &timeout
	return r
}

func (r ApiDataIntegrityGetSummariesRequest) Execute() (*map[string]DataIntegritySummary, *http.Response, error) {
	return r.ApiService.DataIntegrityGetSummariesExecute(r)
}

/*
DataIntegrityGetSummaries Method for DataIntegrityGetSummaries

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataIntegrityGetSummariesRequest
*/
func (a *DataAPIService) DataIntegrityGetSummaries(ctx context.Context) ApiDataIntegrityGetSummariesRequest {
	return ApiDataIntegrityGetSummariesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]DataIntegritySummary
func (a *DataAPIService) DataIntegrityGetSummariesExecute(r ApiDataIntegrityGetSummariesRequest) (*map[string]DataIntegritySummary, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *map[string]DataIntegritySummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataIntegrityGetSummaries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataIntegrity/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.checks != nil {
		t := *r.checks
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "checks", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "checks", t, "multi")
		}
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	} else {
		var defaultValue int64 = 0
		r.timeout = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataIntegrityGetSummaryRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	check      string
	timeout    *int64
}

// [no description yet]
func (r ApiDataIntegrityGetSummaryRequest) Timeout(timeout int64) ApiDataIntegrityGetSummaryRequest {
	r.timeout = &timeout
	return r
}

func (r ApiDataIntegrityGetSummaryRequest) Execute() (*DataIntegritySummary, *http.Response, error) {
	return r.ApiService.DataIntegrityGetSummaryExecute(r)
}

/*
DataIntegrityGetSummary Method for DataIntegrityGetSummary

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param check [no description yet]
	@return ApiDataIntegrityGetSummaryRequest
*/
func (a *DataAPIService) DataIntegrityGetSummary(ctx context.Context, check string) ApiDataIntegrityGetSummaryRequest {
	return ApiDataIntegrityGetSummaryRequest{
		ApiService: a,
		ctx:        ctx,
		check:      check,
	}
}

// Execute executes the request
//
//	@return DataIntegritySummary
func (a *DataAPIService) DataIntegrityGetSummaryExecute(r ApiDataIntegrityGetSummaryRequest) (*DataIntegritySummary, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataIntegritySummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataIntegrityGetSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataIntegrity/{check}/summary"
	localVarPath = strings.Replace(localVarPath, "{"+"check"+"}", url.PathEscape(parameterValueToString(r.check, "check")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	} else {
		var defaultValue int64 = 0
		r.timeout = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataIntegrityRunDataIntegrityRequest struct {
	ctx         context.Context
	ApiService  *DataAPIService
	checks      *[]string
	requestBody *[]string
}

// [no description yet]
func (r ApiDataIntegrityRunDataIntegrityRequest) Checks(checks []string) ApiDataIntegrityRunDataIntegrityRequest {
	r.checks = &checks
	return r
}

// [no description yet]
func (r ApiDataIntegrityRunDataIntegrityRequest) RequestBody(requestBody []string) ApiDataIntegrityRunDataIntegrityRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiDataIntegrityRunDataIntegrityRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DataIntegrityRunDataIntegrityExecute(r)
}

/*
DataIntegrityRunDataIntegrity Method for DataIntegrityRunDataIntegrity

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataIntegrityRunDataIntegrityRequest
*/
func (a *DataAPIService) DataIntegrityRunDataIntegrity(ctx context.Context) ApiDataIntegrityRunDataIntegrityRequest {
	return ApiDataIntegrityRunDataIntegrityRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) DataIntegrityRunDataIntegrityExecute(r ApiDataIntegrityRunDataIntegrityRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataIntegrityRunDataIntegrity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataIntegrity/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.checks != nil {
		t := *r.checks
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "checks", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "checks", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataIntegrityRunDetailsCheckRequest struct {
	ctx         context.Context
	ApiService  *DataAPIService
	checks      *[]string
	requestBody *[]string
}

// [no description yet]
func (r ApiDataIntegrityRunDetailsCheckRequest) Checks(checks []string) ApiDataIntegrityRunDetailsCheckRequest {
	r.checks = &checks
	return r
}

// [no description yet]
func (r ApiDataIntegrityRunDetailsCheckRequest) RequestBody(requestBody []string) ApiDataIntegrityRunDetailsCheckRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiDataIntegrityRunDetailsCheckRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DataIntegrityRunDetailsCheckExecute(r)
}

/*
DataIntegrityRunDetailsCheck Method for DataIntegrityRunDetailsCheck

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataIntegrityRunDetailsCheckRequest
*/
func (a *DataAPIService) DataIntegrityRunDetailsCheck(ctx context.Context) ApiDataIntegrityRunDetailsCheckRequest {
	return ApiDataIntegrityRunDetailsCheckRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) DataIntegrityRunDetailsCheckExecute(r ApiDataIntegrityRunDetailsCheckRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataIntegrityRunDetailsCheck")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataIntegrity/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.checks != nil {
		t := *r.checks
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "checks", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "checks", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataIntegrityRunSummariesCheckRequest struct {
	ctx         context.Context
	ApiService  *DataAPIService
	checks      *[]string
	requestBody *[]string
}

// [no description yet]
func (r ApiDataIntegrityRunSummariesCheckRequest) Checks(checks []string) ApiDataIntegrityRunSummariesCheckRequest {
	r.checks = &checks
	return r
}

// [no description yet]
func (r ApiDataIntegrityRunSummariesCheckRequest) RequestBody(requestBody []string) ApiDataIntegrityRunSummariesCheckRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiDataIntegrityRunSummariesCheckRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DataIntegrityRunSummariesCheckExecute(r)
}

/*
DataIntegrityRunSummariesCheck Method for DataIntegrityRunSummariesCheck

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataIntegrityRunSummariesCheckRequest
*/
func (a *DataAPIService) DataIntegrityRunSummariesCheck(ctx context.Context) ApiDataIntegrityRunSummariesCheckRequest {
	return ApiDataIntegrityRunSummariesCheckRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) DataIntegrityRunSummariesCheckExecute(r ApiDataIntegrityRunSummariesCheckRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataIntegrityRunSummariesCheck")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataIntegrity/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.checks != nil {
		t := *r.checks
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "checks", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "checks", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataSetCompletionSaveDataSetCompletionRequest struct {
	ctx                  context.Context
	ApiService           *DataAPIService
	dataSetCompletionDto *DataSetCompletionDto
}

// [no description yet]
func (r ApiDataSetCompletionSaveDataSetCompletionRequest) DataSetCompletionDto(dataSetCompletionDto DataSetCompletionDto) ApiDataSetCompletionSaveDataSetCompletionRequest {
	r.dataSetCompletionDto = &dataSetCompletionDto
	return r
}

func (r ApiDataSetCompletionSaveDataSetCompletionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataSetCompletionSaveDataSetCompletionExecute(r)
}

/*
DataSetCompletionSaveDataSetCompletion Method for DataSetCompletionSaveDataSetCompletion

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataSetCompletionSaveDataSetCompletionRequest
*/
func (a *DataAPIService) DataSetCompletionSaveDataSetCompletion(ctx context.Context) ApiDataSetCompletionSaveDataSetCompletionRequest {
	return ApiDataSetCompletionSaveDataSetCompletionRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) DataSetCompletionSaveDataSetCompletionExecute(r ApiDataSetCompletionSaveDataSetCompletionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataSetCompletionSaveDataSetCompletion")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataEntry/dataSetCompletion"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataSetCompletionDto == nil {
		return nil, reportError("dataSetCompletionDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataSetCompletionDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataSetLockExceptionGetLockExceptionsRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
}

func (r ApiDataSetLockExceptionGetLockExceptionsRequest) Execute() (*LockExceptionsDto, *http.Response, error) {
	return r.ApiService.DataSetLockExceptionGetLockExceptionsExecute(r)
}

/*
DataSetLockExceptionGetLockExceptions Method for DataSetLockExceptionGetLockExceptions

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataSetLockExceptionGetLockExceptionsRequest
*/
func (a *DataAPIService) DataSetLockExceptionGetLockExceptions(ctx context.Context) ApiDataSetLockExceptionGetLockExceptionsRequest {
	return ApiDataSetLockExceptionGetLockExceptionsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return LockExceptionsDto
func (a *DataAPIService) DataSetLockExceptionGetLockExceptionsExecute(r ApiDataSetLockExceptionGetLockExceptionsRequest) (*LockExceptionsDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LockExceptionsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataSetLockExceptionGetLockExceptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataEntry/lockExceptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataSetMetadataGetMetadataRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
}

func (r ApiDataSetMetadataGetMetadataRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DataSetMetadataGetMetadataExecute(r)
}

/*
DataSetMetadataGetMetadata Method for DataSetMetadataGetMetadata

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataSetMetadataGetMetadataRequest
*/
func (a *DataAPIService) DataSetMetadataGetMetadata(ctx context.Context) ApiDataSetMetadataGetMetadataRequest {
	return ApiDataSetMetadataGetMetadataRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *DataAPIService) DataSetMetadataGetMetadataExecute(r ApiDataSetMetadataGetMetadataRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataSetMetadataGetMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataEntry/metadata"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataSetReportGetCustomDataSetReportRequest struct {
	ctx              context.Context
	ApiService       *DataAPIService
	ds               *string
	ou               *string
	pe               *[]string
	filter           *[]string
	selectedUnitOnly *bool
}

// [no description yet]
func (r ApiDataSetReportGetCustomDataSetReportRequest) Ds(ds string) ApiDataSetReportGetCustomDataSetReportRequest {
	r.ds = &ds
	return r
}

// [no description yet]
func (r ApiDataSetReportGetCustomDataSetReportRequest) Ou(ou string) ApiDataSetReportGetCustomDataSetReportRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiDataSetReportGetCustomDataSetReportRequest) Pe(pe []string) ApiDataSetReportGetCustomDataSetReportRequest {
	r.pe = &pe
	return r
}

// [no description yet]
func (r ApiDataSetReportGetCustomDataSetReportRequest) Filter(filter []string) ApiDataSetReportGetCustomDataSetReportRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiDataSetReportGetCustomDataSetReportRequest) SelectedUnitOnly(selectedUnitOnly bool) ApiDataSetReportGetCustomDataSetReportRequest {
	r.selectedUnitOnly = &selectedUnitOnly
	return r
}

func (r ApiDataSetReportGetCustomDataSetReportRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.DataSetReportGetCustomDataSetReportExecute(r)
}

/*
DataSetReportGetCustomDataSetReport Method for DataSetReportGetCustomDataSetReport

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataSetReportGetCustomDataSetReportRequest
*/
func (a *DataAPIService) DataSetReportGetCustomDataSetReport(ctx context.Context) ApiDataSetReportGetCustomDataSetReportRequest {
	return ApiDataSetReportGetCustomDataSetReportRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *DataAPIService) DataSetReportGetCustomDataSetReportExecute(r ApiDataSetReportGetCustomDataSetReportRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataSetReportGetCustomDataSetReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataSetReport/custom"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ds == nil {
		return localVarReturnValue, nil, reportError("ds is required and must be specified")
	}
	if r.ou == nil {
		return localVarReturnValue, nil, reportError("ou is required and must be specified")
	}
	if r.pe == nil {
		return localVarReturnValue, nil, reportError("pe is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ds", r.ds, "")
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	{
		t := *r.pe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pe", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pe", t, "multi")
		}
	}
	if r.selectedUnitOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "selectedUnitOnly", r.selectedUnitOnly, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataSetReportGetDataSetReportAsExcelRequest struct {
	ctx              context.Context
	ApiService       *DataAPIService
	ds               *string
	ou               *string
	pe               *[]string
	filter           *[]string
	selectedUnitOnly *bool
}

// [no description yet]
func (r ApiDataSetReportGetDataSetReportAsExcelRequest) Ds(ds string) ApiDataSetReportGetDataSetReportAsExcelRequest {
	r.ds = &ds
	return r
}

// [no description yet]
func (r ApiDataSetReportGetDataSetReportAsExcelRequest) Ou(ou string) ApiDataSetReportGetDataSetReportAsExcelRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiDataSetReportGetDataSetReportAsExcelRequest) Pe(pe []string) ApiDataSetReportGetDataSetReportAsExcelRequest {
	r.pe = &pe
	return r
}

// [no description yet]
func (r ApiDataSetReportGetDataSetReportAsExcelRequest) Filter(filter []string) ApiDataSetReportGetDataSetReportAsExcelRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiDataSetReportGetDataSetReportAsExcelRequest) SelectedUnitOnly(selectedUnitOnly bool) ApiDataSetReportGetDataSetReportAsExcelRequest {
	r.selectedUnitOnly = &selectedUnitOnly
	return r
}

func (r ApiDataSetReportGetDataSetReportAsExcelRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataSetReportGetDataSetReportAsExcelExecute(r)
}

/*
DataSetReportGetDataSetReportAsExcel Method for DataSetReportGetDataSetReportAsExcel

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataSetReportGetDataSetReportAsExcelRequest
*/
func (a *DataAPIService) DataSetReportGetDataSetReportAsExcel(ctx context.Context) ApiDataSetReportGetDataSetReportAsExcelRequest {
	return ApiDataSetReportGetDataSetReportAsExcelRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) DataSetReportGetDataSetReportAsExcelExecute(r ApiDataSetReportGetDataSetReportAsExcelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataSetReportGetDataSetReportAsExcel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataSetReport.xls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ds == nil {
		return nil, reportError("ds is required and must be specified")
	}
	if r.ou == nil {
		return nil, reportError("ou is required and must be specified")
	}
	if r.pe == nil {
		return nil, reportError("pe is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ds", r.ds, "")
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	{
		t := *r.pe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pe", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pe", t, "multi")
		}
	}
	if r.selectedUnitOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "selectedUnitOnly", r.selectedUnitOnly, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataSetReportGetDataSetReportAsJsonRequest struct {
	ctx              context.Context
	ApiService       *DataAPIService
	ds               *string
	ou               *string
	pe               *[]string
	filter           *[]string
	selectedUnitOnly *bool
}

// [no description yet]
func (r ApiDataSetReportGetDataSetReportAsJsonRequest) Ds(ds string) ApiDataSetReportGetDataSetReportAsJsonRequest {
	r.ds = &ds
	return r
}

// [no description yet]
func (r ApiDataSetReportGetDataSetReportAsJsonRequest) Ou(ou string) ApiDataSetReportGetDataSetReportAsJsonRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiDataSetReportGetDataSetReportAsJsonRequest) Pe(pe []string) ApiDataSetReportGetDataSetReportAsJsonRequest {
	r.pe = &pe
	return r
}

// [no description yet]
func (r ApiDataSetReportGetDataSetReportAsJsonRequest) Filter(filter []string) ApiDataSetReportGetDataSetReportAsJsonRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiDataSetReportGetDataSetReportAsJsonRequest) SelectedUnitOnly(selectedUnitOnly bool) ApiDataSetReportGetDataSetReportAsJsonRequest {
	r.selectedUnitOnly = &selectedUnitOnly
	return r
}

func (r ApiDataSetReportGetDataSetReportAsJsonRequest) Execute() ([]Grid, *http.Response, error) {
	return r.ApiService.DataSetReportGetDataSetReportAsJsonExecute(r)
}

/*
DataSetReportGetDataSetReportAsJson Method for DataSetReportGetDataSetReportAsJson

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataSetReportGetDataSetReportAsJsonRequest
*/
func (a *DataAPIService) DataSetReportGetDataSetReportAsJson(ctx context.Context) ApiDataSetReportGetDataSetReportAsJsonRequest {
	return ApiDataSetReportGetDataSetReportAsJsonRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Grid
func (a *DataAPIService) DataSetReportGetDataSetReportAsJsonExecute(r ApiDataSetReportGetDataSetReportAsJsonRequest) ([]Grid, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Grid
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataSetReportGetDataSetReportAsJson")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataSetReport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ds == nil {
		return localVarReturnValue, nil, reportError("ds is required and must be specified")
	}
	if r.ou == nil {
		return localVarReturnValue, nil, reportError("ou is required and must be specified")
	}
	if r.pe == nil {
		return localVarReturnValue, nil, reportError("pe is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ds", r.ds, "")
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	{
		t := *r.pe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pe", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pe", t, "multi")
		}
	}
	if r.selectedUnitOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "selectedUnitOnly", r.selectedUnitOnly, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataSetReportGetDataSetReportAsPdfRequest struct {
	ctx              context.Context
	ApiService       *DataAPIService
	ds               *string
	ou               *string
	pe               *[]string
	filter           *[]string
	selectedUnitOnly *bool
}

// [no description yet]
func (r ApiDataSetReportGetDataSetReportAsPdfRequest) Ds(ds string) ApiDataSetReportGetDataSetReportAsPdfRequest {
	r.ds = &ds
	return r
}

// [no description yet]
func (r ApiDataSetReportGetDataSetReportAsPdfRequest) Ou(ou string) ApiDataSetReportGetDataSetReportAsPdfRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiDataSetReportGetDataSetReportAsPdfRequest) Pe(pe []string) ApiDataSetReportGetDataSetReportAsPdfRequest {
	r.pe = &pe
	return r
}

// [no description yet]
func (r ApiDataSetReportGetDataSetReportAsPdfRequest) Filter(filter []string) ApiDataSetReportGetDataSetReportAsPdfRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiDataSetReportGetDataSetReportAsPdfRequest) SelectedUnitOnly(selectedUnitOnly bool) ApiDataSetReportGetDataSetReportAsPdfRequest {
	r.selectedUnitOnly = &selectedUnitOnly
	return r
}

func (r ApiDataSetReportGetDataSetReportAsPdfRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataSetReportGetDataSetReportAsPdfExecute(r)
}

/*
DataSetReportGetDataSetReportAsPdf Method for DataSetReportGetDataSetReportAsPdf

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataSetReportGetDataSetReportAsPdfRequest
*/
func (a *DataAPIService) DataSetReportGetDataSetReportAsPdf(ctx context.Context) ApiDataSetReportGetDataSetReportAsPdfRequest {
	return ApiDataSetReportGetDataSetReportAsPdfRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) DataSetReportGetDataSetReportAsPdfExecute(r ApiDataSetReportGetDataSetReportAsPdfRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataSetReportGetDataSetReportAsPdf")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataSetReport.pdf"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ds == nil {
		return nil, reportError("ds is required and must be specified")
	}
	if r.ou == nil {
		return nil, reportError("ou is required and must be specified")
	}
	if r.pe == nil {
		return nil, reportError("pe is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ds", r.ds, "")
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	{
		t := *r.pe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pe", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pe", t, "multi")
		}
	}
	if r.selectedUnitOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "selectedUnitOnly", r.selectedUnitOnly, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataSetValueGetDataValueSetRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	cc         *string
	cp         *string
	ds         *string
	ou         *string
	pe         *string
}

// [no description yet]
func (r ApiDataSetValueGetDataValueSetRequest) Cc(cc string) ApiDataSetValueGetDataValueSetRequest {
	r.cc = &cc
	return r
}

// [no description yet]
func (r ApiDataSetValueGetDataValueSetRequest) Cp(cp string) ApiDataSetValueGetDataValueSetRequest {
	r.cp = &cp
	return r
}

// [no description yet]
func (r ApiDataSetValueGetDataValueSetRequest) Ds(ds string) ApiDataSetValueGetDataValueSetRequest {
	r.ds = &ds
	return r
}

// [no description yet]
func (r ApiDataSetValueGetDataValueSetRequest) Ou(ou string) ApiDataSetValueGetDataValueSetRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiDataSetValueGetDataValueSetRequest) Pe(pe string) ApiDataSetValueGetDataValueSetRequest {
	r.pe = &pe
	return r
}

func (r ApiDataSetValueGetDataValueSetRequest) Execute() (*DataValuesDto, *http.Response, error) {
	return r.ApiService.DataSetValueGetDataValueSetExecute(r)
}

/*
DataSetValueGetDataValueSet Method for DataSetValueGetDataValueSet

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataSetValueGetDataValueSetRequest
*/
func (a *DataAPIService) DataSetValueGetDataValueSet(ctx context.Context) ApiDataSetValueGetDataValueSetRequest {
	return ApiDataSetValueGetDataValueSetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DataValuesDto
func (a *DataAPIService) DataSetValueGetDataValueSetExecute(r ApiDataSetValueGetDataValueSetRequest) (*DataValuesDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataValuesDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataSetValueGetDataValueSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataEntry/dataValues"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cc", r.cc, "")
	}
	if r.cp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cp", r.cp, "")
	}
	if r.ds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ds", r.ds, "")
	}
	if r.ou != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	}
	if r.pe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pe", r.pe, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataStatisticsGetFavoriteStatisticsRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
}

func (r ApiDataStatisticsGetFavoriteStatisticsRequest) Execute() (*FavoriteStatistics, *http.Response, error) {
	return r.ApiService.DataStatisticsGetFavoriteStatisticsExecute(r)
}

/*
DataStatisticsGetFavoriteStatistics Method for DataStatisticsGetFavoriteStatistics

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDataStatisticsGetFavoriteStatisticsRequest
*/
func (a *DataAPIService) DataStatisticsGetFavoriteStatistics(ctx context.Context, uid string) ApiDataStatisticsGetFavoriteStatisticsRequest {
	return ApiDataStatisticsGetFavoriteStatisticsRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return FavoriteStatistics
func (a *DataAPIService) DataStatisticsGetFavoriteStatisticsExecute(r ApiDataStatisticsGetFavoriteStatisticsRequest) (*FavoriteStatistics, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FavoriteStatistics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataStatisticsGetFavoriteStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataStatistics/favorites/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataStatisticsGetReportsRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	endDate    *time.Time
	interval   *string
	startDate  *time.Time
	fields     *[]string
}

// [no description yet]
func (r ApiDataStatisticsGetReportsRequest) EndDate(endDate time.Time) ApiDataStatisticsGetReportsRequest {
	r.endDate = &endDate
	return r
}

// [no description yet]
func (r ApiDataStatisticsGetReportsRequest) Interval(interval string) ApiDataStatisticsGetReportsRequest {
	r.interval = &interval
	return r
}

// [no description yet]
func (r ApiDataStatisticsGetReportsRequest) StartDate(startDate time.Time) ApiDataStatisticsGetReportsRequest {
	r.startDate = &startDate
	return r
}

// [no description yet]
func (r ApiDataStatisticsGetReportsRequest) Fields(fields []string) ApiDataStatisticsGetReportsRequest {
	r.fields = &fields
	return r
}

func (r ApiDataStatisticsGetReportsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.DataStatisticsGetReportsExecute(r)
}

/*
DataStatisticsGetReports Method for DataStatisticsGetReports

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataStatisticsGetReportsRequest
*/
func (a *DataAPIService) DataStatisticsGetReports(ctx context.Context) ApiDataStatisticsGetReportsRequest {
	return ApiDataStatisticsGetReportsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []map[string]interface{}
func (a *DataAPIService) DataStatisticsGetReportsExecute(r ApiDataStatisticsGetReportsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataStatisticsGetReports")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataStatistics/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endDate == nil {
		return localVarReturnValue, nil, reportError("endDate is required and must be specified")
	}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}
	if r.startDate == nil {
		return localVarReturnValue, nil, reportError("startDate is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataStatisticsGetTopFavoritesRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	eventType  *string
	pageSize   *int32
	sortOrder  *string
	username   *string
}

// [no description yet]
func (r ApiDataStatisticsGetTopFavoritesRequest) EventType(eventType string) ApiDataStatisticsGetTopFavoritesRequest {
	r.eventType = &eventType
	return r
}

// [no description yet]
func (r ApiDataStatisticsGetTopFavoritesRequest) PageSize(pageSize int32) ApiDataStatisticsGetTopFavoritesRequest {
	r.pageSize = &pageSize
	return r
}

// [no description yet]
func (r ApiDataStatisticsGetTopFavoritesRequest) SortOrder(sortOrder string) ApiDataStatisticsGetTopFavoritesRequest {
	r.sortOrder = &sortOrder
	return r
}

// [no description yet]
func (r ApiDataStatisticsGetTopFavoritesRequest) Username(username string) ApiDataStatisticsGetTopFavoritesRequest {
	r.username = &username
	return r
}

func (r ApiDataStatisticsGetTopFavoritesRequest) Execute() ([]FavoriteStatistics, *http.Response, error) {
	return r.ApiService.DataStatisticsGetTopFavoritesExecute(r)
}

/*
DataStatisticsGetTopFavorites Method for DataStatisticsGetTopFavorites

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataStatisticsGetTopFavoritesRequest
*/
func (a *DataAPIService) DataStatisticsGetTopFavorites(ctx context.Context) ApiDataStatisticsGetTopFavoritesRequest {
	return ApiDataStatisticsGetTopFavoritesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []FavoriteStatistics
func (a *DataAPIService) DataStatisticsGetTopFavoritesExecute(r ApiDataStatisticsGetTopFavoritesRequest) ([]FavoriteStatistics, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []FavoriteStatistics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataStatisticsGetTopFavorites")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataStatistics/favorites"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.eventType == nil {
		return localVarReturnValue, nil, reportError("eventType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "eventType", r.eventType, "")
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.username != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "username", r.username, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataStatisticsSaveEventRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	eventType  *string
	blank      *bool
	bytes      *os.File
	empty      *bool
}

// [no description yet]
func (r ApiDataStatisticsSaveEventRequest) EventType(eventType string) ApiDataStatisticsSaveEventRequest {
	r.eventType = &eventType
	return r
}

// [no description yet]
func (r ApiDataStatisticsSaveEventRequest) Blank(blank bool) ApiDataStatisticsSaveEventRequest {
	r.blank = &blank
	return r
}

// [no description yet]
func (r ApiDataStatisticsSaveEventRequest) Bytes(bytes *os.File) ApiDataStatisticsSaveEventRequest {
	r.bytes = bytes
	return r
}

// [no description yet]
func (r ApiDataStatisticsSaveEventRequest) Empty(empty bool) ApiDataStatisticsSaveEventRequest {
	r.empty = &empty
	return r
}

func (r ApiDataStatisticsSaveEventRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataStatisticsSaveEventExecute(r)
}

/*
DataStatisticsSaveEvent Method for DataStatisticsSaveEvent

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataStatisticsSaveEventRequest
*/
func (a *DataAPIService) DataStatisticsSaveEvent(ctx context.Context) ApiDataStatisticsSaveEventRequest {
	return ApiDataStatisticsSaveEventRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) DataStatisticsSaveEventExecute(r ApiDataStatisticsSaveEventRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataStatisticsSaveEvent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataStatistics/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.eventType == nil {
		return nil, reportError("eventType is required and must be specified")
	}

	if r.blank != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blank", r.blank, "")
	}
	if r.bytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bytes", r.bytes, "")
	}
	if r.empty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "empty", r.empty, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "eventType", r.eventType, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataStatisticsSaveSnapshotRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
}

func (r ApiDataStatisticsSaveSnapshotRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataStatisticsSaveSnapshotExecute(r)
}

/*
DataStatisticsSaveSnapshot Method for DataStatisticsSaveSnapshot

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataStatisticsSaveSnapshotRequest
*/
func (a *DataAPIService) DataStatisticsSaveSnapshot(ctx context.Context) ApiDataStatisticsSaveSnapshotRequest {
	return ApiDataStatisticsSaveSnapshotRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) DataStatisticsSaveSnapshotExecute(r ApiDataStatisticsSaveSnapshotRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataStatisticsSaveSnapshot")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataStatistics/snapshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataSummaryGetStatisticsRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
}

func (r ApiDataSummaryGetStatisticsRequest) Execute() (*DataSummary, *http.Response, error) {
	return r.ApiService.DataSummaryGetStatisticsExecute(r)
}

/*
DataSummaryGetStatistics Method for DataSummaryGetStatistics

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataSummaryGetStatisticsRequest
*/
func (a *DataAPIService) DataSummaryGetStatistics(ctx context.Context) ApiDataSummaryGetStatisticsRequest {
	return ApiDataSummaryGetStatisticsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DataSummary
func (a *DataAPIService) DataSummaryGetStatisticsExecute(r ApiDataSummaryGetStatisticsRequest) (*DataSummary, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataSummaryGetStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataSummary/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataValueContextGetChangeLogRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	cc         *string
	co         *string
	cp         *string
	de         *string
	ou         *string
	pe         *string
}

// [no description yet]
func (r ApiDataValueContextGetChangeLogRequest) Cc(cc string) ApiDataValueContextGetChangeLogRequest {
	r.cc = &cc
	return r
}

// [no description yet]
func (r ApiDataValueContextGetChangeLogRequest) Co(co string) ApiDataValueContextGetChangeLogRequest {
	r.co = &co
	return r
}

// [no description yet]
func (r ApiDataValueContextGetChangeLogRequest) Cp(cp string) ApiDataValueContextGetChangeLogRequest {
	r.cp = &cp
	return r
}

// [no description yet]
func (r ApiDataValueContextGetChangeLogRequest) De(de string) ApiDataValueContextGetChangeLogRequest {
	r.de = &de
	return r
}

// [no description yet]
func (r ApiDataValueContextGetChangeLogRequest) Ou(ou string) ApiDataValueContextGetChangeLogRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiDataValueContextGetChangeLogRequest) Pe(pe string) ApiDataValueContextGetChangeLogRequest {
	r.pe = &pe
	return r
}

func (r ApiDataValueContextGetChangeLogRequest) Execute() (*DataValueContextDto, *http.Response, error) {
	return r.ApiService.DataValueContextGetChangeLogExecute(r)
}

/*
DataValueContextGetChangeLog Method for DataValueContextGetChangeLog

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataValueContextGetChangeLogRequest
*/
func (a *DataAPIService) DataValueContextGetChangeLog(ctx context.Context) ApiDataValueContextGetChangeLogRequest {
	return ApiDataValueContextGetChangeLogRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DataValueContextDto
func (a *DataAPIService) DataValueContextGetChangeLogExecute(r ApiDataValueContextGetChangeLogRequest) (*DataValueContextDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataValueContextDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataValueContextGetChangeLog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataEntry/dataValueContext"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cc", r.cc, "")
	}
	if r.co != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "co", r.co, "")
	}
	if r.cp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cp", r.cp, "")
	}
	if r.de != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "de", r.de, "")
	}
	if r.ou != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	}
	if r.pe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pe", r.pe, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataValueDeleteDataValueRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	cc         *string
	co         *string
	cp         *string
	de         *string
	ds         *string
	force      *bool
	ou         *string
	pe         *string
}

// [no description yet]
func (r ApiDataValueDeleteDataValueRequest) Cc(cc string) ApiDataValueDeleteDataValueRequest {
	r.cc = &cc
	return r
}

// [no description yet]
func (r ApiDataValueDeleteDataValueRequest) Co(co string) ApiDataValueDeleteDataValueRequest {
	r.co = &co
	return r
}

// [no description yet]
func (r ApiDataValueDeleteDataValueRequest) Cp(cp string) ApiDataValueDeleteDataValueRequest {
	r.cp = &cp
	return r
}

// [no description yet]
func (r ApiDataValueDeleteDataValueRequest) De(de string) ApiDataValueDeleteDataValueRequest {
	r.de = &de
	return r
}

// [no description yet]
func (r ApiDataValueDeleteDataValueRequest) Ds(ds string) ApiDataValueDeleteDataValueRequest {
	r.ds = &ds
	return r
}

// [no description yet]
func (r ApiDataValueDeleteDataValueRequest) Force(force bool) ApiDataValueDeleteDataValueRequest {
	r.force = &force
	return r
}

// [no description yet]
func (r ApiDataValueDeleteDataValueRequest) Ou(ou string) ApiDataValueDeleteDataValueRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiDataValueDeleteDataValueRequest) Pe(pe string) ApiDataValueDeleteDataValueRequest {
	r.pe = &pe
	return r
}

func (r ApiDataValueDeleteDataValueRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataValueDeleteDataValueExecute(r)
}

/*
DataValueDeleteDataValue Method for DataValueDeleteDataValue

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataValueDeleteDataValueRequest
*/
func (a *DataAPIService) DataValueDeleteDataValue(ctx context.Context) ApiDataValueDeleteDataValueRequest {
	return ApiDataValueDeleteDataValueRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) DataValueDeleteDataValueExecute(r ApiDataValueDeleteDataValueRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataValueDeleteDataValue")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataValues/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cc", r.cc, "")
	}
	if r.co != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "co", r.co, "")
	}
	if r.cp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cp", r.cp, "")
	}
	if r.de != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "de", r.de, "")
	}
	if r.ds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ds", r.ds, "")
	}
	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	}
	if r.ou != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	}
	if r.pe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pe", r.pe, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataValueGetDataValueRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	cc         *string
	co         *string
	cp         *string
	de         *string
	ou         *string
	pe         *string
}

// [no description yet]
func (r ApiDataValueGetDataValueRequest) Cc(cc string) ApiDataValueGetDataValueRequest {
	r.cc = &cc
	return r
}

// [no description yet]
func (r ApiDataValueGetDataValueRequest) Co(co string) ApiDataValueGetDataValueRequest {
	r.co = &co
	return r
}

// [no description yet]
func (r ApiDataValueGetDataValueRequest) Cp(cp string) ApiDataValueGetDataValueRequest {
	r.cp = &cp
	return r
}

// [no description yet]
func (r ApiDataValueGetDataValueRequest) De(de string) ApiDataValueGetDataValueRequest {
	r.de = &de
	return r
}

// [no description yet]
func (r ApiDataValueGetDataValueRequest) Ou(ou string) ApiDataValueGetDataValueRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiDataValueGetDataValueRequest) Pe(pe string) ApiDataValueGetDataValueRequest {
	r.pe = &pe
	return r
}

func (r ApiDataValueGetDataValueRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.DataValueGetDataValueExecute(r)
}

/*
DataValueGetDataValue Method for DataValueGetDataValue

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataValueGetDataValueRequest
*/
func (a *DataAPIService) DataValueGetDataValue(ctx context.Context) ApiDataValueGetDataValueRequest {
	return ApiDataValueGetDataValueRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []string
func (a *DataAPIService) DataValueGetDataValueExecute(r ApiDataValueGetDataValueRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataValueGetDataValue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataValues/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cc", r.cc, "")
	}
	if r.co != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "co", r.co, "")
	}
	if r.cp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cp", r.cp, "")
	}
	if r.de != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "de", r.de, "")
	}
	if r.ou != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	}
	if r.pe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pe", r.pe, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataValueGetDataValueFileRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	cc         *string
	co         *string
	cp         *string
	de         *string
	dimension  *string
	ou         *string
	pe         *string
}

// [no description yet]
func (r ApiDataValueGetDataValueFileRequest) Cc(cc string) ApiDataValueGetDataValueFileRequest {
	r.cc = &cc
	return r
}

// [no description yet]
func (r ApiDataValueGetDataValueFileRequest) Co(co string) ApiDataValueGetDataValueFileRequest {
	r.co = &co
	return r
}

// [no description yet]
func (r ApiDataValueGetDataValueFileRequest) Cp(cp string) ApiDataValueGetDataValueFileRequest {
	r.cp = &cp
	return r
}

// [no description yet]
func (r ApiDataValueGetDataValueFileRequest) De(de string) ApiDataValueGetDataValueFileRequest {
	r.de = &de
	return r
}

// [no description yet]
func (r ApiDataValueGetDataValueFileRequest) Dimension(dimension string) ApiDataValueGetDataValueFileRequest {
	r.dimension = &dimension
	return r
}

// [no description yet]
func (r ApiDataValueGetDataValueFileRequest) Ou(ou string) ApiDataValueGetDataValueFileRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiDataValueGetDataValueFileRequest) Pe(pe string) ApiDataValueGetDataValueFileRequest {
	r.pe = &pe
	return r
}

func (r ApiDataValueGetDataValueFileRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.DataValueGetDataValueFileExecute(r)
}

/*
DataValueGetDataValueFile Method for DataValueGetDataValueFile

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataValueGetDataValueFileRequest
*/
func (a *DataAPIService) DataValueGetDataValueFile(ctx context.Context) ApiDataValueGetDataValueFileRequest {
	return ApiDataValueGetDataValueFileRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *DataAPIService) DataValueGetDataValueFileExecute(r ApiDataValueGetDataValueFileRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataValueGetDataValueFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataValues/files"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cc", r.cc, "")
	}
	if r.co != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "co", r.co, "")
	}
	if r.cp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cp", r.cp, "")
	}
	if r.de != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "de", r.de, "")
	}
	if r.dimension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dimension", r.dimension, "")
	} else {
		var defaultValue string = "original"
		r.dimension = &defaultValue
	}
	if r.ou != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	}
	if r.pe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pe", r.pe, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataValueSaveDataValueRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	de         *string
	ou         *string
	pe         *string
	cc         *string
	co         *string
	comment    *string
	cp         *string
	ds         *string
	followUp   *bool
	force      *bool
	value      *string
}

// [no description yet]
func (r ApiDataValueSaveDataValueRequest) De(de string) ApiDataValueSaveDataValueRequest {
	r.de = &de
	return r
}

// [no description yet]
func (r ApiDataValueSaveDataValueRequest) Ou(ou string) ApiDataValueSaveDataValueRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiDataValueSaveDataValueRequest) Pe(pe string) ApiDataValueSaveDataValueRequest {
	r.pe = &pe
	return r
}

// [no description yet]
func (r ApiDataValueSaveDataValueRequest) Cc(cc string) ApiDataValueSaveDataValueRequest {
	r.cc = &cc
	return r
}

// [no description yet]
func (r ApiDataValueSaveDataValueRequest) Co(co string) ApiDataValueSaveDataValueRequest {
	r.co = &co
	return r
}

// [no description yet]
func (r ApiDataValueSaveDataValueRequest) Comment(comment string) ApiDataValueSaveDataValueRequest {
	r.comment = &comment
	return r
}

// [no description yet]
func (r ApiDataValueSaveDataValueRequest) Cp(cp string) ApiDataValueSaveDataValueRequest {
	r.cp = &cp
	return r
}

// [no description yet]
func (r ApiDataValueSaveDataValueRequest) Ds(ds string) ApiDataValueSaveDataValueRequest {
	r.ds = &ds
	return r
}

// [no description yet]
func (r ApiDataValueSaveDataValueRequest) FollowUp(followUp bool) ApiDataValueSaveDataValueRequest {
	r.followUp = &followUp
	return r
}

// [no description yet]
func (r ApiDataValueSaveDataValueRequest) Force(force bool) ApiDataValueSaveDataValueRequest {
	r.force = &force
	return r
}

// [no description yet]
func (r ApiDataValueSaveDataValueRequest) Value(value string) ApiDataValueSaveDataValueRequest {
	r.value = &value
	return r
}

func (r ApiDataValueSaveDataValueRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataValueSaveDataValueExecute(r)
}

/*
DataValueSaveDataValue Method for DataValueSaveDataValue

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataValueSaveDataValueRequest
*/
func (a *DataAPIService) DataValueSaveDataValue(ctx context.Context) ApiDataValueSaveDataValueRequest {
	return ApiDataValueSaveDataValueRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) DataValueSaveDataValueExecute(r ApiDataValueSaveDataValueRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataValueSaveDataValue")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataValues/#saveDataValue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.de == nil {
		return nil, reportError("de is required and must be specified")
	}
	if strlen(*r.de) < 11 {
		return nil, reportError("de must have at least 11 elements")
	}
	if strlen(*r.de) > 11 {
		return nil, reportError("de must have less than 11 elements")
	}
	if r.ou == nil {
		return nil, reportError("ou is required and must be specified")
	}
	if strlen(*r.ou) < 11 {
		return nil, reportError("ou must have at least 11 elements")
	}
	if strlen(*r.ou) > 11 {
		return nil, reportError("ou must have less than 11 elements")
	}
	if r.pe == nil {
		return nil, reportError("pe is required and must be specified")
	}

	if r.cc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cc", r.cc, "")
	}
	if r.co != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "co", r.co, "")
	}
	if r.comment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "comment", r.comment, "")
	}
	if r.cp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cp", r.cp, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "de", r.de, "")
	if r.ds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ds", r.ds, "")
	}
	if r.followUp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUp", r.followUp, "")
	}
	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pe", r.pe, "")
	if r.value != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "value", r.value, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataValueSaveDataValueWithBodyRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	dataValueDto *DataValueDto
}

// [no description yet]
func (r ApiDataValueSaveDataValueWithBodyRequest) DataValueDto(dataValueDto DataValueDto) ApiDataValueSaveDataValueWithBodyRequest {
	r.dataValueDto = &dataValueDto
	return r
}

func (r ApiDataValueSaveDataValueWithBodyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataValueSaveDataValueWithBodyExecute(r)
}

/*
DataValueSaveDataValueWithBody Method for DataValueSaveDataValueWithBody

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataValueSaveDataValueWithBodyRequest
*/
func (a *DataAPIService) DataValueSaveDataValueWithBody(ctx context.Context) ApiDataValueSaveDataValueWithBodyRequest {
	return ApiDataValueSaveDataValueWithBodyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) DataValueSaveDataValueWithBodyExecute(r ApiDataValueSaveDataValueWithBodyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataValueSaveDataValueWithBody")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataValues/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataValueDto == nil {
		return nil, reportError("dataValueDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataValueDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataValueSaveFileDataValueRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	de         *string
	ou         *string
	pe         *string
	cc         *string
	co         *string
	comment    *string
	cp         *string
	ds         *string
	file       *os.File
	followUp   *bool
	force      *bool
}

// [no description yet]
func (r ApiDataValueSaveFileDataValueRequest) De(de string) ApiDataValueSaveFileDataValueRequest {
	r.de = &de
	return r
}

// [no description yet]
func (r ApiDataValueSaveFileDataValueRequest) Ou(ou string) ApiDataValueSaveFileDataValueRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiDataValueSaveFileDataValueRequest) Pe(pe string) ApiDataValueSaveFileDataValueRequest {
	r.pe = &pe
	return r
}

// [no description yet]
func (r ApiDataValueSaveFileDataValueRequest) Cc(cc string) ApiDataValueSaveFileDataValueRequest {
	r.cc = &cc
	return r
}

// [no description yet]
func (r ApiDataValueSaveFileDataValueRequest) Co(co string) ApiDataValueSaveFileDataValueRequest {
	r.co = &co
	return r
}

// [no description yet]
func (r ApiDataValueSaveFileDataValueRequest) Comment(comment string) ApiDataValueSaveFileDataValueRequest {
	r.comment = &comment
	return r
}

// [no description yet]
func (r ApiDataValueSaveFileDataValueRequest) Cp(cp string) ApiDataValueSaveFileDataValueRequest {
	r.cp = &cp
	return r
}

// [no description yet]
func (r ApiDataValueSaveFileDataValueRequest) Ds(ds string) ApiDataValueSaveFileDataValueRequest {
	r.ds = &ds
	return r
}

// [no description yet]
func (r ApiDataValueSaveFileDataValueRequest) File(file *os.File) ApiDataValueSaveFileDataValueRequest {
	r.file = file
	return r
}

// [no description yet]
func (r ApiDataValueSaveFileDataValueRequest) FollowUp(followUp bool) ApiDataValueSaveFileDataValueRequest {
	r.followUp = &followUp
	return r
}

// [no description yet]
func (r ApiDataValueSaveFileDataValueRequest) Force(force bool) ApiDataValueSaveFileDataValueRequest {
	r.force = &force
	return r
}

func (r ApiDataValueSaveFileDataValueRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DataValueSaveFileDataValueExecute(r)
}

/*
DataValueSaveFileDataValue Method for DataValueSaveFileDataValue

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataValueSaveFileDataValueRequest
*/
func (a *DataAPIService) DataValueSaveFileDataValue(ctx context.Context) ApiDataValueSaveFileDataValueRequest {
	return ApiDataValueSaveFileDataValueRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) DataValueSaveFileDataValueExecute(r ApiDataValueSaveFileDataValueRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataValueSaveFileDataValue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataValues/file"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.de == nil {
		return localVarReturnValue, nil, reportError("de is required and must be specified")
	}
	if strlen(*r.de) < 11 {
		return localVarReturnValue, nil, reportError("de must have at least 11 elements")
	}
	if strlen(*r.de) > 11 {
		return localVarReturnValue, nil, reportError("de must have less than 11 elements")
	}
	if r.ou == nil {
		return localVarReturnValue, nil, reportError("ou is required and must be specified")
	}
	if strlen(*r.ou) < 11 {
		return localVarReturnValue, nil, reportError("ou must have at least 11 elements")
	}
	if strlen(*r.ou) > 11 {
		return localVarReturnValue, nil, reportError("ou must have less than 11 elements")
	}
	if r.pe == nil {
		return localVarReturnValue, nil, reportError("pe is required and must be specified")
	}

	if r.cc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cc", r.cc, "")
	}
	if r.co != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "co", r.co, "")
	}
	if r.comment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "comment", r.comment, "")
	}
	if r.cp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cp", r.cp, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "de", r.de, "")
	if r.ds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ds", r.ds, "")
	}
	if r.file != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "file", r.file, "")
	}
	if r.followUp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUp", r.followUp, "")
	}
	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pe", r.pe, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataValueSetDataValueFollowUpRequest struct {
	ctx                      context.Context
	ApiService               *DataAPIService
	dataValueFollowUpRequest *DataValueFollowUpRequest
}

// [no description yet]
func (r ApiDataValueSetDataValueFollowUpRequest) DataValueFollowUpRequest(dataValueFollowUpRequest DataValueFollowUpRequest) ApiDataValueSetDataValueFollowUpRequest {
	r.dataValueFollowUpRequest = &dataValueFollowUpRequest
	return r
}

func (r ApiDataValueSetDataValueFollowUpRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataValueSetDataValueFollowUpExecute(r)
}

/*
DataValueSetDataValueFollowUp Method for DataValueSetDataValueFollowUp

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataValueSetDataValueFollowUpRequest
*/
func (a *DataAPIService) DataValueSetDataValueFollowUp(ctx context.Context) ApiDataValueSetDataValueFollowUpRequest {
	return ApiDataValueSetDataValueFollowUpRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) DataValueSetDataValueFollowUpExecute(r ApiDataValueSetDataValueFollowUpRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataValueSetDataValueFollowUp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataValues/followup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataValueFollowUpRequest == nil {
		return nil, reportError("dataValueFollowUpRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataValueFollowUpRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataValueSetDataValuesFollowUpRequest struct {
	ctx                       context.Context
	ApiService                *DataAPIService
	dataValuesFollowUpRequest *DataValuesFollowUpRequest
}

// [no description yet]
func (r ApiDataValueSetDataValuesFollowUpRequest) DataValuesFollowUpRequest(dataValuesFollowUpRequest DataValuesFollowUpRequest) ApiDataValueSetDataValuesFollowUpRequest {
	r.dataValuesFollowUpRequest = &dataValuesFollowUpRequest
	return r
}

func (r ApiDataValueSetDataValuesFollowUpRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataValueSetDataValuesFollowUpExecute(r)
}

/*
DataValueSetDataValuesFollowUp Method for DataValueSetDataValuesFollowUp

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataValueSetDataValuesFollowUpRequest
*/
func (a *DataAPIService) DataValueSetDataValuesFollowUp(ctx context.Context) ApiDataValueSetDataValuesFollowUpRequest {
	return ApiDataValueSetDataValuesFollowUpRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) DataValueSetDataValuesFollowUpExecute(r ApiDataValueSetDataValuesFollowUpRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataValueSetDataValuesFollowUp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataValues/followups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataValuesFollowUpRequest == nil {
		return nil, reportError("dataValuesFollowUpRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataValuesFollowUpRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest struct {
	ctx                            context.Context
	ApiService                     *DataAPIService
	attachment                     *string
	attributeCombo                 *string
	attributeOptionCombo           *[]string
	attributeOptionComboIdScheme   *string
	attributeOptions               *[]string
	categoryIdScheme               *string
	categoryOptionComboIdScheme    *string
	categoryOptionIdScheme         *string
	children                       *bool
	compression                    *string
	dataElement                    *[]string
	dataElementGroup               *[]string
	dataElementIdScheme            *string
	dataSet                        *[]string
	dataSetIdScheme                *string
	endDate                        *time.Time
	idScheme                       *string
	includeDeleted                 *bool
	inputDataElementGroupIdScheme  *string
	inputDataElementIdScheme       *string
	inputDataSetIdScheme           *string
	inputIdScheme                  *string
	inputOrgUnitIdScheme           *string
	lastUpdated                    *time.Time
	lastUpdatedDuration            *string
	limit                          *int32
	orgUnit                        *[]string
	orgUnitGroup                   *[]string
	orgUnitIdScheme                *string
	period                         *[]string
	programIdScheme                *string
	programStageIdScheme           *string
	programStageInstanceIdScheme   *string
	startDate                      *time.Time
	trackedEntityAttributeIdScheme *string
	trackedEntityIdScheme          *string
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) Attachment(attachment string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.attachment = &attachment
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) AttributeCombo(attributeCombo string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.attributeCombo = &attributeCombo
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) AttributeOptionCombo(attributeOptionCombo []string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.attributeOptionCombo = &attributeOptionCombo
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) AttributeOptionComboIdScheme(attributeOptionComboIdScheme string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.attributeOptionComboIdScheme = &attributeOptionComboIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) AttributeOptions(attributeOptions []string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.attributeOptions = &attributeOptions
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) CategoryIdScheme(categoryIdScheme string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.categoryIdScheme = &categoryIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) CategoryOptionComboIdScheme(categoryOptionComboIdScheme string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.categoryOptionComboIdScheme = &categoryOptionComboIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) CategoryOptionIdScheme(categoryOptionIdScheme string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.categoryOptionIdScheme = &categoryOptionIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) Children(children bool) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.children = &children
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) Compression(compression string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.compression = &compression
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) DataElement(dataElement []string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.dataElement = &dataElement
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) DataElementGroup(dataElementGroup []string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.dataElementGroup = &dataElementGroup
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) DataElementIdScheme(dataElementIdScheme string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.dataElementIdScheme = &dataElementIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) DataSet(dataSet []string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.dataSet = &dataSet
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) DataSetIdScheme(dataSetIdScheme string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.dataSetIdScheme = &dataSetIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) EndDate(endDate time.Time) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.endDate = &endDate
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) IdScheme(idScheme string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.idScheme = &idScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) IncludeDeleted(includeDeleted bool) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.includeDeleted = &includeDeleted
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) InputDataElementGroupIdScheme(inputDataElementGroupIdScheme string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.inputDataElementGroupIdScheme = &inputDataElementGroupIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) InputDataElementIdScheme(inputDataElementIdScheme string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.inputDataElementIdScheme = &inputDataElementIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) InputDataSetIdScheme(inputDataSetIdScheme string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.inputDataSetIdScheme = &inputDataSetIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) InputIdScheme(inputIdScheme string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.inputIdScheme = &inputIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) InputOrgUnitIdScheme(inputOrgUnitIdScheme string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.inputOrgUnitIdScheme = &inputOrgUnitIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) LastUpdated(lastUpdated time.Time) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.lastUpdated = &lastUpdated
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) LastUpdatedDuration(lastUpdatedDuration string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.lastUpdatedDuration = &lastUpdatedDuration
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) Limit(limit int32) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.limit = &limit
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) OrgUnit(orgUnit []string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.orgUnit = &orgUnit
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) OrgUnitGroup(orgUnitGroup []string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.orgUnitGroup = &orgUnitGroup
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) OrgUnitIdScheme(orgUnitIdScheme string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.orgUnitIdScheme = &orgUnitIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) Period(period []string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.period = &period
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) ProgramIdScheme(programIdScheme string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.programIdScheme = &programIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) ProgramStageIdScheme(programStageIdScheme string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.programStageIdScheme = &programStageIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) ProgramStageInstanceIdScheme(programStageInstanceIdScheme string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.programStageInstanceIdScheme = &programStageInstanceIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) StartDate(startDate time.Time) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.startDate = &startDate
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) TrackedEntityAttributeIdScheme(trackedEntityAttributeIdScheme string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.trackedEntityAttributeIdScheme = &trackedEntityAttributeIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) TrackedEntityIdScheme(trackedEntityIdScheme string) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	r.trackedEntityIdScheme = &trackedEntityIdScheme
	return r
}

func (r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) Execute() (*DataValueSet, *http.Response, error) {
	return r.ApiService.DataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxExecute(r)
}

/*
DataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdx Method for DataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdx

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest
*/
func (a *DataAPIService) DataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdx(ctx context.Context) ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest {
	return ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DataValueSet
func (a *DataAPIService) DataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxExecute(r ApiDataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdxRequest) (*DataValueSet, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataValueSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataValueSetGetDataValueSetXmlgetDataValueSetJsongetDataValueSetCsvgetDataValueSetXmlAdx")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataValueSets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.attachment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachment", r.attachment, "")
	}
	if r.attributeCombo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attributeCombo", r.attributeCombo, "")
	}
	if r.attributeOptionCombo != nil {
		t := *r.attributeOptionCombo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attributeOptionCombo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attributeOptionCombo", t, "multi")
		}
	}
	if r.attributeOptionComboIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attributeOptionComboIdScheme", r.attributeOptionComboIdScheme, "")
	}
	if r.attributeOptions != nil {
		t := *r.attributeOptions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attributeOptions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attributeOptions", t, "multi")
		}
	}
	if r.categoryIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIdScheme", r.categoryIdScheme, "")
	}
	if r.categoryOptionComboIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryOptionComboIdScheme", r.categoryOptionComboIdScheme, "")
	}
	if r.categoryOptionIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryOptionIdScheme", r.categoryOptionIdScheme, "")
	}
	if r.children != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "children", r.children, "")
	} else {
		var defaultValue bool = false
		r.children = &defaultValue
	}
	if r.compression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compression", r.compression, "")
	}
	if r.dataElement != nil {
		t := *r.dataElement
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dataElement", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dataElement", t, "multi")
		}
	}
	if r.dataElementGroup != nil {
		t := *r.dataElementGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dataElementGroup", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dataElementGroup", t, "multi")
		}
	}
	if r.dataElementIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataElementIdScheme", r.dataElementIdScheme, "")
	}
	if r.dataSet != nil {
		t := *r.dataSet
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dataSet", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dataSet", t, "multi")
		}
	}
	if r.dataSetIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSetIdScheme", r.dataSetIdScheme, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.idScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idScheme", r.idScheme, "")
	}
	if r.includeDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDeleted", r.includeDeleted, "")
	} else {
		var defaultValue bool = false
		r.includeDeleted = &defaultValue
	}
	if r.inputDataElementGroupIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inputDataElementGroupIdScheme", r.inputDataElementGroupIdScheme, "")
	}
	if r.inputDataElementIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inputDataElementIdScheme", r.inputDataElementIdScheme, "")
	}
	if r.inputDataSetIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inputDataSetIdScheme", r.inputDataSetIdScheme, "")
	}
	if r.inputIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inputIdScheme", r.inputIdScheme, "")
	}
	if r.inputOrgUnitIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inputOrgUnitIdScheme", r.inputOrgUnitIdScheme, "")
	}
	if r.lastUpdated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastUpdated", r.lastUpdated, "")
	}
	if r.lastUpdatedDuration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastUpdatedDuration", r.lastUpdatedDuration, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.orgUnit != nil {
		t := *r.orgUnit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orgUnit", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orgUnit", t, "multi")
		}
	}
	if r.orgUnitGroup != nil {
		t := *r.orgUnitGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orgUnitGroup", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orgUnitGroup", t, "multi")
		}
	}
	if r.orgUnitIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orgUnitIdScheme", r.orgUnitIdScheme, "")
	}
	if r.period != nil {
		t := *r.period
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "period", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "period", t, "multi")
		}
	}
	if r.programIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "programIdScheme", r.programIdScheme, "")
	}
	if r.programStageIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "programStageIdScheme", r.programStageIdScheme, "")
	}
	if r.programStageInstanceIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "programStageInstanceIdScheme", r.programStageInstanceIdScheme, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.trackedEntityAttributeIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trackedEntityAttributeIdScheme", r.trackedEntityAttributeIdScheme, "")
	}
	if r.trackedEntityIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trackedEntityIdScheme", r.trackedEntityIdScheme, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/adx+xml;charset=UTF-8", "application/csv;charset=UTF-8", "application/json;charset=UTF-8", "application/xml;charset=UTF-8", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest struct {
	ctx                            context.Context
	ApiService                     *DataAPIService
	async                          *bool
	categoryIdScheme               *string
	categoryOptionComboIdScheme    *string
	categoryOptionIdScheme         *string
	dataElementIdScheme            *string
	dataSet                        *string
	dataSetIdScheme                *string
	datasetAllowsPeriods           *bool
	dryRun                         *bool
	eventIdScheme                  *string
	filename                       *string
	firstRowIsHeader               *bool
	force                          *bool
	idScheme                       *string
	ignoreEmptyCollection          *bool
	importStrategy                 *string
	mergeDataValues                *bool
	mergeMode                      *string
	notificationLevel              *string
	orgUnitIdScheme                *string
	preheatCache                   *bool
	programIdScheme                *string
	programStageIdScheme           *string
	reportMode                     *string
	requireAttributeOptionCombo    *bool
	requireCategoryOptionCombo     *bool
	sharing                        *bool
	skipAudit                      *bool
	skipCache                      *bool
	skipExistingCheck              *bool
	skipLastUpdated                *bool
	skipNotifications              *bool
	skipPatternValidation          *bool
	strictAttributeOptionCombos    *bool
	strictCategoryOptionCombos     *bool
	strictDataElements             *bool
	strictDataSetApproval          *bool
	strictDataSetInputPeriods      *bool
	strictDataSetLocking           *bool
	strictOrganisationUnits        *bool
	strictPeriods                  *bool
	trackedEntityAttributeIdScheme *string
	trackedEntityIdScheme          *string
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) Async(async bool) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.async = &async
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) CategoryIdScheme(categoryIdScheme string) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.categoryIdScheme = &categoryIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) CategoryOptionComboIdScheme(categoryOptionComboIdScheme string) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.categoryOptionComboIdScheme = &categoryOptionComboIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) CategoryOptionIdScheme(categoryOptionIdScheme string) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.categoryOptionIdScheme = &categoryOptionIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) DataElementIdScheme(dataElementIdScheme string) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.dataElementIdScheme = &dataElementIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) DataSet(dataSet string) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.dataSet = &dataSet
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) DataSetIdScheme(dataSetIdScheme string) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.dataSetIdScheme = &dataSetIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) DatasetAllowsPeriods(datasetAllowsPeriods bool) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.datasetAllowsPeriods = &datasetAllowsPeriods
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) DryRun(dryRun bool) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.dryRun = &dryRun
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) EventIdScheme(eventIdScheme string) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.eventIdScheme = &eventIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) Filename(filename string) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.filename = &filename
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) FirstRowIsHeader(firstRowIsHeader bool) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.firstRowIsHeader = &firstRowIsHeader
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) Force(force bool) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.force = &force
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) IdScheme(idScheme string) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.idScheme = &idScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) IgnoreEmptyCollection(ignoreEmptyCollection bool) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.ignoreEmptyCollection = &ignoreEmptyCollection
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) ImportStrategy(importStrategy string) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.importStrategy = &importStrategy
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) MergeDataValues(mergeDataValues bool) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.mergeDataValues = &mergeDataValues
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) MergeMode(mergeMode string) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) NotificationLevel(notificationLevel string) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.notificationLevel = &notificationLevel
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) OrgUnitIdScheme(orgUnitIdScheme string) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.orgUnitIdScheme = &orgUnitIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) PreheatCache(preheatCache bool) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.preheatCache = &preheatCache
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) ProgramIdScheme(programIdScheme string) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.programIdScheme = &programIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) ProgramStageIdScheme(programStageIdScheme string) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.programStageIdScheme = &programStageIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) ReportMode(reportMode string) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.reportMode = &reportMode
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) RequireAttributeOptionCombo(requireAttributeOptionCombo bool) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.requireAttributeOptionCombo = &requireAttributeOptionCombo
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) RequireCategoryOptionCombo(requireCategoryOptionCombo bool) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.requireCategoryOptionCombo = &requireCategoryOptionCombo
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) Sharing(sharing bool) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.sharing = &sharing
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) SkipAudit(skipAudit bool) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.skipAudit = &skipAudit
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) SkipCache(skipCache bool) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.skipCache = &skipCache
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) SkipExistingCheck(skipExistingCheck bool) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.skipExistingCheck = &skipExistingCheck
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) SkipLastUpdated(skipLastUpdated bool) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.skipLastUpdated = &skipLastUpdated
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) SkipNotifications(skipNotifications bool) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.skipNotifications = &skipNotifications
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) SkipPatternValidation(skipPatternValidation bool) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.skipPatternValidation = &skipPatternValidation
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) StrictAttributeOptionCombos(strictAttributeOptionCombos bool) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.strictAttributeOptionCombos = &strictAttributeOptionCombos
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) StrictCategoryOptionCombos(strictCategoryOptionCombos bool) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.strictCategoryOptionCombos = &strictCategoryOptionCombos
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) StrictDataElements(strictDataElements bool) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.strictDataElements = &strictDataElements
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) StrictDataSetApproval(strictDataSetApproval bool) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.strictDataSetApproval = &strictDataSetApproval
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) StrictDataSetInputPeriods(strictDataSetInputPeriods bool) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.strictDataSetInputPeriods = &strictDataSetInputPeriods
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) StrictDataSetLocking(strictDataSetLocking bool) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.strictDataSetLocking = &strictDataSetLocking
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) StrictOrganisationUnits(strictOrganisationUnits bool) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.strictOrganisationUnits = &strictOrganisationUnits
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) StrictPeriods(strictPeriods bool) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.strictPeriods = &strictPeriods
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) TrackedEntityAttributeIdScheme(trackedEntityAttributeIdScheme string) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.trackedEntityAttributeIdScheme = &trackedEntityAttributeIdScheme
	return r
}

// [no description yet]
func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) TrackedEntityIdScheme(trackedEntityIdScheme string) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	r.trackedEntityIdScheme = &trackedEntityIdScheme
	return r
}

func (r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetExecute(r)
}

/*
DataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSet Method for DataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSet

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest
*/
func (a *DataAPIService) DataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSet(ctx context.Context) ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest {
	return ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) DataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetExecute(r ApiDataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSetRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DataValueSetPostAdxDataValueSetpostDxf2DataValueSetpostAdxDataValueSetpostJsonDataValueSetpostCsvDataValueSetpostPdfDataValueSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataValueSets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	if r.categoryIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIdScheme", r.categoryIdScheme, "")
	}
	if r.categoryOptionComboIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryOptionComboIdScheme", r.categoryOptionComboIdScheme, "")
	}
	if r.categoryOptionIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryOptionIdScheme", r.categoryOptionIdScheme, "")
	}
	if r.dataElementIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataElementIdScheme", r.dataElementIdScheme, "")
	}
	if r.dataSet != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSet", r.dataSet, "")
	}
	if r.dataSetIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSetIdScheme", r.dataSetIdScheme, "")
	}
	if r.datasetAllowsPeriods != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "datasetAllowsPeriods", r.datasetAllowsPeriods, "")
	} else {
		var defaultValue bool = false
		r.datasetAllowsPeriods = &defaultValue
	}
	if r.dryRun != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dryRun", r.dryRun, "")
	} else {
		var defaultValue bool = false
		r.dryRun = &defaultValue
	}
	if r.eventIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventIdScheme", r.eventIdScheme, "")
	}
	if r.filename != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filename", r.filename, "")
	}
	if r.firstRowIsHeader != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstRowIsHeader", r.firstRowIsHeader, "")
	} else {
		var defaultValue bool = true
		r.firstRowIsHeader = &defaultValue
	}
	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	} else {
		var defaultValue bool = false
		r.force = &defaultValue
	}
	if r.idScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idScheme", r.idScheme, "")
	}
	if r.ignoreEmptyCollection != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignoreEmptyCollection", r.ignoreEmptyCollection, "")
	} else {
		var defaultValue bool = false
		r.ignoreEmptyCollection = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeDataValues != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeDataValues", r.mergeDataValues, "")
	} else {
		var defaultValue bool = false
		r.mergeDataValues = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.notificationLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notificationLevel", r.notificationLevel, "")
	}
	if r.orgUnitIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orgUnitIdScheme", r.orgUnitIdScheme, "")
	}
	if r.preheatCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatCache", r.preheatCache, "")
	}
	if r.programIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "programIdScheme", r.programIdScheme, "")
	}
	if r.programStageIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "programStageIdScheme", r.programStageIdScheme, "")
	}
	if r.reportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reportMode", r.reportMode, "")
	} else {
		var defaultValue string = "FULL"
		r.reportMode = &defaultValue
	}
	if r.requireAttributeOptionCombo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireAttributeOptionCombo", r.requireAttributeOptionCombo, "")
	} else {
		var defaultValue bool = false
		r.requireAttributeOptionCombo = &defaultValue
	}
	if r.requireCategoryOptionCombo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireCategoryOptionCombo", r.requireCategoryOptionCombo, "")
	} else {
		var defaultValue bool = false
		r.requireCategoryOptionCombo = &defaultValue
	}
	if r.sharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sharing", r.sharing, "")
	} else {
		var defaultValue bool = false
		r.sharing = &defaultValue
	}
	if r.skipAudit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipAudit", r.skipAudit, "")
	} else {
		var defaultValue bool = false
		r.skipAudit = &defaultValue
	}
	if r.skipCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipCache", r.skipCache, "")
	} else {
		var defaultValue bool = false
		r.skipCache = &defaultValue
	}
	if r.skipExistingCheck != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipExistingCheck", r.skipExistingCheck, "")
	} else {
		var defaultValue bool = false
		r.skipExistingCheck = &defaultValue
	}
	if r.skipLastUpdated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipLastUpdated", r.skipLastUpdated, "")
	} else {
		var defaultValue bool = false
		r.skipLastUpdated = &defaultValue
	}
	if r.skipNotifications != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipNotifications", r.skipNotifications, "")
	} else {
		var defaultValue bool = false
		r.skipNotifications = &defaultValue
	}
	if r.skipPatternValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipPatternValidation", r.skipPatternValidation, "")
	} else {
		var defaultValue bool = false
		r.skipPatternValidation = &defaultValue
	}
	if r.strictAttributeOptionCombos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strictAttributeOptionCombos", r.strictAttributeOptionCombos, "")
	} else {
		var defaultValue bool = false
		r.strictAttributeOptionCombos = &defaultValue
	}
	if r.strictCategoryOptionCombos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strictCategoryOptionCombos", r.strictCategoryOptionCombos, "")
	} else {
		var defaultValue bool = false
		r.strictCategoryOptionCombos = &defaultValue
	}
	if r.strictDataElements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strictDataElements", r.strictDataElements, "")
	} else {
		var defaultValue bool = false
		r.strictDataElements = &defaultValue
	}
	if r.strictDataSetApproval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strictDataSetApproval", r.strictDataSetApproval, "")
	} else {
		var defaultValue bool = false
		r.strictDataSetApproval = &defaultValue
	}
	if r.strictDataSetInputPeriods != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strictDataSetInputPeriods", r.strictDataSetInputPeriods, "")
	} else {
		var defaultValue bool = false
		r.strictDataSetInputPeriods = &defaultValue
	}
	if r.strictDataSetLocking != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strictDataSetLocking", r.strictDataSetLocking, "")
	} else {
		var defaultValue bool = false
		r.strictDataSetLocking = &defaultValue
	}
	if r.strictOrganisationUnits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strictOrganisationUnits", r.strictOrganisationUnits, "")
	} else {
		var defaultValue bool = false
		r.strictOrganisationUnits = &defaultValue
	}
	if r.strictPeriods != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strictPeriods", r.strictPeriods, "")
	} else {
		var defaultValue bool = false
		r.strictPeriods = &defaultValue
	}
	if r.trackedEntityAttributeIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trackedEntityAttributeIdScheme", r.trackedEntityAttributeIdScheme, "")
	}
	if r.trackedEntityIdScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trackedEntityIdScheme", r.trackedEntityIdScheme, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDatastoreAddEntryRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	key        string
	namespace  string
	body       *string
	encrypt    *bool
}

// [no description yet]
func (r ApiDatastoreAddEntryRequest) Body(body string) ApiDatastoreAddEntryRequest {
	r.body = &body
	return r
}

// [no description yet]
func (r ApiDatastoreAddEntryRequest) Encrypt(encrypt bool) ApiDatastoreAddEntryRequest {
	r.encrypt = &encrypt
	return r
}

func (r ApiDatastoreAddEntryRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DatastoreAddEntryExecute(r)
}

/*
DatastoreAddEntry Method for DatastoreAddEntry

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param key Name of the key.
	@param namespace Name of the namespace.
	@return ApiDatastoreAddEntryRequest
*/
func (a *DataAPIService) DatastoreAddEntry(ctx context.Context, key string, namespace string) ApiDatastoreAddEntryRequest {
	return ApiDatastoreAddEntryRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
		namespace:  namespace,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) DatastoreAddEntryExecute(r ApiDatastoreAddEntryRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DatastoreAddEntry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataStore/{namespace}/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.encrypt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "encrypt", r.encrypt, "")
	} else {
		var defaultValue bool = false
		r.encrypt = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDatastoreDeleteEntryRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	key        string
	namespace  string
}

func (r ApiDatastoreDeleteEntryRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DatastoreDeleteEntryExecute(r)
}

/*
DatastoreDeleteEntry Method for DatastoreDeleteEntry

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param key Name of the key.
	@param namespace Name of the namespace.
	@return ApiDatastoreDeleteEntryRequest
*/
func (a *DataAPIService) DatastoreDeleteEntry(ctx context.Context, key string, namespace string) ApiDatastoreDeleteEntryRequest {
	return ApiDatastoreDeleteEntryRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
		namespace:  namespace,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) DatastoreDeleteEntryExecute(r ApiDatastoreDeleteEntryRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DatastoreDeleteEntry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataStore/{namespace}/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDatastoreDeleteNamespaceRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	namespace  string
}

func (r ApiDatastoreDeleteNamespaceRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DatastoreDeleteNamespaceExecute(r)
}

/*
DatastoreDeleteNamespace Method for DatastoreDeleteNamespace

Delete a namespace including all its entries.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param namespace Name of the namespace.
	@return ApiDatastoreDeleteNamespaceRequest
*/
func (a *DataAPIService) DatastoreDeleteNamespace(ctx context.Context, namespace string) ApiDatastoreDeleteNamespaceRequest {
	return ApiDatastoreDeleteNamespaceRequest{
		ApiService: a,
		ctx:        ctx,
		namespace:  namespace,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) DatastoreDeleteNamespaceExecute(r ApiDatastoreDeleteNamespaceRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DatastoreDeleteNamespace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataStore/{namespace}"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDatastoreGetEntriesRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	fields       *string
	namespace    string
	filter       *string
	headless     *bool
	includeAll   *bool
	order        *string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// [no description yet]
func (r ApiDatastoreGetEntriesRequest) Fields(fields string) ApiDatastoreGetEntriesRequest {
	r.fields = &fields
	return r
}

// [no description yet]
func (r ApiDatastoreGetEntriesRequest) Filter(filter string) ApiDatastoreGetEntriesRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiDatastoreGetEntriesRequest) Headless(headless bool) ApiDatastoreGetEntriesRequest {
	r.headless = &headless
	return r
}

// [no description yet]
func (r ApiDatastoreGetEntriesRequest) IncludeAll(includeAll bool) ApiDatastoreGetEntriesRequest {
	r.includeAll = &includeAll
	return r
}

// [no description yet]
func (r ApiDatastoreGetEntriesRequest) Order(order string) ApiDatastoreGetEntriesRequest {
	r.order = &order
	return r
}

// [no description yet]
func (r ApiDatastoreGetEntriesRequest) Page(page int32) ApiDatastoreGetEntriesRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiDatastoreGetEntriesRequest) PageSize(pageSize int32) ApiDatastoreGetEntriesRequest {
	r.pageSize = &pageSize
	return r
}

// [no description yet]
func (r ApiDatastoreGetEntriesRequest) Paging(paging bool) ApiDatastoreGetEntriesRequest {
	r.paging = &paging
	return r
}

// [no description yet]
func (r ApiDatastoreGetEntriesRequest) RootJunction(rootJunction string) ApiDatastoreGetEntriesRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiDatastoreGetEntriesRequest) Execute() (*EntriesResponse, *http.Response, error) {
	return r.ApiService.DatastoreGetEntriesExecute(r)
}

/*
DatastoreGetEntries Method for DatastoreGetEntries

List all entries in a namespace matching the search criteria.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param namespace Name of the namespace.
	@return ApiDatastoreGetEntriesRequest
*/
func (a *DataAPIService) DatastoreGetEntries(ctx context.Context, namespace string) ApiDatastoreGetEntriesRequest {
	return ApiDatastoreGetEntriesRequest{
		ApiService: a,
		ctx:        ctx,
		namespace:  namespace,
	}
}

// Execute executes the request
//
//	@return EntriesResponse
func (a *DataAPIService) DatastoreGetEntriesExecute(r ApiDatastoreGetEntriesRequest) (*EntriesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EntriesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DatastoreGetEntries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataStore/{namespace}"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fields == nil {
		return localVarReturnValue, nil, reportError("fields is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.includeAll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAll", r.includeAll, "")
	} else {
		var defaultValue bool = false
		r.includeAll = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	} else {
		var defaultValue string = "_"
		r.order = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	} else {
		var defaultValue bool = true
		r.paging = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDatastoreGetEntryRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	key        string
	namespace  string
}

func (r ApiDatastoreGetEntryRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.DatastoreGetEntryExecute(r)
}

/*
DatastoreGetEntry Method for DatastoreGetEntry

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param key Name of the key.
	@param namespace Name of the namespace.
	@return ApiDatastoreGetEntryRequest
*/
func (a *DataAPIService) DatastoreGetEntry(ctx context.Context, key string, namespace string) ApiDatastoreGetEntryRequest {
	return ApiDatastoreGetEntryRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
		namespace:  namespace,
	}
}

// Execute executes the request
//
//	@return string
func (a *DataAPIService) DatastoreGetEntryExecute(r ApiDatastoreGetEntryRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DatastoreGetEntry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataStore/{namespace}/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDatastoreGetEntryMetaDataRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	key        string
	namespace  string
}

func (r ApiDatastoreGetEntryMetaDataRequest) Execute() (*DatastoreEntry, *http.Response, error) {
	return r.ApiService.DatastoreGetEntryMetaDataExecute(r)
}

/*
DatastoreGetEntryMetaData Method for DatastoreGetEntryMetaData

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param key Name of the key.
	@param namespace Name of the namespace.
	@return ApiDatastoreGetEntryMetaDataRequest
*/
func (a *DataAPIService) DatastoreGetEntryMetaData(ctx context.Context, key string, namespace string) ApiDatastoreGetEntryMetaDataRequest {
	return ApiDatastoreGetEntryMetaDataRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
		namespace:  namespace,
	}
}

// Execute executes the request
//
//	@return DatastoreEntry
func (a *DataAPIService) DatastoreGetEntryMetaDataExecute(r ApiDatastoreGetEntryMetaDataRequest) (*DatastoreEntry, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DatastoreEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DatastoreGetEntryMetaData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataStore/{namespace}/{key}/metaData"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDatastoreGetKeysInNamespaceRequest struct {
	ctx         context.Context
	ApiService  *DataAPIService
	namespace   string
	lastUpdated *time.Time
}

// [no description yet]
func (r ApiDatastoreGetKeysInNamespaceRequest) LastUpdated(lastUpdated time.Time) ApiDatastoreGetKeysInNamespaceRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiDatastoreGetKeysInNamespaceRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.DatastoreGetKeysInNamespaceExecute(r)
}

/*
DatastoreGetKeysInNamespace Method for DatastoreGetKeysInNamespace

List all keys in a specific namespace.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param namespace Name of the namespace.
	@return ApiDatastoreGetKeysInNamespaceRequest
*/
func (a *DataAPIService) DatastoreGetKeysInNamespace(ctx context.Context, namespace string) ApiDatastoreGetKeysInNamespaceRequest {
	return ApiDatastoreGetKeysInNamespaceRequest{
		ApiService: a,
		ctx:        ctx,
		namespace:  namespace,
	}
}

// Execute executes the request
//
//	@return []string
func (a *DataAPIService) DatastoreGetKeysInNamespaceExecute(r ApiDatastoreGetKeysInNamespaceRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DatastoreGetKeysInNamespace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataStore/{namespace}/keys"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.lastUpdated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastUpdated", r.lastUpdated, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDatastoreGetNamespacesRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
}

func (r ApiDatastoreGetNamespacesRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.DatastoreGetNamespacesExecute(r)
}

/*
DatastoreGetNamespaces Method for DatastoreGetNamespaces

Lists names of available namespaces.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDatastoreGetNamespacesRequest
*/
func (a *DataAPIService) DatastoreGetNamespaces(ctx context.Context) ApiDatastoreGetNamespacesRequest {
	return ApiDatastoreGetNamespacesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []string
func (a *DataAPIService) DatastoreGetNamespacesExecute(r ApiDatastoreGetNamespacesRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DatastoreGetNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataStore/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDatastorePutEntryRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	key        string
	namespace  string
	body       *string
	encrypt    *bool
}

// [no description yet]
func (r ApiDatastorePutEntryRequest) Body(body string) ApiDatastorePutEntryRequest {
	r.body = &body
	return r
}

// [no description yet]
func (r ApiDatastorePutEntryRequest) Encrypt(encrypt bool) ApiDatastorePutEntryRequest {
	r.encrypt = &encrypt
	return r
}

func (r ApiDatastorePutEntryRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DatastorePutEntryExecute(r)
}

/*
DatastorePutEntry Method for DatastorePutEntry

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param key Name of the key.
	@param namespace Name of the namespace.
	@return ApiDatastorePutEntryRequest
*/
func (a *DataAPIService) DatastorePutEntry(ctx context.Context, key string, namespace string) ApiDatastorePutEntryRequest {
	return ApiDatastorePutEntryRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
		namespace:  namespace,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) DatastorePutEntryExecute(r ApiDatastorePutEntryRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DatastorePutEntry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataStore/{namespace}/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.encrypt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "encrypt", r.encrypt, "")
	} else {
		var defaultValue bool = false
		r.encrypt = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletedObjectGetDeletedObjectsRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	code       *[]string
	deletedAt  *time.Time
	klass      *[]string
	page       *int32
	pageSize   *int32
	paging     *bool
	skipPaging *bool
	total      *int32
	uid        *[]string
}

// [no description yet]
func (r ApiDeletedObjectGetDeletedObjectsRequest) Code(code []string) ApiDeletedObjectGetDeletedObjectsRequest {
	r.code = &code
	return r
}

// [no description yet]
func (r ApiDeletedObjectGetDeletedObjectsRequest) DeletedAt(deletedAt time.Time) ApiDeletedObjectGetDeletedObjectsRequest {
	r.deletedAt = &deletedAt
	return r
}

// [no description yet]
func (r ApiDeletedObjectGetDeletedObjectsRequest) Klass(klass []string) ApiDeletedObjectGetDeletedObjectsRequest {
	r.klass = &klass
	return r
}

// [no description yet]
func (r ApiDeletedObjectGetDeletedObjectsRequest) Page(page int32) ApiDeletedObjectGetDeletedObjectsRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiDeletedObjectGetDeletedObjectsRequest) PageSize(pageSize int32) ApiDeletedObjectGetDeletedObjectsRequest {
	r.pageSize = &pageSize
	return r
}

// [no description yet]
func (r ApiDeletedObjectGetDeletedObjectsRequest) Paging(paging bool) ApiDeletedObjectGetDeletedObjectsRequest {
	r.paging = &paging
	return r
}

// [no description yet]
func (r ApiDeletedObjectGetDeletedObjectsRequest) SkipPaging(skipPaging bool) ApiDeletedObjectGetDeletedObjectsRequest {
	r.skipPaging = &skipPaging
	return r
}

// [no description yet]
func (r ApiDeletedObjectGetDeletedObjectsRequest) Total(total int32) ApiDeletedObjectGetDeletedObjectsRequest {
	r.total = &total
	return r
}

// [no description yet]
func (r ApiDeletedObjectGetDeletedObjectsRequest) Uid(uid []string) ApiDeletedObjectGetDeletedObjectsRequest {
	r.uid = &uid
	return r
}

func (r ApiDeletedObjectGetDeletedObjectsRequest) Execute() ([]DeletedObject, *http.Response, error) {
	return r.ApiService.DeletedObjectGetDeletedObjectsExecute(r)
}

/*
DeletedObjectGetDeletedObjects Method for DeletedObjectGetDeletedObjects

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeletedObjectGetDeletedObjectsRequest
*/
func (a *DataAPIService) DeletedObjectGetDeletedObjects(ctx context.Context) ApiDeletedObjectGetDeletedObjectsRequest {
	return ApiDeletedObjectGetDeletedObjectsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []DeletedObject
func (a *DataAPIService) DeletedObjectGetDeletedObjectsExecute(r ApiDeletedObjectGetDeletedObjectsRequest) ([]DeletedObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []DeletedObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.DeletedObjectGetDeletedObjects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deletedObjects/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	if r.deletedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deletedAt", r.deletedAt, "")
	}
	if r.klass != nil {
		t := *r.klass
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "klass", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "klass", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.skipPaging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipPaging", r.skipPaging, "")
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue int32 = 0
		r.total = &defaultValue
	}
	if r.uid != nil {
		t := *r.uid
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "uid", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "uid", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGeoJsonImportDeleteImportRequest struct {
	ctx         context.Context
	ApiService  *DataAPIService
	attributeId *string
}

// [no description yet]
func (r ApiGeoJsonImportDeleteImportRequest) AttributeId(attributeId string) ApiGeoJsonImportDeleteImportRequest {
	r.attributeId = &attributeId
	return r
}

func (r ApiGeoJsonImportDeleteImportRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.GeoJsonImportDeleteImportExecute(r)
}

/*
GeoJsonImportDeleteImport Method for GeoJsonImportDeleteImport

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGeoJsonImportDeleteImportRequest
*/
func (a *DataAPIService) GeoJsonImportDeleteImport(ctx context.Context) ApiGeoJsonImportDeleteImportRequest {
	return ApiGeoJsonImportDeleteImportRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) GeoJsonImportDeleteImportExecute(r ApiGeoJsonImportDeleteImportRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.GeoJsonImportDeleteImport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organisationUnits/geometry"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.attributeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attributeId", r.attributeId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGeoJsonImportDeleteImportSingleRequest struct {
	ctx         context.Context
	ApiService  *DataAPIService
	uid         string
	attributeId *string
	dryRun      *bool
}

// [no description yet]
func (r ApiGeoJsonImportDeleteImportSingleRequest) AttributeId(attributeId string) ApiGeoJsonImportDeleteImportSingleRequest {
	r.attributeId = &attributeId
	return r
}

// [no description yet]
func (r ApiGeoJsonImportDeleteImportSingleRequest) DryRun(dryRun bool) ApiGeoJsonImportDeleteImportSingleRequest {
	r.dryRun = &dryRun
	return r
}

func (r ApiGeoJsonImportDeleteImportSingleRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.GeoJsonImportDeleteImportSingleExecute(r)
}

/*
GeoJsonImportDeleteImportSingle Method for GeoJsonImportDeleteImportSingle

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiGeoJsonImportDeleteImportSingleRequest
*/
func (a *DataAPIService) GeoJsonImportDeleteImportSingle(ctx context.Context, uid string) ApiGeoJsonImportDeleteImportSingleRequest {
	return ApiGeoJsonImportDeleteImportSingleRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) GeoJsonImportDeleteImportSingleExecute(r ApiGeoJsonImportDeleteImportSingleRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.GeoJsonImportDeleteImportSingle")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organisationUnits/{uid}/geometry"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.attributeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attributeId", r.attributeId, "")
	}
	if r.dryRun != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dryRun", r.dryRun, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGeoJsonImportPostImportRequest struct {
	ctx             context.Context
	ApiService      *DataAPIService
	async           *bool
	attributeId     *string
	dryRun          *bool
	geoJsonId       *bool
	geoJsonProperty *string
	orgUnitProperty *string
}

// [no description yet]
func (r ApiGeoJsonImportPostImportRequest) Async(async bool) ApiGeoJsonImportPostImportRequest {
	r.async = &async
	return r
}

// [no description yet]
func (r ApiGeoJsonImportPostImportRequest) AttributeId(attributeId string) ApiGeoJsonImportPostImportRequest {
	r.attributeId = &attributeId
	return r
}

// [no description yet]
func (r ApiGeoJsonImportPostImportRequest) DryRun(dryRun bool) ApiGeoJsonImportPostImportRequest {
	r.dryRun = &dryRun
	return r
}

// [no description yet]
func (r ApiGeoJsonImportPostImportRequest) GeoJsonId(geoJsonId bool) ApiGeoJsonImportPostImportRequest {
	r.geoJsonId = &geoJsonId
	return r
}

// [no description yet]
func (r ApiGeoJsonImportPostImportRequest) GeoJsonProperty(geoJsonProperty string) ApiGeoJsonImportPostImportRequest {
	r.geoJsonProperty = &geoJsonProperty
	return r
}

// [no description yet]
func (r ApiGeoJsonImportPostImportRequest) OrgUnitProperty(orgUnitProperty string) ApiGeoJsonImportPostImportRequest {
	r.orgUnitProperty = &orgUnitProperty
	return r
}

func (r ApiGeoJsonImportPostImportRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.GeoJsonImportPostImportExecute(r)
}

/*
GeoJsonImportPostImport Method for GeoJsonImportPostImport

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGeoJsonImportPostImportRequest
*/
func (a *DataAPIService) GeoJsonImportPostImport(ctx context.Context) ApiGeoJsonImportPostImportRequest {
	return ApiGeoJsonImportPostImportRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) GeoJsonImportPostImportExecute(r ApiGeoJsonImportPostImportRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.GeoJsonImportPostImport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organisationUnits/geometry"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "")
	} else {
		var defaultValue bool = false
		r.async = &defaultValue
	}
	if r.attributeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attributeId", r.attributeId, "")
	}
	if r.dryRun != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dryRun", r.dryRun, "")
	}
	if r.geoJsonId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "geoJsonId", r.geoJsonId, "")
	} else {
		var defaultValue bool = true
		r.geoJsonId = &defaultValue
	}
	if r.geoJsonProperty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "geoJsonProperty", r.geoJsonProperty, "")
	}
	if r.orgUnitProperty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orgUnitProperty", r.orgUnitProperty, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGeoJsonImportPostImportSingleRequest struct {
	ctx         context.Context
	ApiService  *DataAPIService
	uid         string
	body        *string
	attributeId *string
	dryRun      *bool
}

// [no description yet]
func (r ApiGeoJsonImportPostImportSingleRequest) Body(body string) ApiGeoJsonImportPostImportSingleRequest {
	r.body = &body
	return r
}

// [no description yet]
func (r ApiGeoJsonImportPostImportSingleRequest) AttributeId(attributeId string) ApiGeoJsonImportPostImportSingleRequest {
	r.attributeId = &attributeId
	return r
}

// [no description yet]
func (r ApiGeoJsonImportPostImportSingleRequest) DryRun(dryRun bool) ApiGeoJsonImportPostImportSingleRequest {
	r.dryRun = &dryRun
	return r
}

func (r ApiGeoJsonImportPostImportSingleRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.GeoJsonImportPostImportSingleExecute(r)
}

/*
GeoJsonImportPostImportSingle Method for GeoJsonImportPostImportSingle

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiGeoJsonImportPostImportSingleRequest
*/
func (a *DataAPIService) GeoJsonImportPostImportSingle(ctx context.Context, uid string) ApiGeoJsonImportPostImportSingleRequest {
	return ApiGeoJsonImportPostImportSingleRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) GeoJsonImportPostImportSingleExecute(r ApiGeoJsonImportPostImportSingleRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.GeoJsonImportPostImportSingle")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organisationUnits/{uid}/geometry"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.attributeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attributeId", r.attributeId, "")
	}
	if r.dryRun != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dryRun", r.dryRun, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/geo+json", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/geo+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLockExceptionAddLockExceptionRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	ds         *string
	ou         *string
	pe         *string
}

// [no description yet]
func (r ApiLockExceptionAddLockExceptionRequest) Ds(ds string) ApiLockExceptionAddLockExceptionRequest {
	r.ds = &ds
	return r
}

// [no description yet]
func (r ApiLockExceptionAddLockExceptionRequest) Ou(ou string) ApiLockExceptionAddLockExceptionRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiLockExceptionAddLockExceptionRequest) Pe(pe string) ApiLockExceptionAddLockExceptionRequest {
	r.pe = &pe
	return r
}

func (r ApiLockExceptionAddLockExceptionRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.LockExceptionAddLockExceptionExecute(r)
}

/*
LockExceptionAddLockException Method for LockExceptionAddLockException

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLockExceptionAddLockExceptionRequest
*/
func (a *DataAPIService) LockExceptionAddLockException(ctx context.Context) ApiLockExceptionAddLockExceptionRequest {
	return ApiLockExceptionAddLockExceptionRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) LockExceptionAddLockExceptionExecute(r ApiLockExceptionAddLockExceptionRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.LockExceptionAddLockException")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lockExceptions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ds == nil {
		return localVarReturnValue, nil, reportError("ds is required and must be specified")
	}
	if r.ou == nil {
		return localVarReturnValue, nil, reportError("ou is required and must be specified")
	}
	if r.pe == nil {
		return localVarReturnValue, nil, reportError("pe is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ds", r.ds, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pe", r.pe, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLockExceptionDeleteLockExceptionRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	ds         *string
	pe         *string
	ou         *string
}

// [no description yet]
func (r ApiLockExceptionDeleteLockExceptionRequest) Ds(ds string) ApiLockExceptionDeleteLockExceptionRequest {
	r.ds = &ds
	return r
}

// [no description yet]
func (r ApiLockExceptionDeleteLockExceptionRequest) Pe(pe string) ApiLockExceptionDeleteLockExceptionRequest {
	r.pe = &pe
	return r
}

// [no description yet]
func (r ApiLockExceptionDeleteLockExceptionRequest) Ou(ou string) ApiLockExceptionDeleteLockExceptionRequest {
	r.ou = &ou
	return r
}

func (r ApiLockExceptionDeleteLockExceptionRequest) Execute() (*http.Response, error) {
	return r.ApiService.LockExceptionDeleteLockExceptionExecute(r)
}

/*
LockExceptionDeleteLockException Method for LockExceptionDeleteLockException

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLockExceptionDeleteLockExceptionRequest
*/
func (a *DataAPIService) LockExceptionDeleteLockException(ctx context.Context) ApiLockExceptionDeleteLockExceptionRequest {
	return ApiLockExceptionDeleteLockExceptionRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) LockExceptionDeleteLockExceptionExecute(r ApiLockExceptionDeleteLockExceptionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.LockExceptionDeleteLockException")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lockExceptions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ds == nil {
		return nil, reportError("ds is required and must be specified")
	}
	if r.pe == nil {
		return nil, reportError("pe is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ds", r.ds, "")
	if r.ou != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "pe", r.pe, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLockExceptionGetLockExceptionCombinationsRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
}

func (r ApiLockExceptionGetLockExceptionCombinationsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.LockExceptionGetLockExceptionCombinationsExecute(r)
}

/*
LockExceptionGetLockExceptionCombinations Method for LockExceptionGetLockExceptionCombinations

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLockExceptionGetLockExceptionCombinationsRequest
*/
func (a *DataAPIService) LockExceptionGetLockExceptionCombinations(ctx context.Context) ApiLockExceptionGetLockExceptionCombinationsRequest {
	return ApiLockExceptionGetLockExceptionCombinationsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *DataAPIService) LockExceptionGetLockExceptionCombinationsExecute(r ApiLockExceptionGetLockExceptionCombinationsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.LockExceptionGetLockExceptionCombinations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lockExceptions/combinations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLockExceptionGetLockExceptionsRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	key        *string
}

// [no description yet]
func (r ApiLockExceptionGetLockExceptionsRequest) Key(key string) ApiLockExceptionGetLockExceptionsRequest {
	r.key = &key
	return r
}

func (r ApiLockExceptionGetLockExceptionsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.LockExceptionGetLockExceptionsExecute(r)
}

/*
LockExceptionGetLockExceptions Method for LockExceptionGetLockExceptions

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLockExceptionGetLockExceptionsRequest
*/
func (a *DataAPIService) LockExceptionGetLockExceptions(ctx context.Context) ApiLockExceptionGetLockExceptionsRequest {
	return ApiLockExceptionGetLockExceptionsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *DataAPIService) LockExceptionGetLockExceptionsExecute(r ApiLockExceptionGetLockExceptionsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.LockExceptionGetLockExceptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lockExceptions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLockExceptionGetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiLockExceptionGetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiLockExceptionGetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiLockExceptionGetObjectGistAsCsvRequest) Auto(auto string) ApiLockExceptionGetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiLockExceptionGetObjectGistAsCsvRequest) Describe(describe bool) ApiLockExceptionGetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiLockExceptionGetObjectGistAsCsvRequest) Fields(fields string) ApiLockExceptionGetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiLockExceptionGetObjectGistAsCsvRequest) Filter(filter string) ApiLockExceptionGetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiLockExceptionGetObjectGistAsCsvRequest) Headless(headless bool) ApiLockExceptionGetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiLockExceptionGetObjectGistAsCsvRequest) Inverse(inverse bool) ApiLockExceptionGetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiLockExceptionGetObjectGistAsCsvRequest) Locale(locale string) ApiLockExceptionGetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiLockExceptionGetObjectGistAsCsvRequest) Order(order string) ApiLockExceptionGetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiLockExceptionGetObjectGistAsCsvRequest) Page(page int32) ApiLockExceptionGetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiLockExceptionGetObjectGistAsCsvRequest) PageListName(pageListName string) ApiLockExceptionGetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiLockExceptionGetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiLockExceptionGetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiLockExceptionGetObjectGistAsCsvRequest) References(references bool) ApiLockExceptionGetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiLockExceptionGetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiLockExceptionGetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiLockExceptionGetObjectGistAsCsvRequest) Total(total bool) ApiLockExceptionGetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiLockExceptionGetObjectGistAsCsvRequest) Translate(translate bool) ApiLockExceptionGetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiLockExceptionGetObjectGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.LockExceptionGetObjectGistAsCsvExecute(r)
}

/*
LockExceptionGetObjectGistAsCsv Method for LockExceptionGetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiLockExceptionGetObjectGistAsCsvRequest
*/
func (a *DataAPIService) LockExceptionGetObjectGistAsCsv(ctx context.Context, uid string) ApiLockExceptionGetObjectGistAsCsvRequest {
	return ApiLockExceptionGetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *DataAPIService) LockExceptionGetObjectGistAsCsvExecute(r ApiLockExceptionGetObjectGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.LockExceptionGetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lockExceptions/{uid}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest) Auto(auto string) ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest) Describe(describe bool) ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest) Fields(fields string) ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest) Filter(filter string) ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest) Headless(headless bool) ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest) Inverse(inverse bool) ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest) Locale(locale string) ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest) Order(order string) ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest) Page(page int32) ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest) PageListName(pageListName string) ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest) References(references bool) ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest) Total(total bool) ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest) Translate(translate bool) ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.LockExceptionGetObjectGistgetObjectGistAsCsvExecute(r)
}

/*
LockExceptionGetObjectGistgetObjectGistAsCsv Method for LockExceptionGetObjectGistgetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest
*/
func (a *DataAPIService) LockExceptionGetObjectGistgetObjectGistAsCsv(ctx context.Context, uid string) ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest {
	return ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *DataAPIService) LockExceptionGetObjectGistgetObjectGistAsCsvExecute(r ApiLockExceptionGetObjectGistgetObjectGistAsCsvRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.LockExceptionGetObjectGistgetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lockExceptions/{uid}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLockExceptionGetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiLockExceptionGetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiLockExceptionGetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiLockExceptionGetObjectListGistAsCsvRequest) Auto(auto string) ApiLockExceptionGetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiLockExceptionGetObjectListGistAsCsvRequest) Describe(describe bool) ApiLockExceptionGetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiLockExceptionGetObjectListGistAsCsvRequest) Fields(fields string) ApiLockExceptionGetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiLockExceptionGetObjectListGistAsCsvRequest) Filter(filter string) ApiLockExceptionGetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiLockExceptionGetObjectListGistAsCsvRequest) Headless(headless bool) ApiLockExceptionGetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiLockExceptionGetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiLockExceptionGetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiLockExceptionGetObjectListGistAsCsvRequest) Locale(locale string) ApiLockExceptionGetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiLockExceptionGetObjectListGistAsCsvRequest) Order(order string) ApiLockExceptionGetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiLockExceptionGetObjectListGistAsCsvRequest) Page(page int32) ApiLockExceptionGetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiLockExceptionGetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiLockExceptionGetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiLockExceptionGetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiLockExceptionGetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiLockExceptionGetObjectListGistAsCsvRequest) References(references bool) ApiLockExceptionGetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiLockExceptionGetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiLockExceptionGetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiLockExceptionGetObjectListGistAsCsvRequest) Total(total bool) ApiLockExceptionGetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiLockExceptionGetObjectListGistAsCsvRequest) Translate(translate bool) ApiLockExceptionGetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiLockExceptionGetObjectListGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.LockExceptionGetObjectListGistAsCsvExecute(r)
}

/*
LockExceptionGetObjectListGistAsCsv Method for LockExceptionGetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLockExceptionGetObjectListGistAsCsvRequest
*/
func (a *DataAPIService) LockExceptionGetObjectListGistAsCsv(ctx context.Context) ApiLockExceptionGetObjectListGistAsCsvRequest {
	return ApiLockExceptionGetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *DataAPIService) LockExceptionGetObjectListGistAsCsvExecute(r ApiLockExceptionGetObjectListGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.LockExceptionGetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lockExceptions/gist.csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest) Auto(auto string) ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest) Describe(describe bool) ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest) Fields(fields string) ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest) Filter(filter string) ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest) Headless(headless bool) ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest) Locale(locale string) ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest) Order(order string) ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest) Page(page int32) ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest) References(references bool) ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest) Total(total bool) ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest) Translate(translate bool) ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest) Execute() (*LockExceptionGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.LockExceptionGetObjectListGistgetObjectListGistAsCsvExecute(r)
}

/*
LockExceptionGetObjectListGistgetObjectListGistAsCsv Method for LockExceptionGetObjectListGistgetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest
*/
func (a *DataAPIService) LockExceptionGetObjectListGistgetObjectListGistAsCsv(ctx context.Context) ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest {
	return ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return LockExceptionGetObjectListGistGetObjectListGistAsCsv200Response
func (a *DataAPIService) LockExceptionGetObjectListGistgetObjectListGistAsCsvExecute(r ApiLockExceptionGetObjectListGistgetObjectListGistAsCsvRequest) (*LockExceptionGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LockExceptionGetObjectListGistGetObjectListGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.LockExceptionGetObjectListGistgetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lockExceptions/gist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLockExceptionGetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiLockExceptionGetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiLockExceptionGetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiLockExceptionGetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiLockExceptionGetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiLockExceptionGetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiLockExceptionGetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiLockExceptionGetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiLockExceptionGetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiLockExceptionGetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiLockExceptionGetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiLockExceptionGetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiLockExceptionGetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiLockExceptionGetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiLockExceptionGetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiLockExceptionGetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiLockExceptionGetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiLockExceptionGetObjectPropertyGistAsCsvRequest) Order(order string) ApiLockExceptionGetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiLockExceptionGetObjectPropertyGistAsCsvRequest) Page(page int32) ApiLockExceptionGetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiLockExceptionGetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiLockExceptionGetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiLockExceptionGetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiLockExceptionGetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiLockExceptionGetObjectPropertyGistAsCsvRequest) References(references bool) ApiLockExceptionGetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiLockExceptionGetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiLockExceptionGetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiLockExceptionGetObjectPropertyGistAsCsvRequest) Total(total bool) ApiLockExceptionGetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiLockExceptionGetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiLockExceptionGetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiLockExceptionGetObjectPropertyGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.LockExceptionGetObjectPropertyGistAsCsvExecute(r)
}

/*
LockExceptionGetObjectPropertyGistAsCsv Method for LockExceptionGetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiLockExceptionGetObjectPropertyGistAsCsvRequest
*/
func (a *DataAPIService) LockExceptionGetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiLockExceptionGetObjectPropertyGistAsCsvRequest {
	return ApiLockExceptionGetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *DataAPIService) LockExceptionGetObjectPropertyGistAsCsvExecute(r ApiLockExceptionGetObjectPropertyGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.LockExceptionGetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lockExceptions/{uid}/{property}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Order(order string) ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Page(page int32) ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) References(references bool) ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Total(total bool) ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Execute() (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.LockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r)
}

/*
LockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsv Method for LockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest
*/
func (a *DataAPIService) LockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	return ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
func (a *DataAPIService) LockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r ApiLockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.LockExceptionGetObjectPropertyGistgetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lockExceptions/{uid}/{property}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMinMaxValueRemoveMinMaxValueRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	co         *string
	de         *string
	ou         *string
}

// [no description yet]
func (r ApiMinMaxValueRemoveMinMaxValueRequest) Co(co string) ApiMinMaxValueRemoveMinMaxValueRequest {
	r.co = &co
	return r
}

// [no description yet]
func (r ApiMinMaxValueRemoveMinMaxValueRequest) De(de string) ApiMinMaxValueRemoveMinMaxValueRequest {
	r.de = &de
	return r
}

// [no description yet]
func (r ApiMinMaxValueRemoveMinMaxValueRequest) Ou(ou string) ApiMinMaxValueRemoveMinMaxValueRequest {
	r.ou = &ou
	return r
}

func (r ApiMinMaxValueRemoveMinMaxValueRequest) Execute() (*http.Response, error) {
	return r.ApiService.MinMaxValueRemoveMinMaxValueExecute(r)
}

/*
MinMaxValueRemoveMinMaxValue Method for MinMaxValueRemoveMinMaxValue

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMinMaxValueRemoveMinMaxValueRequest
*/
func (a *DataAPIService) MinMaxValueRemoveMinMaxValue(ctx context.Context) ApiMinMaxValueRemoveMinMaxValueRequest {
	return ApiMinMaxValueRemoveMinMaxValueRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) MinMaxValueRemoveMinMaxValueExecute(r ApiMinMaxValueRemoveMinMaxValueRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.MinMaxValueRemoveMinMaxValue")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataEntry/minMaxValues"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.co != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "co", r.co, "")
	}
	if r.de != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "de", r.de, "")
	}
	if r.ou != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMinMaxValueSaveOrUpdateMinMaxValueRequest struct {
	ctx            context.Context
	ApiService     *DataAPIService
	minMaxValueDto *MinMaxValueDto
}

// [no description yet]
func (r ApiMinMaxValueSaveOrUpdateMinMaxValueRequest) MinMaxValueDto(minMaxValueDto MinMaxValueDto) ApiMinMaxValueSaveOrUpdateMinMaxValueRequest {
	r.minMaxValueDto = &minMaxValueDto
	return r
}

func (r ApiMinMaxValueSaveOrUpdateMinMaxValueRequest) Execute() (*http.Response, error) {
	return r.ApiService.MinMaxValueSaveOrUpdateMinMaxValueExecute(r)
}

/*
MinMaxValueSaveOrUpdateMinMaxValue Method for MinMaxValueSaveOrUpdateMinMaxValue

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMinMaxValueSaveOrUpdateMinMaxValueRequest
*/
func (a *DataAPIService) MinMaxValueSaveOrUpdateMinMaxValue(ctx context.Context) ApiMinMaxValueSaveOrUpdateMinMaxValueRequest {
	return ApiMinMaxValueSaveOrUpdateMinMaxValueRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) MinMaxValueSaveOrUpdateMinMaxValueExecute(r ApiMinMaxValueSaveOrUpdateMinMaxValueRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.MinMaxValueSaveOrUpdateMinMaxValue")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dataEntry/minMaxValues"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.minMaxValueDto == nil {
		return nil, reportError("minMaxValueDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.minMaxValueDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest struct {
	ctx           context.Context
	ApiService    *DataAPIService
	algorithm     *string
	dataEndDate   *time.Time
	dataStartDate *time.Time
	de            *[]string
	ds            *[]string
	endDate       *time.Time
	maxResults    *int32
	orderBy       *string
	ou            *[]string
	startDate     *time.Time
	threshold     *float64
}

// [no description yet]
func (r ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest) Algorithm(algorithm string) ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest {
	r.algorithm = &algorithm
	return r
}

// [no description yet]
func (r ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest) DataEndDate(dataEndDate time.Time) ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest {
	r.dataEndDate = &dataEndDate
	return r
}

// [no description yet]
func (r ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest) DataStartDate(dataStartDate time.Time) ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest {
	r.dataStartDate = &dataStartDate
	return r
}

// [no description yet]
func (r ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest) De(de []string) ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest {
	r.de = &de
	return r
}

// [no description yet]
func (r ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest) Ds(ds []string) ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest {
	r.ds = &ds
	return r
}

// [no description yet]
func (r ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest) EndDate(endDate time.Time) ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest {
	r.endDate = &endDate
	return r
}

// [no description yet]
func (r ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest) MaxResults(maxResults int32) ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest {
	r.maxResults = &maxResults
	return r
}

// [no description yet]
func (r ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest) OrderBy(orderBy string) ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest {
	r.orderBy = &orderBy
	return r
}

// [no description yet]
func (r ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest) Ou(ou []string) ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest) StartDate(startDate time.Time) ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest {
	r.startDate = &startDate
	return r
}

// [no description yet]
func (r ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest) Threshold(threshold float64) ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest {
	r.threshold = &threshold
	return r
}

func (r ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest) Execute() (*OutlierDetectionResponse, *http.Response, error) {
	return r.ApiService.OutlierDetectionGetOutliersJsongetOutliersCsvExecute(r)
}

/*
OutlierDetectionGetOutliersJsongetOutliersCsv Method for OutlierDetectionGetOutliersJsongetOutliersCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest
*/
func (a *DataAPIService) OutlierDetectionGetOutliersJsongetOutliersCsv(ctx context.Context) ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest {
	return ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return OutlierDetectionResponse
func (a *DataAPIService) OutlierDetectionGetOutliersJsongetOutliersCsvExecute(r ApiOutlierDetectionGetOutliersJsongetOutliersCsvRequest) (*OutlierDetectionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OutlierDetectionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.OutlierDetectionGetOutliersJsongetOutliersCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/outlierDetection"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.algorithm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "algorithm", r.algorithm, "")
	} else {
		var defaultValue string = "Z_SCORE"
		r.algorithm = &defaultValue
	}
	if r.dataEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataEndDate", r.dataEndDate, "")
	}
	if r.dataStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataStartDate", r.dataStartDate, "")
	}
	if r.de != nil {
		t := *r.de
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "de", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "de", t, "multi")
		}
	}
	if r.ds != nil {
		t := *r.ds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ds", t, "multi")
		}
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "")
	}
	if r.ou != nil {
		t := *r.ou
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ou", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ou", t, "multi")
		}
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.threshold != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "threshold", r.threshold, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSynchronizationExecuteRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
}

func (r ApiSynchronizationExecuteRequest) Execute() (*ImportConflicts, *http.Response, error) {
	return r.ApiService.SynchronizationExecuteExecute(r)
}

/*
SynchronizationExecute Method for SynchronizationExecute

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSynchronizationExecuteRequest
*/
func (a *DataAPIService) SynchronizationExecute(ctx context.Context) ApiSynchronizationExecuteRequest {
	return ApiSynchronizationExecuteRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ImportConflicts
func (a *DataAPIService) SynchronizationExecuteExecute(r ApiSynchronizationExecuteRequest) (*ImportConflicts, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ImportConflicts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.SynchronizationExecute")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/synchronization/dataPush"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSynchronizationGetMetadataRepoIndexRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
}

func (r ApiSynchronizationGetMetadataRepoIndexRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.SynchronizationGetMetadataRepoIndexExecute(r)
}

/*
SynchronizationGetMetadataRepoIndex Method for SynchronizationGetMetadataRepoIndex

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSynchronizationGetMetadataRepoIndexRequest
*/
func (a *DataAPIService) SynchronizationGetMetadataRepoIndex(ctx context.Context) ApiSynchronizationGetMetadataRepoIndexRequest {
	return ApiSynchronizationGetMetadataRepoIndexRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *DataAPIService) SynchronizationGetMetadataRepoIndexExecute(r ApiSynchronizationGetMetadataRepoIndexRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.SynchronizationGetMetadataRepoIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/synchronization/metadataRepo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSynchronizationImportMetaDataRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	body       *string
}

// [no description yet]
func (r ApiSynchronizationImportMetaDataRequest) Body(body string) ApiSynchronizationImportMetaDataRequest {
	r.body = &body
	return r
}

func (r ApiSynchronizationImportMetaDataRequest) Execute() (*ImportReport, *http.Response, error) {
	return r.ApiService.SynchronizationImportMetaDataExecute(r)
}

/*
SynchronizationImportMetaData Method for SynchronizationImportMetaData

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSynchronizationImportMetaDataRequest
*/
func (a *DataAPIService) SynchronizationImportMetaData(ctx context.Context) ApiSynchronizationImportMetaDataRequest {
	return ApiSynchronizationImportMetaDataRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ImportReport
func (a *DataAPIService) SynchronizationImportMetaDataExecute(r ApiSynchronizationImportMetaDataRequest) (*ImportReport, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ImportReport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.SynchronizationImportMetaData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/synchronization/metadataPull"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSynchronizationRemoteServerAvailableRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
}

func (r ApiSynchronizationRemoteServerAvailableRequest) Execute() (*AvailabilityStatus, *http.Response, error) {
	return r.ApiService.SynchronizationRemoteServerAvailableExecute(r)
}

/*
SynchronizationRemoteServerAvailable Method for SynchronizationRemoteServerAvailable

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSynchronizationRemoteServerAvailableRequest
*/
func (a *DataAPIService) SynchronizationRemoteServerAvailable(ctx context.Context) ApiSynchronizationRemoteServerAvailableRequest {
	return ApiSynchronizationRemoteServerAvailableRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AvailabilityStatus
func (a *DataAPIService) SynchronizationRemoteServerAvailableExecute(r ApiSynchronizationRemoteServerAvailableRequest) (*AvailabilityStatus, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AvailabilityStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.SynchronizationRemoteServerAvailable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/synchronization/availability"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplateAddCollectionItemRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiValidationNotificationTemplateAddCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationNotificationTemplateAddCollectionItemExecute(r)
}

/*
ValidationNotificationTemplateAddCollectionItem Method for ValidationNotificationTemplateAddCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationNotificationTemplateAddCollectionItemRequest
*/
func (a *DataAPIService) ValidationNotificationTemplateAddCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiValidationNotificationTemplateAddCollectionItemRequest {
	return ApiValidationNotificationTemplateAddCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationNotificationTemplateAddCollectionItemExecute(r ApiValidationNotificationTemplateAddCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplateAddCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplateAddCollectionItemsJsonaddCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *DataAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiValidationNotificationTemplateAddCollectionItemsJsonaddCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiValidationNotificationTemplateAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiValidationNotificationTemplateAddCollectionItemsJsonaddCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationNotificationTemplateAddCollectionItemsJsonaddCollectionItemsXmlExecute(r)
}

/*
ValidationNotificationTemplateAddCollectionItemsJsonaddCollectionItemsXml Method for ValidationNotificationTemplateAddCollectionItemsJsonaddCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationNotificationTemplateAddCollectionItemsJsonaddCollectionItemsXmlRequest
*/
func (a *DataAPIService) ValidationNotificationTemplateAddCollectionItemsJsonaddCollectionItemsXml(ctx context.Context, property string, uid string) ApiValidationNotificationTemplateAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	return ApiValidationNotificationTemplateAddCollectionItemsJsonaddCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationNotificationTemplateAddCollectionItemsJsonaddCollectionItemsXmlExecute(r ApiValidationNotificationTemplateAddCollectionItemsJsonaddCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplateAddCollectionItemsJsonaddCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplateBulkSharingRequest struct {
	ctx                context.Context
	ApiService         *DataAPIService
	atomic             *bool
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	bulkJsonPatch      *BulkJsonPatch
}

// [no description yet]
func (r ApiValidationNotificationTemplateBulkSharingRequest) Atomic(atomic bool) ApiValidationNotificationTemplateBulkSharingRequest {
	r.atomic = &atomic
	return r
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiValidationNotificationTemplateBulkSharingRequest) AtomicMode(atomicMode string) ApiValidationNotificationTemplateBulkSharingRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiValidationNotificationTemplateBulkSharingRequest) FlushMode(flushMode string) ApiValidationNotificationTemplateBulkSharingRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiValidationNotificationTemplateBulkSharingRequest) Identifier(identifier string) ApiValidationNotificationTemplateBulkSharingRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiValidationNotificationTemplateBulkSharingRequest) ImportMode(importMode string) ApiValidationNotificationTemplateBulkSharingRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiValidationNotificationTemplateBulkSharingRequest) ImportReportMode(importReportMode string) ApiValidationNotificationTemplateBulkSharingRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiValidationNotificationTemplateBulkSharingRequest) ImportStrategy(importStrategy string) ApiValidationNotificationTemplateBulkSharingRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiValidationNotificationTemplateBulkSharingRequest) MergeMode(mergeMode string) ApiValidationNotificationTemplateBulkSharingRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplateBulkSharingRequest) MetadataSyncImport(metadataSyncImport bool) ApiValidationNotificationTemplateBulkSharingRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiValidationNotificationTemplateBulkSharingRequest) Page(page int32) ApiValidationNotificationTemplateBulkSharingRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiValidationNotificationTemplateBulkSharingRequest) PageSize(pageSize int32) ApiValidationNotificationTemplateBulkSharingRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiValidationNotificationTemplateBulkSharingRequest) Paging(paging bool) ApiValidationNotificationTemplateBulkSharingRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiValidationNotificationTemplateBulkSharingRequest) PreheatMode(preheatMode string) ApiValidationNotificationTemplateBulkSharingRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiValidationNotificationTemplateBulkSharingRequest) RootJunction(rootJunction string) ApiValidationNotificationTemplateBulkSharingRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiValidationNotificationTemplateBulkSharingRequest) SkipSharing(skipSharing bool) ApiValidationNotificationTemplateBulkSharingRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplateBulkSharingRequest) SkipTranslation(skipTranslation bool) ApiValidationNotificationTemplateBulkSharingRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiValidationNotificationTemplateBulkSharingRequest) SkipValidation(skipValidation bool) ApiValidationNotificationTemplateBulkSharingRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiValidationNotificationTemplateBulkSharingRequest) UserOverrideMode(userOverrideMode string) ApiValidationNotificationTemplateBulkSharingRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplateBulkSharingRequest) BulkJsonPatch(bulkJsonPatch BulkJsonPatch) ApiValidationNotificationTemplateBulkSharingRequest {
	r.bulkJsonPatch = &bulkJsonPatch
	return r
}

func (r ApiValidationNotificationTemplateBulkSharingRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationNotificationTemplateBulkSharingExecute(r)
}

/*
ValidationNotificationTemplateBulkSharing Method for ValidationNotificationTemplateBulkSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidationNotificationTemplateBulkSharingRequest
*/
func (a *DataAPIService) ValidationNotificationTemplateBulkSharing(ctx context.Context) ApiValidationNotificationTemplateBulkSharingRequest {
	return ApiValidationNotificationTemplateBulkSharingRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationNotificationTemplateBulkSharingExecute(r ApiValidationNotificationTemplateBulkSharingRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplateBulkSharing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/sharing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomic", r.atomic, "")
	} else {
		var defaultValue bool = false
		r.atomic = &defaultValue
	}
	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkJsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplateDeleteCollectionItemRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiValidationNotificationTemplateDeleteCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationNotificationTemplateDeleteCollectionItemExecute(r)
}

/*
ValidationNotificationTemplateDeleteCollectionItem Method for ValidationNotificationTemplateDeleteCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationNotificationTemplateDeleteCollectionItemRequest
*/
func (a *DataAPIService) ValidationNotificationTemplateDeleteCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiValidationNotificationTemplateDeleteCollectionItemRequest {
	return ApiValidationNotificationTemplateDeleteCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationNotificationTemplateDeleteCollectionItemExecute(r ApiValidationNotificationTemplateDeleteCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplateDeleteCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplateDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *DataAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiValidationNotificationTemplateDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiValidationNotificationTemplateDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiValidationNotificationTemplateDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationNotificationTemplateDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r)
}

/*
ValidationNotificationTemplateDeleteCollectionItemsJsondeleteCollectionItemsXml Method for ValidationNotificationTemplateDeleteCollectionItemsJsondeleteCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationNotificationTemplateDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest
*/
func (a *DataAPIService) ValidationNotificationTemplateDeleteCollectionItemsJsondeleteCollectionItemsXml(ctx context.Context, property string, uid string) ApiValidationNotificationTemplateDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	return ApiValidationNotificationTemplateDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationNotificationTemplateDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r ApiValidationNotificationTemplateDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplateDeleteCollectionItemsJsondeleteCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplateDeleteObjectRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
}

func (r ApiValidationNotificationTemplateDeleteObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationNotificationTemplateDeleteObjectExecute(r)
}

/*
ValidationNotificationTemplateDeleteObject Method for ValidationNotificationTemplateDeleteObject

Deletes the ValidationNotificationTemplate provided by ID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationNotificationTemplateDeleteObjectRequest
*/
func (a *DataAPIService) ValidationNotificationTemplateDeleteObject(ctx context.Context, uid string) ApiValidationNotificationTemplateDeleteObjectRequest {
	return ApiValidationNotificationTemplateDeleteObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationNotificationTemplateDeleteObjectExecute(r ApiValidationNotificationTemplateDeleteObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplateDeleteObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplateGetObjectRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	uid          string
	fields       *[]string
	filter       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiValidationNotificationTemplateGetObjectRequest) Fields(fields []string) ApiValidationNotificationTemplateGetObjectRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiValidationNotificationTemplateGetObjectRequest) Filter(filter []string) ApiValidationNotificationTemplateGetObjectRequest {
	r.filter = &filter
	return r
}

// Defines which page number to return.
func (r ApiValidationNotificationTemplateGetObjectRequest) Page(page int32) ApiValidationNotificationTemplateGetObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiValidationNotificationTemplateGetObjectRequest) PageSize(pageSize int32) ApiValidationNotificationTemplateGetObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiValidationNotificationTemplateGetObjectRequest) Paging(paging bool) ApiValidationNotificationTemplateGetObjectRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiValidationNotificationTemplateGetObjectRequest) RootJunction(rootJunction string) ApiValidationNotificationTemplateGetObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiValidationNotificationTemplateGetObjectRequest) Execute() (*ValidationNotificationTemplate, *http.Response, error) {
	return r.ApiService.ValidationNotificationTemplateGetObjectExecute(r)
}

/*
ValidationNotificationTemplateGetObject Method for ValidationNotificationTemplateGetObject

View a ValidationNotificationTemplate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationNotificationTemplateGetObjectRequest
*/
func (a *DataAPIService) ValidationNotificationTemplateGetObject(ctx context.Context, uid string) ApiValidationNotificationTemplateGetObjectRequest {
	return ApiValidationNotificationTemplateGetObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return ValidationNotificationTemplate
func (a *DataAPIService) ValidationNotificationTemplateGetObjectExecute(r ApiValidationNotificationTemplateGetObjectRequest) (*ValidationNotificationTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ValidationNotificationTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplateGetObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplateGetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiValidationNotificationTemplateGetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiValidationNotificationTemplateGetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiValidationNotificationTemplateGetObjectGistAsCsvRequest) Auto(auto string) ApiValidationNotificationTemplateGetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiValidationNotificationTemplateGetObjectGistAsCsvRequest) Describe(describe bool) ApiValidationNotificationTemplateGetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiValidationNotificationTemplateGetObjectGistAsCsvRequest) Fields(fields string) ApiValidationNotificationTemplateGetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiValidationNotificationTemplateGetObjectGistAsCsvRequest) Filter(filter string) ApiValidationNotificationTemplateGetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiValidationNotificationTemplateGetObjectGistAsCsvRequest) Headless(headless bool) ApiValidationNotificationTemplateGetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiValidationNotificationTemplateGetObjectGistAsCsvRequest) Inverse(inverse bool) ApiValidationNotificationTemplateGetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiValidationNotificationTemplateGetObjectGistAsCsvRequest) Locale(locale string) ApiValidationNotificationTemplateGetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiValidationNotificationTemplateGetObjectGistAsCsvRequest) Order(order string) ApiValidationNotificationTemplateGetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiValidationNotificationTemplateGetObjectGistAsCsvRequest) Page(page int32) ApiValidationNotificationTemplateGetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplateGetObjectGistAsCsvRequest) PageListName(pageListName string) ApiValidationNotificationTemplateGetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiValidationNotificationTemplateGetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiValidationNotificationTemplateGetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiValidationNotificationTemplateGetObjectGistAsCsvRequest) References(references bool) ApiValidationNotificationTemplateGetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiValidationNotificationTemplateGetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiValidationNotificationTemplateGetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiValidationNotificationTemplateGetObjectGistAsCsvRequest) Total(total bool) ApiValidationNotificationTemplateGetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiValidationNotificationTemplateGetObjectGistAsCsvRequest) Translate(translate bool) ApiValidationNotificationTemplateGetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiValidationNotificationTemplateGetObjectGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ValidationNotificationTemplateGetObjectGistAsCsvExecute(r)
}

/*
ValidationNotificationTemplateGetObjectGistAsCsv Method for ValidationNotificationTemplateGetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationNotificationTemplateGetObjectGistAsCsvRequest
*/
func (a *DataAPIService) ValidationNotificationTemplateGetObjectGistAsCsv(ctx context.Context, uid string) ApiValidationNotificationTemplateGetObjectGistAsCsvRequest {
	return ApiValidationNotificationTemplateGetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *DataAPIService) ValidationNotificationTemplateGetObjectGistAsCsvExecute(r ApiValidationNotificationTemplateGetObjectGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplateGetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/{uid}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest) Auto(auto string) ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest) Describe(describe bool) ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest) Fields(fields string) ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest) Filter(filter string) ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest) Headless(headless bool) ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest) Inverse(inverse bool) ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest) Locale(locale string) ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest) Order(order string) ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest) Page(page int32) ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest) PageListName(pageListName string) ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest) References(references bool) ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest) Total(total bool) ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest) Translate(translate bool) ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvExecute(r)
}

/*
ValidationNotificationTemplateGetObjectGistgetObjectGistAsCsv Method for ValidationNotificationTemplateGetObjectGistgetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest
*/
func (a *DataAPIService) ValidationNotificationTemplateGetObjectGistgetObjectGistAsCsv(ctx context.Context, uid string) ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest {
	return ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *DataAPIService) ValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvExecute(r ApiValidationNotificationTemplateGetObjectGistgetObjectGistAsCsvRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplateGetObjectGistgetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/{uid}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplateGetObjectListRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	fields       *[]string
	filter       *[]string
	orders       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// &#x60;&lt;field-name&gt;[,&lt;field-name&gt;...]&#x60;
func (r ApiValidationNotificationTemplateGetObjectListRequest) Fields(fields []string) ApiValidationNotificationTemplateGetObjectListRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiValidationNotificationTemplateGetObjectListRequest) Filter(filter []string) ApiValidationNotificationTemplateGetObjectListRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplateGetObjectListRequest) Orders(orders []string) ApiValidationNotificationTemplateGetObjectListRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiValidationNotificationTemplateGetObjectListRequest) Page(page int32) ApiValidationNotificationTemplateGetObjectListRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiValidationNotificationTemplateGetObjectListRequest) PageSize(pageSize int32) ApiValidationNotificationTemplateGetObjectListRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiValidationNotificationTemplateGetObjectListRequest) Paging(paging bool) ApiValidationNotificationTemplateGetObjectListRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiValidationNotificationTemplateGetObjectListRequest) RootJunction(rootJunction string) ApiValidationNotificationTemplateGetObjectListRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiValidationNotificationTemplateGetObjectListRequest) Execute() (*ValidationNotificationTemplateGetObjectList200Response, *http.Response, error) {
	return r.ApiService.ValidationNotificationTemplateGetObjectListExecute(r)
}

/*
ValidationNotificationTemplateGetObjectList Method for ValidationNotificationTemplateGetObjectList

List all ValidationNotificationTemplates

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidationNotificationTemplateGetObjectListRequest
*/
func (a *DataAPIService) ValidationNotificationTemplateGetObjectList(ctx context.Context) ApiValidationNotificationTemplateGetObjectListRequest {
	return ApiValidationNotificationTemplateGetObjectListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ValidationNotificationTemplateGetObjectList200Response
func (a *DataAPIService) ValidationNotificationTemplateGetObjectListExecute(r ApiValidationNotificationTemplateGetObjectListRequest) (*ValidationNotificationTemplateGetObjectList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ValidationNotificationTemplateGetObjectList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplateGetObjectList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplateGetObjectListCsvRequest struct {
	ctx            context.Context
	ApiService     *DataAPIService
	arraySeparator *string
	fields         *[]string
	filter         *[]string
	orders         *[]string
	page           *int32
	pageSize       *int32
	paging         *bool
	rootJunction   *string
	separator      *string
	skipHeader     *bool
}

// [no description yet]
func (r ApiValidationNotificationTemplateGetObjectListCsvRequest) ArraySeparator(arraySeparator string) ApiValidationNotificationTemplateGetObjectListCsvRequest {
	r.arraySeparator = &arraySeparator
	return r
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiValidationNotificationTemplateGetObjectListCsvRequest) Fields(fields []string) ApiValidationNotificationTemplateGetObjectListCsvRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiValidationNotificationTemplateGetObjectListCsvRequest) Filter(filter []string) ApiValidationNotificationTemplateGetObjectListCsvRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplateGetObjectListCsvRequest) Orders(orders []string) ApiValidationNotificationTemplateGetObjectListCsvRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiValidationNotificationTemplateGetObjectListCsvRequest) Page(page int32) ApiValidationNotificationTemplateGetObjectListCsvRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiValidationNotificationTemplateGetObjectListCsvRequest) PageSize(pageSize int32) ApiValidationNotificationTemplateGetObjectListCsvRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiValidationNotificationTemplateGetObjectListCsvRequest) Paging(paging bool) ApiValidationNotificationTemplateGetObjectListCsvRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiValidationNotificationTemplateGetObjectListCsvRequest) RootJunction(rootJunction string) ApiValidationNotificationTemplateGetObjectListCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplateGetObjectListCsvRequest) Separator(separator string) ApiValidationNotificationTemplateGetObjectListCsvRequest {
	r.separator = &separator
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplateGetObjectListCsvRequest) SkipHeader(skipHeader bool) ApiValidationNotificationTemplateGetObjectListCsvRequest {
	r.skipHeader = &skipHeader
	return r
}

func (r ApiValidationNotificationTemplateGetObjectListCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ValidationNotificationTemplateGetObjectListCsvExecute(r)
}

/*
ValidationNotificationTemplateGetObjectListCsv Method for ValidationNotificationTemplateGetObjectListCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidationNotificationTemplateGetObjectListCsvRequest
*/
func (a *DataAPIService) ValidationNotificationTemplateGetObjectListCsv(ctx context.Context) ApiValidationNotificationTemplateGetObjectListCsvRequest {
	return ApiValidationNotificationTemplateGetObjectListCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *DataAPIService) ValidationNotificationTemplateGetObjectListCsvExecute(r ApiValidationNotificationTemplateGetObjectListCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplateGetObjectListCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/#getObjectListCsv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.arraySeparator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arraySeparator", r.arraySeparator, "")
	} else {
		var defaultValue string = ";"
		r.arraySeparator = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.separator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "separator", r.separator, "")
	} else {
		var defaultValue string = ","
		r.separator = &defaultValue
	}
	if r.skipHeader != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipHeader", r.skipHeader, "")
	} else {
		var defaultValue bool = false
		r.skipHeader = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/text", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest) Auto(auto string) ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest) Describe(describe bool) ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest) Fields(fields string) ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest) Filter(filter string) ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest) Headless(headless bool) ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest) Locale(locale string) ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest) Order(order string) ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest) Page(page int32) ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest) References(references bool) ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest) Total(total bool) ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest) Translate(translate bool) ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ValidationNotificationTemplateGetObjectListGistAsCsvExecute(r)
}

/*
ValidationNotificationTemplateGetObjectListGistAsCsv Method for ValidationNotificationTemplateGetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest
*/
func (a *DataAPIService) ValidationNotificationTemplateGetObjectListGistAsCsv(ctx context.Context) ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest {
	return ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *DataAPIService) ValidationNotificationTemplateGetObjectListGistAsCsvExecute(r ApiValidationNotificationTemplateGetObjectListGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplateGetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/gist.csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest) Auto(auto string) ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest) Describe(describe bool) ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest) Fields(fields string) ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest) Filter(filter string) ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest) Headless(headless bool) ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest) Locale(locale string) ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest) Order(order string) ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest) Page(page int32) ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest) References(references bool) ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest) Total(total bool) ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest) Translate(translate bool) ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest) Execute() (*ValidationNotificationTemplateGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.ValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvExecute(r)
}

/*
ValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsv Method for ValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest
*/
func (a *DataAPIService) ValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsv(ctx context.Context) ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest {
	return ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ValidationNotificationTemplateGetObjectListGistGetObjectListGistAsCsv200Response
func (a *DataAPIService) ValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvExecute(r ApiValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsvRequest) (*ValidationNotificationTemplateGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ValidationNotificationTemplateGetObjectListGistGetObjectListGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplateGetObjectListGistgetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/gist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplateGetObjectPropertyRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	property     string
	uid          string
	fields       *[]string
	locale       *string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
	translate    *bool
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiValidationNotificationTemplateGetObjectPropertyRequest) Fields(fields []string) ApiValidationNotificationTemplateGetObjectPropertyRequest {
	r.fields = &fields
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplateGetObjectPropertyRequest) Locale(locale string) ApiValidationNotificationTemplateGetObjectPropertyRequest {
	r.locale = &locale
	return r
}

// Defines which page number to return.
func (r ApiValidationNotificationTemplateGetObjectPropertyRequest) Page(page int32) ApiValidationNotificationTemplateGetObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiValidationNotificationTemplateGetObjectPropertyRequest) PageSize(pageSize int32) ApiValidationNotificationTemplateGetObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiValidationNotificationTemplateGetObjectPropertyRequest) Paging(paging bool) ApiValidationNotificationTemplateGetObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiValidationNotificationTemplateGetObjectPropertyRequest) RootJunction(rootJunction string) ApiValidationNotificationTemplateGetObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplateGetObjectPropertyRequest) Translate(translate bool) ApiValidationNotificationTemplateGetObjectPropertyRequest {
	r.translate = &translate
	return r
}

func (r ApiValidationNotificationTemplateGetObjectPropertyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ValidationNotificationTemplateGetObjectPropertyExecute(r)
}

/*
ValidationNotificationTemplateGetObjectProperty Method for ValidationNotificationTemplateGetObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationNotificationTemplateGetObjectPropertyRequest
*/
func (a *DataAPIService) ValidationNotificationTemplateGetObjectProperty(ctx context.Context, property string, uid string) ApiValidationNotificationTemplateGetObjectPropertyRequest {
	return ApiValidationNotificationTemplateGetObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *DataAPIService) ValidationNotificationTemplateGetObjectPropertyExecute(r ApiValidationNotificationTemplateGetObjectPropertyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplateGetObjectProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest) Order(order string) ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest) Page(page int32) ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest) References(references bool) ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest) Total(total bool) ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ValidationNotificationTemplateGetObjectPropertyGistAsCsvExecute(r)
}

/*
ValidationNotificationTemplateGetObjectPropertyGistAsCsv Method for ValidationNotificationTemplateGetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest
*/
func (a *DataAPIService) ValidationNotificationTemplateGetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest {
	return ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *DataAPIService) ValidationNotificationTemplateGetObjectPropertyGistAsCsvExecute(r ApiValidationNotificationTemplateGetObjectPropertyGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplateGetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/{uid}/{property}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Order(order string) ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Page(page int32) ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) References(references bool) ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Total(total bool) ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Execute() (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.ValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r)
}

/*
ValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsv Method for ValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest
*/
func (a *DataAPIService) ValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	return ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
func (a *DataAPIService) ValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r ApiValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplateGetObjectPropertyGistgetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/{uid}/{property}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplatePatchObjectRequest struct {
	ctx                context.Context
	ApiService         *DataAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	jsonPatch          *JsonPatch
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiValidationNotificationTemplatePatchObjectRequest) AtomicMode(atomicMode string) ApiValidationNotificationTemplatePatchObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiValidationNotificationTemplatePatchObjectRequest) FlushMode(flushMode string) ApiValidationNotificationTemplatePatchObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiValidationNotificationTemplatePatchObjectRequest) Identifier(identifier string) ApiValidationNotificationTemplatePatchObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiValidationNotificationTemplatePatchObjectRequest) ImportMode(importMode string) ApiValidationNotificationTemplatePatchObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiValidationNotificationTemplatePatchObjectRequest) ImportReportMode(importReportMode string) ApiValidationNotificationTemplatePatchObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiValidationNotificationTemplatePatchObjectRequest) ImportStrategy(importStrategy string) ApiValidationNotificationTemplatePatchObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiValidationNotificationTemplatePatchObjectRequest) MergeMode(mergeMode string) ApiValidationNotificationTemplatePatchObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplatePatchObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiValidationNotificationTemplatePatchObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiValidationNotificationTemplatePatchObjectRequest) Page(page int32) ApiValidationNotificationTemplatePatchObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiValidationNotificationTemplatePatchObjectRequest) PageSize(pageSize int32) ApiValidationNotificationTemplatePatchObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiValidationNotificationTemplatePatchObjectRequest) Paging(paging bool) ApiValidationNotificationTemplatePatchObjectRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiValidationNotificationTemplatePatchObjectRequest) PreheatMode(preheatMode string) ApiValidationNotificationTemplatePatchObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiValidationNotificationTemplatePatchObjectRequest) RootJunction(rootJunction string) ApiValidationNotificationTemplatePatchObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiValidationNotificationTemplatePatchObjectRequest) SkipSharing(skipSharing bool) ApiValidationNotificationTemplatePatchObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplatePatchObjectRequest) SkipTranslation(skipTranslation bool) ApiValidationNotificationTemplatePatchObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiValidationNotificationTemplatePatchObjectRequest) SkipValidation(skipValidation bool) ApiValidationNotificationTemplatePatchObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiValidationNotificationTemplatePatchObjectRequest) UserOverrideMode(userOverrideMode string) ApiValidationNotificationTemplatePatchObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplatePatchObjectRequest) JsonPatch(jsonPatch JsonPatch) ApiValidationNotificationTemplatePatchObjectRequest {
	r.jsonPatch = &jsonPatch
	return r
}

func (r ApiValidationNotificationTemplatePatchObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationNotificationTemplatePatchObjectExecute(r)
}

/*
ValidationNotificationTemplatePatchObject Method for ValidationNotificationTemplatePatchObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationNotificationTemplatePatchObjectRequest
*/
func (a *DataAPIService) ValidationNotificationTemplatePatchObject(ctx context.Context, uid string) ApiValidationNotificationTemplatePatchObjectRequest {
	return ApiValidationNotificationTemplatePatchObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationNotificationTemplatePatchObjectExecute(r ApiValidationNotificationTemplatePatchObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplatePatchObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest struct {
	ctx                            context.Context
	ApiService                     *DataAPIService
	atomicMode                     *string
	flushMode                      *string
	identifier                     *string
	importMode                     *string
	importReportMode               *string
	importStrategy                 *string
	mergeMode                      *string
	metadataSyncImport             *bool
	preheatMode                    *string
	skipSharing                    *bool
	skipTranslation                *bool
	skipValidation                 *bool
	userOverrideMode               *string
	validationNotificationTemplate *ValidationNotificationTemplate
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest) AtomicMode(atomicMode string) ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest) FlushMode(flushMode string) ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest) Identifier(identifier string) ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest) ImportMode(importMode string) ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest) ImportReportMode(importReportMode string) ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest) ImportStrategy(importStrategy string) ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest) MergeMode(mergeMode string) ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest) PreheatMode(preheatMode string) ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest) SkipSharing(skipSharing bool) ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest) SkipValidation(skipValidation bool) ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest) ValidationNotificationTemplate(validationNotificationTemplate ValidationNotificationTemplate) ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest {
	r.validationNotificationTemplate = &validationNotificationTemplate
	return r
}

func (r ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationNotificationTemplatePostJsonObjectpostXmlObjectExecute(r)
}

/*
ValidationNotificationTemplatePostJsonObjectpostXmlObject Method for ValidationNotificationTemplatePostJsonObjectpostXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest
*/
func (a *DataAPIService) ValidationNotificationTemplatePostJsonObjectpostXmlObject(ctx context.Context) ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest {
	return ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationNotificationTemplatePostJsonObjectpostXmlObjectExecute(r ApiValidationNotificationTemplatePostJsonObjectpostXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplatePostJsonObjectpostXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.validationNotificationTemplate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest struct {
	ctx                            context.Context
	ApiService                     *DataAPIService
	uid                            string
	atomicMode                     *string
	flushMode                      *string
	identifier                     *string
	importMode                     *string
	importReportMode               *string
	importStrategy                 *string
	mergeMode                      *string
	metadataSyncImport             *bool
	preheatMode                    *string
	skipSharing                    *bool
	skipTranslation                *bool
	skipValidation                 *bool
	userOverrideMode               *string
	validationNotificationTemplate *ValidationNotificationTemplate
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest) AtomicMode(atomicMode string) ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest) FlushMode(flushMode string) ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest) Identifier(identifier string) ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest) ImportMode(importMode string) ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest) ImportReportMode(importReportMode string) ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest) ImportStrategy(importStrategy string) ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest) MergeMode(mergeMode string) ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest) PreheatMode(preheatMode string) ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest) SkipSharing(skipSharing bool) ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest) SkipValidation(skipValidation bool) ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest) ValidationNotificationTemplate(validationNotificationTemplate ValidationNotificationTemplate) ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest {
	r.validationNotificationTemplate = &validationNotificationTemplate
	return r
}

func (r ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationNotificationTemplatePutJsonObjectputXmlObjectExecute(r)
}

/*
ValidationNotificationTemplatePutJsonObjectputXmlObject Method for ValidationNotificationTemplatePutJsonObjectputXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest
*/
func (a *DataAPIService) ValidationNotificationTemplatePutJsonObjectputXmlObject(ctx context.Context, uid string) ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest {
	return ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationNotificationTemplatePutJsonObjectputXmlObjectExecute(r ApiValidationNotificationTemplatePutJsonObjectputXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplatePutJsonObjectputXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.validationNotificationTemplate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplateRemoveAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
}

func (r ApiValidationNotificationTemplateRemoveAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationNotificationTemplateRemoveAsFavoriteExecute(r)
}

/*
ValidationNotificationTemplateRemoveAsFavorite Method for ValidationNotificationTemplateRemoveAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationNotificationTemplateRemoveAsFavoriteRequest
*/
func (a *DataAPIService) ValidationNotificationTemplateRemoveAsFavorite(ctx context.Context, uid string) ApiValidationNotificationTemplateRemoveAsFavoriteRequest {
	return ApiValidationNotificationTemplateRemoveAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationNotificationTemplateRemoveAsFavoriteExecute(r ApiValidationNotificationTemplateRemoveAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplateRemoveAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplateReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *DataAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiValidationNotificationTemplateReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiValidationNotificationTemplateReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiValidationNotificationTemplateReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationNotificationTemplateReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r)
}

/*
ValidationNotificationTemplateReplaceCollectionItemsJsonreplaceCollectionItemsXml Method for ValidationNotificationTemplateReplaceCollectionItemsJsonreplaceCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationNotificationTemplateReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest
*/
func (a *DataAPIService) ValidationNotificationTemplateReplaceCollectionItemsJsonreplaceCollectionItemsXml(ctx context.Context, property string, uid string) ApiValidationNotificationTemplateReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	return ApiValidationNotificationTemplateReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationNotificationTemplateReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r ApiValidationNotificationTemplateReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplateReplaceCollectionItemsJsonreplaceCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplateReplaceTranslationsRequest struct {
	ctx                                             context.Context
	ApiService                                      *DataAPIService
	uid                                             string
	aggregateDataExchangeReplaceTranslationsRequest *AggregateDataExchangeReplaceTranslationsRequest
}

// [no description yet]
func (r ApiValidationNotificationTemplateReplaceTranslationsRequest) AggregateDataExchangeReplaceTranslationsRequest(aggregateDataExchangeReplaceTranslationsRequest AggregateDataExchangeReplaceTranslationsRequest) ApiValidationNotificationTemplateReplaceTranslationsRequest {
	r.aggregateDataExchangeReplaceTranslationsRequest = &aggregateDataExchangeReplaceTranslationsRequest
	return r
}

func (r ApiValidationNotificationTemplateReplaceTranslationsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ValidationNotificationTemplateReplaceTranslationsExecute(r)
}

/*
ValidationNotificationTemplateReplaceTranslations Method for ValidationNotificationTemplateReplaceTranslations

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationNotificationTemplateReplaceTranslationsRequest
*/
func (a *DataAPIService) ValidationNotificationTemplateReplaceTranslations(ctx context.Context, uid string) ApiValidationNotificationTemplateReplaceTranslationsRequest {
	return ApiValidationNotificationTemplateReplaceTranslationsRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *DataAPIService) ValidationNotificationTemplateReplaceTranslationsExecute(r ApiValidationNotificationTemplateReplaceTranslationsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplateReplaceTranslations")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/{uid}/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateDataExchangeReplaceTranslationsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplateSetAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
}

func (r ApiValidationNotificationTemplateSetAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationNotificationTemplateSetAsFavoriteExecute(r)
}

/*
ValidationNotificationTemplateSetAsFavorite Method for ValidationNotificationTemplateSetAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationNotificationTemplateSetAsFavoriteRequest
*/
func (a *DataAPIService) ValidationNotificationTemplateSetAsFavorite(ctx context.Context, uid string) ApiValidationNotificationTemplateSetAsFavoriteRequest {
	return ApiValidationNotificationTemplateSetAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationNotificationTemplateSetAsFavoriteExecute(r ApiValidationNotificationTemplateSetAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplateSetAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplateSetSharingRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
	sharing    *Sharing
}

// [no description yet]
func (r ApiValidationNotificationTemplateSetSharingRequest) Sharing(sharing Sharing) ApiValidationNotificationTemplateSetSharingRequest {
	r.sharing = &sharing
	return r
}

func (r ApiValidationNotificationTemplateSetSharingRequest) Execute() (*http.Response, error) {
	return r.ApiService.ValidationNotificationTemplateSetSharingExecute(r)
}

/*
ValidationNotificationTemplateSetSharing Method for ValidationNotificationTemplateSetSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationNotificationTemplateSetSharingRequest
*/
func (a *DataAPIService) ValidationNotificationTemplateSetSharing(ctx context.Context, uid string) ApiValidationNotificationTemplateSetSharingRequest {
	return ApiValidationNotificationTemplateSetSharingRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *DataAPIService) ValidationNotificationTemplateSetSharingExecute(r ApiValidationNotificationTemplateSetSharingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplateSetSharing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/{uid}/sharing"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharing
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplateSubscribeRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
}

func (r ApiValidationNotificationTemplateSubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationNotificationTemplateSubscribeExecute(r)
}

/*
ValidationNotificationTemplateSubscribe Method for ValidationNotificationTemplateSubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationNotificationTemplateSubscribeRequest
*/
func (a *DataAPIService) ValidationNotificationTemplateSubscribe(ctx context.Context, uid string) ApiValidationNotificationTemplateSubscribeRequest {
	return ApiValidationNotificationTemplateSubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationNotificationTemplateSubscribeExecute(r ApiValidationNotificationTemplateSubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplateSubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplateUnsubscribeRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
}

func (r ApiValidationNotificationTemplateUnsubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationNotificationTemplateUnsubscribeExecute(r)
}

/*
ValidationNotificationTemplateUnsubscribe Method for ValidationNotificationTemplateUnsubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationNotificationTemplateUnsubscribeRequest
*/
func (a *DataAPIService) ValidationNotificationTemplateUnsubscribe(ctx context.Context, uid string) ApiValidationNotificationTemplateUnsubscribeRequest {
	return ApiValidationNotificationTemplateUnsubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationNotificationTemplateUnsubscribeExecute(r ApiValidationNotificationTemplateUnsubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplateUnsubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationNotificationTemplateUpdateObjectPropertyRequest struct {
	ctx                            context.Context
	ApiService                     *DataAPIService
	property                       string
	uid                            string
	atomicMode                     *string
	flushMode                      *string
	identifier                     *string
	importMode                     *string
	importReportMode               *string
	importStrategy                 *string
	mergeMode                      *string
	metadataSyncImport             *bool
	page                           *int32
	pageSize                       *int32
	paging                         *bool
	preheatMode                    *string
	rootJunction                   *string
	skipSharing                    *bool
	skipTranslation                *bool
	skipValidation                 *bool
	userOverrideMode               *string
	validationNotificationTemplate *ValidationNotificationTemplate
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiValidationNotificationTemplateUpdateObjectPropertyRequest) AtomicMode(atomicMode string) ApiValidationNotificationTemplateUpdateObjectPropertyRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiValidationNotificationTemplateUpdateObjectPropertyRequest) FlushMode(flushMode string) ApiValidationNotificationTemplateUpdateObjectPropertyRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiValidationNotificationTemplateUpdateObjectPropertyRequest) Identifier(identifier string) ApiValidationNotificationTemplateUpdateObjectPropertyRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiValidationNotificationTemplateUpdateObjectPropertyRequest) ImportMode(importMode string) ApiValidationNotificationTemplateUpdateObjectPropertyRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiValidationNotificationTemplateUpdateObjectPropertyRequest) ImportReportMode(importReportMode string) ApiValidationNotificationTemplateUpdateObjectPropertyRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiValidationNotificationTemplateUpdateObjectPropertyRequest) ImportStrategy(importStrategy string) ApiValidationNotificationTemplateUpdateObjectPropertyRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiValidationNotificationTemplateUpdateObjectPropertyRequest) MergeMode(mergeMode string) ApiValidationNotificationTemplateUpdateObjectPropertyRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplateUpdateObjectPropertyRequest) MetadataSyncImport(metadataSyncImport bool) ApiValidationNotificationTemplateUpdateObjectPropertyRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiValidationNotificationTemplateUpdateObjectPropertyRequest) Page(page int32) ApiValidationNotificationTemplateUpdateObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiValidationNotificationTemplateUpdateObjectPropertyRequest) PageSize(pageSize int32) ApiValidationNotificationTemplateUpdateObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiValidationNotificationTemplateUpdateObjectPropertyRequest) Paging(paging bool) ApiValidationNotificationTemplateUpdateObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiValidationNotificationTemplateUpdateObjectPropertyRequest) PreheatMode(preheatMode string) ApiValidationNotificationTemplateUpdateObjectPropertyRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiValidationNotificationTemplateUpdateObjectPropertyRequest) RootJunction(rootJunction string) ApiValidationNotificationTemplateUpdateObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiValidationNotificationTemplateUpdateObjectPropertyRequest) SkipSharing(skipSharing bool) ApiValidationNotificationTemplateUpdateObjectPropertyRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplateUpdateObjectPropertyRequest) SkipTranslation(skipTranslation bool) ApiValidationNotificationTemplateUpdateObjectPropertyRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiValidationNotificationTemplateUpdateObjectPropertyRequest) SkipValidation(skipValidation bool) ApiValidationNotificationTemplateUpdateObjectPropertyRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiValidationNotificationTemplateUpdateObjectPropertyRequest) UserOverrideMode(userOverrideMode string) ApiValidationNotificationTemplateUpdateObjectPropertyRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiValidationNotificationTemplateUpdateObjectPropertyRequest) ValidationNotificationTemplate(validationNotificationTemplate ValidationNotificationTemplate) ApiValidationNotificationTemplateUpdateObjectPropertyRequest {
	r.validationNotificationTemplate = &validationNotificationTemplate
	return r
}

func (r ApiValidationNotificationTemplateUpdateObjectPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.ValidationNotificationTemplateUpdateObjectPropertyExecute(r)
}

/*
ValidationNotificationTemplateUpdateObjectProperty Method for ValidationNotificationTemplateUpdateObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationNotificationTemplateUpdateObjectPropertyRequest
*/
func (a *DataAPIService) ValidationNotificationTemplateUpdateObjectProperty(ctx context.Context, property string, uid string) ApiValidationNotificationTemplateUpdateObjectPropertyRequest {
	return ApiValidationNotificationTemplateUpdateObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
func (a *DataAPIService) ValidationNotificationTemplateUpdateObjectPropertyExecute(r ApiValidationNotificationTemplateUpdateObjectPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationNotificationTemplateUpdateObjectProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationNotificationTemplates/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.validationNotificationTemplate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiValidationResultDeleteRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	id         int32
}

func (r ApiValidationResultDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ValidationResultDeleteExecute(r)
}

/*
ValidationResultDelete Method for ValidationResultDelete

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id [no description yet]
	@return ApiValidationResultDeleteRequest
*/
func (a *DataAPIService) ValidationResultDelete(ctx context.Context, id int32) ApiValidationResultDeleteRequest {
	return ApiValidationResultDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *DataAPIService) ValidationResultDeleteExecute(r ApiValidationResultDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationResultDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationResults/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiValidationResultDeleteValidationResultsRequest struct {
	ctx              context.Context
	ApiService       *DataAPIService
	created          *string
	notificationSent *bool
	ou               *[]string
	pe               *string
	unconstrained    *bool
	vr               *[]string
}

// [no description yet]
func (r ApiValidationResultDeleteValidationResultsRequest) Created(created string) ApiValidationResultDeleteValidationResultsRequest {
	r.created = &created
	return r
}

// [no description yet]
func (r ApiValidationResultDeleteValidationResultsRequest) NotificationSent(notificationSent bool) ApiValidationResultDeleteValidationResultsRequest {
	r.notificationSent = &notificationSent
	return r
}

// [no description yet]
func (r ApiValidationResultDeleteValidationResultsRequest) Ou(ou []string) ApiValidationResultDeleteValidationResultsRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiValidationResultDeleteValidationResultsRequest) Pe(pe string) ApiValidationResultDeleteValidationResultsRequest {
	r.pe = &pe
	return r
}

// [no description yet]
func (r ApiValidationResultDeleteValidationResultsRequest) Unconstrained(unconstrained bool) ApiValidationResultDeleteValidationResultsRequest {
	r.unconstrained = &unconstrained
	return r
}

// [no description yet]
func (r ApiValidationResultDeleteValidationResultsRequest) Vr(vr []string) ApiValidationResultDeleteValidationResultsRequest {
	r.vr = &vr
	return r
}

func (r ApiValidationResultDeleteValidationResultsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ValidationResultDeleteValidationResultsExecute(r)
}

/*
ValidationResultDeleteValidationResults Method for ValidationResultDeleteValidationResults

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidationResultDeleteValidationResultsRequest
*/
func (a *DataAPIService) ValidationResultDeleteValidationResults(ctx context.Context) ApiValidationResultDeleteValidationResultsRequest {
	return ApiValidationResultDeleteValidationResultsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) ValidationResultDeleteValidationResultsExecute(r ApiValidationResultDeleteValidationResultsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationResultDeleteValidationResults")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationResults/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created", r.created, "")
	}
	if r.notificationSent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notificationSent", r.notificationSent, "")
	}
	if r.ou != nil {
		t := *r.ou
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ou", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ou", t, "multi")
		}
	}
	if r.pe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pe", r.pe, "")
	}
	if r.unconstrained != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unconstrained", r.unconstrained, "")
	}
	if r.vr != nil {
		t := *r.vr
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vr", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vr", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiValidationResultGetObjectRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	id         int32
}

func (r ApiValidationResultGetObjectRequest) Execute() (*ValidationResult, *http.Response, error) {
	return r.ApiService.ValidationResultGetObjectExecute(r)
}

/*
ValidationResultGetObject Method for ValidationResultGetObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id [no description yet]
	@return ApiValidationResultGetObjectRequest
*/
func (a *DataAPIService) ValidationResultGetObject(ctx context.Context, id int32) ApiValidationResultGetObjectRequest {
	return ApiValidationResultGetObjectRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ValidationResult
func (a *DataAPIService) ValidationResultGetObjectExecute(r ApiValidationResultGetObjectRequest) (*ValidationResult, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ValidationResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationResultGetObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationResults/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationResultGetObjectListRequest struct {
	ctx         context.Context
	ApiService  *DataAPIService
	createdDate *time.Time
	ou          *[]string
	page        *int32
	pageSize    *int32
	paging      *bool
	pe          *[]string
	skipPaging  *bool
	total       *int64
	vr          *[]string
}

// [no description yet]
func (r ApiValidationResultGetObjectListRequest) CreatedDate(createdDate time.Time) ApiValidationResultGetObjectListRequest {
	r.createdDate = &createdDate
	return r
}

// [no description yet]
func (r ApiValidationResultGetObjectListRequest) Ou(ou []string) ApiValidationResultGetObjectListRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiValidationResultGetObjectListRequest) Page(page int32) ApiValidationResultGetObjectListRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiValidationResultGetObjectListRequest) PageSize(pageSize int32) ApiValidationResultGetObjectListRequest {
	r.pageSize = &pageSize
	return r
}

// [no description yet]
func (r ApiValidationResultGetObjectListRequest) Paging(paging bool) ApiValidationResultGetObjectListRequest {
	r.paging = &paging
	return r
}

// [no description yet]
func (r ApiValidationResultGetObjectListRequest) Pe(pe []string) ApiValidationResultGetObjectListRequest {
	r.pe = &pe
	return r
}

// [no description yet]
func (r ApiValidationResultGetObjectListRequest) SkipPaging(skipPaging bool) ApiValidationResultGetObjectListRequest {
	r.skipPaging = &skipPaging
	return r
}

// [no description yet]
func (r ApiValidationResultGetObjectListRequest) Total(total int64) ApiValidationResultGetObjectListRequest {
	r.total = &total
	return r
}

// [no description yet]
func (r ApiValidationResultGetObjectListRequest) Vr(vr []string) ApiValidationResultGetObjectListRequest {
	r.vr = &vr
	return r
}

func (r ApiValidationResultGetObjectListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ValidationResultGetObjectListExecute(r)
}

/*
ValidationResultGetObjectList Method for ValidationResultGetObjectList

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidationResultGetObjectListRequest
*/
func (a *DataAPIService) ValidationResultGetObjectList(ctx context.Context) ApiValidationResultGetObjectListRequest {
	return ApiValidationResultGetObjectListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *DataAPIService) ValidationResultGetObjectListExecute(r ApiValidationResultGetObjectListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationResultGetObjectList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationResults/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.createdDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdDate", r.createdDate, "")
	}
	if r.ou != nil {
		t := *r.ou
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ou", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ou", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.pe != nil {
		t := *r.pe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pe", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pe", t, "multi")
		}
	}
	if r.skipPaging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipPaging", r.skipPaging, "")
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue int64 = 0
		r.total = &defaultValue
	}
	if r.vr != nil {
		t := *r.vr
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vr", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vr", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleAddCollectionItemRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiValidationRuleAddCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleAddCollectionItemExecute(r)
}

/*
ValidationRuleAddCollectionItem Method for ValidationRuleAddCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationRuleAddCollectionItemRequest
*/
func (a *DataAPIService) ValidationRuleAddCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiValidationRuleAddCollectionItemRequest {
	return ApiValidationRuleAddCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleAddCollectionItemExecute(r ApiValidationRuleAddCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleAddCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleAddCollectionItemsJsonaddCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *DataAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiValidationRuleAddCollectionItemsJsonaddCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiValidationRuleAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiValidationRuleAddCollectionItemsJsonaddCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleAddCollectionItemsJsonaddCollectionItemsXmlExecute(r)
}

/*
ValidationRuleAddCollectionItemsJsonaddCollectionItemsXml Method for ValidationRuleAddCollectionItemsJsonaddCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationRuleAddCollectionItemsJsonaddCollectionItemsXmlRequest
*/
func (a *DataAPIService) ValidationRuleAddCollectionItemsJsonaddCollectionItemsXml(ctx context.Context, property string, uid string) ApiValidationRuleAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	return ApiValidationRuleAddCollectionItemsJsonaddCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleAddCollectionItemsJsonaddCollectionItemsXmlExecute(r ApiValidationRuleAddCollectionItemsJsonaddCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleAddCollectionItemsJsonaddCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleBulkSharingRequest struct {
	ctx                context.Context
	ApiService         *DataAPIService
	atomic             *bool
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	bulkJsonPatch      *BulkJsonPatch
}

// [no description yet]
func (r ApiValidationRuleBulkSharingRequest) Atomic(atomic bool) ApiValidationRuleBulkSharingRequest {
	r.atomic = &atomic
	return r
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiValidationRuleBulkSharingRequest) AtomicMode(atomicMode string) ApiValidationRuleBulkSharingRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiValidationRuleBulkSharingRequest) FlushMode(flushMode string) ApiValidationRuleBulkSharingRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiValidationRuleBulkSharingRequest) Identifier(identifier string) ApiValidationRuleBulkSharingRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiValidationRuleBulkSharingRequest) ImportMode(importMode string) ApiValidationRuleBulkSharingRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiValidationRuleBulkSharingRequest) ImportReportMode(importReportMode string) ApiValidationRuleBulkSharingRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiValidationRuleBulkSharingRequest) ImportStrategy(importStrategy string) ApiValidationRuleBulkSharingRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiValidationRuleBulkSharingRequest) MergeMode(mergeMode string) ApiValidationRuleBulkSharingRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiValidationRuleBulkSharingRequest) MetadataSyncImport(metadataSyncImport bool) ApiValidationRuleBulkSharingRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiValidationRuleBulkSharingRequest) Page(page int32) ApiValidationRuleBulkSharingRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiValidationRuleBulkSharingRequest) PageSize(pageSize int32) ApiValidationRuleBulkSharingRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiValidationRuleBulkSharingRequest) Paging(paging bool) ApiValidationRuleBulkSharingRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiValidationRuleBulkSharingRequest) PreheatMode(preheatMode string) ApiValidationRuleBulkSharingRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiValidationRuleBulkSharingRequest) RootJunction(rootJunction string) ApiValidationRuleBulkSharingRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiValidationRuleBulkSharingRequest) SkipSharing(skipSharing bool) ApiValidationRuleBulkSharingRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiValidationRuleBulkSharingRequest) SkipTranslation(skipTranslation bool) ApiValidationRuleBulkSharingRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiValidationRuleBulkSharingRequest) SkipValidation(skipValidation bool) ApiValidationRuleBulkSharingRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiValidationRuleBulkSharingRequest) UserOverrideMode(userOverrideMode string) ApiValidationRuleBulkSharingRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiValidationRuleBulkSharingRequest) BulkJsonPatch(bulkJsonPatch BulkJsonPatch) ApiValidationRuleBulkSharingRequest {
	r.bulkJsonPatch = &bulkJsonPatch
	return r
}

func (r ApiValidationRuleBulkSharingRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleBulkSharingExecute(r)
}

/*
ValidationRuleBulkSharing Method for ValidationRuleBulkSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidationRuleBulkSharingRequest
*/
func (a *DataAPIService) ValidationRuleBulkSharing(ctx context.Context) ApiValidationRuleBulkSharingRequest {
	return ApiValidationRuleBulkSharingRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleBulkSharingExecute(r ApiValidationRuleBulkSharingRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleBulkSharing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/sharing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomic", r.atomic, "")
	} else {
		var defaultValue bool = false
		r.atomic = &defaultValue
	}
	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkJsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleDeleteCollectionItemRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiValidationRuleDeleteCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleDeleteCollectionItemExecute(r)
}

/*
ValidationRuleDeleteCollectionItem Method for ValidationRuleDeleteCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationRuleDeleteCollectionItemRequest
*/
func (a *DataAPIService) ValidationRuleDeleteCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiValidationRuleDeleteCollectionItemRequest {
	return ApiValidationRuleDeleteCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleDeleteCollectionItemExecute(r ApiValidationRuleDeleteCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleDeleteCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *DataAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiValidationRuleDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiValidationRuleDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiValidationRuleDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r)
}

/*
ValidationRuleDeleteCollectionItemsJsondeleteCollectionItemsXml Method for ValidationRuleDeleteCollectionItemsJsondeleteCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationRuleDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest
*/
func (a *DataAPIService) ValidationRuleDeleteCollectionItemsJsondeleteCollectionItemsXml(ctx context.Context, property string, uid string) ApiValidationRuleDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	return ApiValidationRuleDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r ApiValidationRuleDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleDeleteCollectionItemsJsondeleteCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleDeleteObjectRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
}

func (r ApiValidationRuleDeleteObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleDeleteObjectExecute(r)
}

/*
ValidationRuleDeleteObject Method for ValidationRuleDeleteObject

Deletes the ValidationRule provided by ID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationRuleDeleteObjectRequest
*/
func (a *DataAPIService) ValidationRuleDeleteObject(ctx context.Context, uid string) ApiValidationRuleDeleteObjectRequest {
	return ApiValidationRuleDeleteObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleDeleteObjectExecute(r ApiValidationRuleDeleteObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleDeleteObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGetExpressionDescriptionRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	body       *string
}

// [no description yet]
func (r ApiValidationRuleGetExpressionDescriptionRequest) Body(body string) ApiValidationRuleGetExpressionDescriptionRequest {
	r.body = &body
	return r
}

func (r ApiValidationRuleGetExpressionDescriptionRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleGetExpressionDescriptionExecute(r)
}

/*
ValidationRuleGetExpressionDescription Method for ValidationRuleGetExpressionDescription

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidationRuleGetExpressionDescriptionRequest
*/
func (a *DataAPIService) ValidationRuleGetExpressionDescription(ctx context.Context) ApiValidationRuleGetExpressionDescriptionRequest {
	return ApiValidationRuleGetExpressionDescriptionRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleGetExpressionDescriptionExecute(r ApiValidationRuleGetExpressionDescriptionRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGetExpressionDescription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/expression/description"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGetObjectRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	uid          string
	fields       *[]string
	filter       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiValidationRuleGetObjectRequest) Fields(fields []string) ApiValidationRuleGetObjectRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiValidationRuleGetObjectRequest) Filter(filter []string) ApiValidationRuleGetObjectRequest {
	r.filter = &filter
	return r
}

// Defines which page number to return.
func (r ApiValidationRuleGetObjectRequest) Page(page int32) ApiValidationRuleGetObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiValidationRuleGetObjectRequest) PageSize(pageSize int32) ApiValidationRuleGetObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiValidationRuleGetObjectRequest) Paging(paging bool) ApiValidationRuleGetObjectRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiValidationRuleGetObjectRequest) RootJunction(rootJunction string) ApiValidationRuleGetObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiValidationRuleGetObjectRequest) Execute() (*ValidationRule, *http.Response, error) {
	return r.ApiService.ValidationRuleGetObjectExecute(r)
}

/*
ValidationRuleGetObject Method for ValidationRuleGetObject

View a ValidationRule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationRuleGetObjectRequest
*/
func (a *DataAPIService) ValidationRuleGetObject(ctx context.Context, uid string) ApiValidationRuleGetObjectRequest {
	return ApiValidationRuleGetObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return ValidationRule
func (a *DataAPIService) ValidationRuleGetObjectExecute(r ApiValidationRuleGetObjectRequest) (*ValidationRule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ValidationRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGetObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiValidationRuleGetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiValidationRuleGetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiValidationRuleGetObjectGistAsCsvRequest) Auto(auto string) ApiValidationRuleGetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiValidationRuleGetObjectGistAsCsvRequest) Describe(describe bool) ApiValidationRuleGetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiValidationRuleGetObjectGistAsCsvRequest) Fields(fields string) ApiValidationRuleGetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiValidationRuleGetObjectGistAsCsvRequest) Filter(filter string) ApiValidationRuleGetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiValidationRuleGetObjectGistAsCsvRequest) Headless(headless bool) ApiValidationRuleGetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiValidationRuleGetObjectGistAsCsvRequest) Inverse(inverse bool) ApiValidationRuleGetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiValidationRuleGetObjectGistAsCsvRequest) Locale(locale string) ApiValidationRuleGetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiValidationRuleGetObjectGistAsCsvRequest) Order(order string) ApiValidationRuleGetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiValidationRuleGetObjectGistAsCsvRequest) Page(page int32) ApiValidationRuleGetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiValidationRuleGetObjectGistAsCsvRequest) PageListName(pageListName string) ApiValidationRuleGetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiValidationRuleGetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiValidationRuleGetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiValidationRuleGetObjectGistAsCsvRequest) References(references bool) ApiValidationRuleGetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiValidationRuleGetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiValidationRuleGetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiValidationRuleGetObjectGistAsCsvRequest) Total(total bool) ApiValidationRuleGetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiValidationRuleGetObjectGistAsCsvRequest) Translate(translate bool) ApiValidationRuleGetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiValidationRuleGetObjectGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ValidationRuleGetObjectGistAsCsvExecute(r)
}

/*
ValidationRuleGetObjectGistAsCsv Method for ValidationRuleGetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationRuleGetObjectGistAsCsvRequest
*/
func (a *DataAPIService) ValidationRuleGetObjectGistAsCsv(ctx context.Context, uid string) ApiValidationRuleGetObjectGistAsCsvRequest {
	return ApiValidationRuleGetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *DataAPIService) ValidationRuleGetObjectGistAsCsvExecute(r ApiValidationRuleGetObjectGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/{uid}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest) Auto(auto string) ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest) Describe(describe bool) ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest) Fields(fields string) ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest) Filter(filter string) ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest) Headless(headless bool) ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest) Inverse(inverse bool) ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest) Locale(locale string) ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest) Order(order string) ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest) Page(page int32) ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest) PageListName(pageListName string) ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest) References(references bool) ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest) Total(total bool) ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest) Translate(translate bool) ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ValidationRuleGetObjectGistgetObjectGistAsCsvExecute(r)
}

/*
ValidationRuleGetObjectGistgetObjectGistAsCsv Method for ValidationRuleGetObjectGistgetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest
*/
func (a *DataAPIService) ValidationRuleGetObjectGistgetObjectGistAsCsv(ctx context.Context, uid string) ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest {
	return ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *DataAPIService) ValidationRuleGetObjectGistgetObjectGistAsCsvExecute(r ApiValidationRuleGetObjectGistgetObjectGistAsCsvRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGetObjectGistgetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/{uid}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGetObjectListRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	fields       *[]string
	filter       *[]string
	orders       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// &#x60;&lt;field-name&gt;[,&lt;field-name&gt;...]&#x60;
func (r ApiValidationRuleGetObjectListRequest) Fields(fields []string) ApiValidationRuleGetObjectListRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiValidationRuleGetObjectListRequest) Filter(filter []string) ApiValidationRuleGetObjectListRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiValidationRuleGetObjectListRequest) Orders(orders []string) ApiValidationRuleGetObjectListRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiValidationRuleGetObjectListRequest) Page(page int32) ApiValidationRuleGetObjectListRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiValidationRuleGetObjectListRequest) PageSize(pageSize int32) ApiValidationRuleGetObjectListRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiValidationRuleGetObjectListRequest) Paging(paging bool) ApiValidationRuleGetObjectListRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiValidationRuleGetObjectListRequest) RootJunction(rootJunction string) ApiValidationRuleGetObjectListRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiValidationRuleGetObjectListRequest) Execute() (*ValidationRuleGetObjectList200Response, *http.Response, error) {
	return r.ApiService.ValidationRuleGetObjectListExecute(r)
}

/*
ValidationRuleGetObjectList Method for ValidationRuleGetObjectList

List all ValidationRules

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidationRuleGetObjectListRequest
*/
func (a *DataAPIService) ValidationRuleGetObjectList(ctx context.Context) ApiValidationRuleGetObjectListRequest {
	return ApiValidationRuleGetObjectListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ValidationRuleGetObjectList200Response
func (a *DataAPIService) ValidationRuleGetObjectListExecute(r ApiValidationRuleGetObjectListRequest) (*ValidationRuleGetObjectList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ValidationRuleGetObjectList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGetObjectList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGetObjectListCsvRequest struct {
	ctx            context.Context
	ApiService     *DataAPIService
	arraySeparator *string
	fields         *[]string
	filter         *[]string
	orders         *[]string
	page           *int32
	pageSize       *int32
	paging         *bool
	rootJunction   *string
	separator      *string
	skipHeader     *bool
}

// [no description yet]
func (r ApiValidationRuleGetObjectListCsvRequest) ArraySeparator(arraySeparator string) ApiValidationRuleGetObjectListCsvRequest {
	r.arraySeparator = &arraySeparator
	return r
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiValidationRuleGetObjectListCsvRequest) Fields(fields []string) ApiValidationRuleGetObjectListCsvRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiValidationRuleGetObjectListCsvRequest) Filter(filter []string) ApiValidationRuleGetObjectListCsvRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiValidationRuleGetObjectListCsvRequest) Orders(orders []string) ApiValidationRuleGetObjectListCsvRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiValidationRuleGetObjectListCsvRequest) Page(page int32) ApiValidationRuleGetObjectListCsvRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiValidationRuleGetObjectListCsvRequest) PageSize(pageSize int32) ApiValidationRuleGetObjectListCsvRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiValidationRuleGetObjectListCsvRequest) Paging(paging bool) ApiValidationRuleGetObjectListCsvRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiValidationRuleGetObjectListCsvRequest) RootJunction(rootJunction string) ApiValidationRuleGetObjectListCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiValidationRuleGetObjectListCsvRequest) Separator(separator string) ApiValidationRuleGetObjectListCsvRequest {
	r.separator = &separator
	return r
}

// [no description yet]
func (r ApiValidationRuleGetObjectListCsvRequest) SkipHeader(skipHeader bool) ApiValidationRuleGetObjectListCsvRequest {
	r.skipHeader = &skipHeader
	return r
}

func (r ApiValidationRuleGetObjectListCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ValidationRuleGetObjectListCsvExecute(r)
}

/*
ValidationRuleGetObjectListCsv Method for ValidationRuleGetObjectListCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidationRuleGetObjectListCsvRequest
*/
func (a *DataAPIService) ValidationRuleGetObjectListCsv(ctx context.Context) ApiValidationRuleGetObjectListCsvRequest {
	return ApiValidationRuleGetObjectListCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *DataAPIService) ValidationRuleGetObjectListCsvExecute(r ApiValidationRuleGetObjectListCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGetObjectListCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/#getObjectListCsv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.arraySeparator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arraySeparator", r.arraySeparator, "")
	} else {
		var defaultValue string = ";"
		r.arraySeparator = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.separator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "separator", r.separator, "")
	} else {
		var defaultValue string = ","
		r.separator = &defaultValue
	}
	if r.skipHeader != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipHeader", r.skipHeader, "")
	} else {
		var defaultValue bool = false
		r.skipHeader = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/text", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiValidationRuleGetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiValidationRuleGetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiValidationRuleGetObjectListGistAsCsvRequest) Auto(auto string) ApiValidationRuleGetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiValidationRuleGetObjectListGistAsCsvRequest) Describe(describe bool) ApiValidationRuleGetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiValidationRuleGetObjectListGistAsCsvRequest) Fields(fields string) ApiValidationRuleGetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiValidationRuleGetObjectListGistAsCsvRequest) Filter(filter string) ApiValidationRuleGetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiValidationRuleGetObjectListGistAsCsvRequest) Headless(headless bool) ApiValidationRuleGetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiValidationRuleGetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiValidationRuleGetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiValidationRuleGetObjectListGistAsCsvRequest) Locale(locale string) ApiValidationRuleGetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiValidationRuleGetObjectListGistAsCsvRequest) Order(order string) ApiValidationRuleGetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiValidationRuleGetObjectListGistAsCsvRequest) Page(page int32) ApiValidationRuleGetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiValidationRuleGetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiValidationRuleGetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiValidationRuleGetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiValidationRuleGetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiValidationRuleGetObjectListGistAsCsvRequest) References(references bool) ApiValidationRuleGetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiValidationRuleGetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiValidationRuleGetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiValidationRuleGetObjectListGistAsCsvRequest) Total(total bool) ApiValidationRuleGetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiValidationRuleGetObjectListGistAsCsvRequest) Translate(translate bool) ApiValidationRuleGetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiValidationRuleGetObjectListGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ValidationRuleGetObjectListGistAsCsvExecute(r)
}

/*
ValidationRuleGetObjectListGistAsCsv Method for ValidationRuleGetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidationRuleGetObjectListGistAsCsvRequest
*/
func (a *DataAPIService) ValidationRuleGetObjectListGistAsCsv(ctx context.Context) ApiValidationRuleGetObjectListGistAsCsvRequest {
	return ApiValidationRuleGetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *DataAPIService) ValidationRuleGetObjectListGistAsCsvExecute(r ApiValidationRuleGetObjectListGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/gist.csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest) Auto(auto string) ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest) Describe(describe bool) ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest) Fields(fields string) ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest) Filter(filter string) ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest) Headless(headless bool) ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest) Locale(locale string) ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest) Order(order string) ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest) Page(page int32) ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest) References(references bool) ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest) Total(total bool) ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest) Translate(translate bool) ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest) Execute() (*ValidationRuleGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.ValidationRuleGetObjectListGistgetObjectListGistAsCsvExecute(r)
}

/*
ValidationRuleGetObjectListGistgetObjectListGistAsCsv Method for ValidationRuleGetObjectListGistgetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest
*/
func (a *DataAPIService) ValidationRuleGetObjectListGistgetObjectListGistAsCsv(ctx context.Context) ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest {
	return ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ValidationRuleGetObjectListGistGetObjectListGistAsCsv200Response
func (a *DataAPIService) ValidationRuleGetObjectListGistgetObjectListGistAsCsvExecute(r ApiValidationRuleGetObjectListGistgetObjectListGistAsCsvRequest) (*ValidationRuleGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ValidationRuleGetObjectListGistGetObjectListGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGetObjectListGistgetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/gist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGetObjectPropertyRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	property     string
	uid          string
	fields       *[]string
	locale       *string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
	translate    *bool
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiValidationRuleGetObjectPropertyRequest) Fields(fields []string) ApiValidationRuleGetObjectPropertyRequest {
	r.fields = &fields
	return r
}

// [no description yet]
func (r ApiValidationRuleGetObjectPropertyRequest) Locale(locale string) ApiValidationRuleGetObjectPropertyRequest {
	r.locale = &locale
	return r
}

// Defines which page number to return.
func (r ApiValidationRuleGetObjectPropertyRequest) Page(page int32) ApiValidationRuleGetObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiValidationRuleGetObjectPropertyRequest) PageSize(pageSize int32) ApiValidationRuleGetObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiValidationRuleGetObjectPropertyRequest) Paging(paging bool) ApiValidationRuleGetObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiValidationRuleGetObjectPropertyRequest) RootJunction(rootJunction string) ApiValidationRuleGetObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiValidationRuleGetObjectPropertyRequest) Translate(translate bool) ApiValidationRuleGetObjectPropertyRequest {
	r.translate = &translate
	return r
}

func (r ApiValidationRuleGetObjectPropertyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ValidationRuleGetObjectPropertyExecute(r)
}

/*
ValidationRuleGetObjectProperty Method for ValidationRuleGetObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationRuleGetObjectPropertyRequest
*/
func (a *DataAPIService) ValidationRuleGetObjectProperty(ctx context.Context, property string, uid string) ApiValidationRuleGetObjectPropertyRequest {
	return ApiValidationRuleGetObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *DataAPIService) ValidationRuleGetObjectPropertyExecute(r ApiValidationRuleGetObjectPropertyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGetObjectProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiValidationRuleGetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiValidationRuleGetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiValidationRuleGetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiValidationRuleGetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiValidationRuleGetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiValidationRuleGetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiValidationRuleGetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiValidationRuleGetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiValidationRuleGetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiValidationRuleGetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiValidationRuleGetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiValidationRuleGetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiValidationRuleGetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiValidationRuleGetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiValidationRuleGetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiValidationRuleGetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiValidationRuleGetObjectPropertyGistAsCsvRequest) Order(order string) ApiValidationRuleGetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiValidationRuleGetObjectPropertyGistAsCsvRequest) Page(page int32) ApiValidationRuleGetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiValidationRuleGetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiValidationRuleGetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiValidationRuleGetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiValidationRuleGetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiValidationRuleGetObjectPropertyGistAsCsvRequest) References(references bool) ApiValidationRuleGetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiValidationRuleGetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiValidationRuleGetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiValidationRuleGetObjectPropertyGistAsCsvRequest) Total(total bool) ApiValidationRuleGetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiValidationRuleGetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiValidationRuleGetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiValidationRuleGetObjectPropertyGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ValidationRuleGetObjectPropertyGistAsCsvExecute(r)
}

/*
ValidationRuleGetObjectPropertyGistAsCsv Method for ValidationRuleGetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationRuleGetObjectPropertyGistAsCsvRequest
*/
func (a *DataAPIService) ValidationRuleGetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiValidationRuleGetObjectPropertyGistAsCsvRequest {
	return ApiValidationRuleGetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *DataAPIService) ValidationRuleGetObjectPropertyGistAsCsvExecute(r ApiValidationRuleGetObjectPropertyGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/{uid}/{property}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Order(order string) ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Page(page int32) ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) References(references bool) ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Total(total bool) ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Execute() (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.ValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r)
}

/*
ValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsv Method for ValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest
*/
func (a *DataAPIService) ValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	return ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
func (a *DataAPIService) ValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r ApiValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGetObjectPropertyGistgetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/{uid}/{property}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGroupAddCollectionItemRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiValidationRuleGroupAddCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleGroupAddCollectionItemExecute(r)
}

/*
ValidationRuleGroupAddCollectionItem Method for ValidationRuleGroupAddCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationRuleGroupAddCollectionItemRequest
*/
func (a *DataAPIService) ValidationRuleGroupAddCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiValidationRuleGroupAddCollectionItemRequest {
	return ApiValidationRuleGroupAddCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleGroupAddCollectionItemExecute(r ApiValidationRuleGroupAddCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupAddCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGroupAddCollectionItemsJsonaddCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *DataAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiValidationRuleGroupAddCollectionItemsJsonaddCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiValidationRuleGroupAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiValidationRuleGroupAddCollectionItemsJsonaddCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleGroupAddCollectionItemsJsonaddCollectionItemsXmlExecute(r)
}

/*
ValidationRuleGroupAddCollectionItemsJsonaddCollectionItemsXml Method for ValidationRuleGroupAddCollectionItemsJsonaddCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationRuleGroupAddCollectionItemsJsonaddCollectionItemsXmlRequest
*/
func (a *DataAPIService) ValidationRuleGroupAddCollectionItemsJsonaddCollectionItemsXml(ctx context.Context, property string, uid string) ApiValidationRuleGroupAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	return ApiValidationRuleGroupAddCollectionItemsJsonaddCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleGroupAddCollectionItemsJsonaddCollectionItemsXmlExecute(r ApiValidationRuleGroupAddCollectionItemsJsonaddCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupAddCollectionItemsJsonaddCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGroupBulkSharingRequest struct {
	ctx                context.Context
	ApiService         *DataAPIService
	atomic             *bool
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	bulkJsonPatch      *BulkJsonPatch
}

// [no description yet]
func (r ApiValidationRuleGroupBulkSharingRequest) Atomic(atomic bool) ApiValidationRuleGroupBulkSharingRequest {
	r.atomic = &atomic
	return r
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiValidationRuleGroupBulkSharingRequest) AtomicMode(atomicMode string) ApiValidationRuleGroupBulkSharingRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiValidationRuleGroupBulkSharingRequest) FlushMode(flushMode string) ApiValidationRuleGroupBulkSharingRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiValidationRuleGroupBulkSharingRequest) Identifier(identifier string) ApiValidationRuleGroupBulkSharingRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiValidationRuleGroupBulkSharingRequest) ImportMode(importMode string) ApiValidationRuleGroupBulkSharingRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiValidationRuleGroupBulkSharingRequest) ImportReportMode(importReportMode string) ApiValidationRuleGroupBulkSharingRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiValidationRuleGroupBulkSharingRequest) ImportStrategy(importStrategy string) ApiValidationRuleGroupBulkSharingRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiValidationRuleGroupBulkSharingRequest) MergeMode(mergeMode string) ApiValidationRuleGroupBulkSharingRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupBulkSharingRequest) MetadataSyncImport(metadataSyncImport bool) ApiValidationRuleGroupBulkSharingRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiValidationRuleGroupBulkSharingRequest) Page(page int32) ApiValidationRuleGroupBulkSharingRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiValidationRuleGroupBulkSharingRequest) PageSize(pageSize int32) ApiValidationRuleGroupBulkSharingRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiValidationRuleGroupBulkSharingRequest) Paging(paging bool) ApiValidationRuleGroupBulkSharingRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiValidationRuleGroupBulkSharingRequest) PreheatMode(preheatMode string) ApiValidationRuleGroupBulkSharingRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiValidationRuleGroupBulkSharingRequest) RootJunction(rootJunction string) ApiValidationRuleGroupBulkSharingRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiValidationRuleGroupBulkSharingRequest) SkipSharing(skipSharing bool) ApiValidationRuleGroupBulkSharingRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupBulkSharingRequest) SkipTranslation(skipTranslation bool) ApiValidationRuleGroupBulkSharingRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiValidationRuleGroupBulkSharingRequest) SkipValidation(skipValidation bool) ApiValidationRuleGroupBulkSharingRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiValidationRuleGroupBulkSharingRequest) UserOverrideMode(userOverrideMode string) ApiValidationRuleGroupBulkSharingRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupBulkSharingRequest) BulkJsonPatch(bulkJsonPatch BulkJsonPatch) ApiValidationRuleGroupBulkSharingRequest {
	r.bulkJsonPatch = &bulkJsonPatch
	return r
}

func (r ApiValidationRuleGroupBulkSharingRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleGroupBulkSharingExecute(r)
}

/*
ValidationRuleGroupBulkSharing Method for ValidationRuleGroupBulkSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidationRuleGroupBulkSharingRequest
*/
func (a *DataAPIService) ValidationRuleGroupBulkSharing(ctx context.Context) ApiValidationRuleGroupBulkSharingRequest {
	return ApiValidationRuleGroupBulkSharingRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleGroupBulkSharingExecute(r ApiValidationRuleGroupBulkSharingRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupBulkSharing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/sharing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomic", r.atomic, "")
	} else {
		var defaultValue bool = false
		r.atomic = &defaultValue
	}
	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkJsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGroupDeleteCollectionItemRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiValidationRuleGroupDeleteCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleGroupDeleteCollectionItemExecute(r)
}

/*
ValidationRuleGroupDeleteCollectionItem Method for ValidationRuleGroupDeleteCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationRuleGroupDeleteCollectionItemRequest
*/
func (a *DataAPIService) ValidationRuleGroupDeleteCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiValidationRuleGroupDeleteCollectionItemRequest {
	return ApiValidationRuleGroupDeleteCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleGroupDeleteCollectionItemExecute(r ApiValidationRuleGroupDeleteCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupDeleteCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGroupDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *DataAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiValidationRuleGroupDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiValidationRuleGroupDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiValidationRuleGroupDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleGroupDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r)
}

/*
ValidationRuleGroupDeleteCollectionItemsJsondeleteCollectionItemsXml Method for ValidationRuleGroupDeleteCollectionItemsJsondeleteCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationRuleGroupDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest
*/
func (a *DataAPIService) ValidationRuleGroupDeleteCollectionItemsJsondeleteCollectionItemsXml(ctx context.Context, property string, uid string) ApiValidationRuleGroupDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	return ApiValidationRuleGroupDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleGroupDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r ApiValidationRuleGroupDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupDeleteCollectionItemsJsondeleteCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGroupDeleteObjectRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
}

func (r ApiValidationRuleGroupDeleteObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleGroupDeleteObjectExecute(r)
}

/*
ValidationRuleGroupDeleteObject Method for ValidationRuleGroupDeleteObject

Deletes the ValidationRuleGroup provided by ID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationRuleGroupDeleteObjectRequest
*/
func (a *DataAPIService) ValidationRuleGroupDeleteObject(ctx context.Context, uid string) ApiValidationRuleGroupDeleteObjectRequest {
	return ApiValidationRuleGroupDeleteObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleGroupDeleteObjectExecute(r ApiValidationRuleGroupDeleteObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupDeleteObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGroupGetObjectRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	uid          string
	fields       *[]string
	filter       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiValidationRuleGroupGetObjectRequest) Fields(fields []string) ApiValidationRuleGroupGetObjectRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiValidationRuleGroupGetObjectRequest) Filter(filter []string) ApiValidationRuleGroupGetObjectRequest {
	r.filter = &filter
	return r
}

// Defines which page number to return.
func (r ApiValidationRuleGroupGetObjectRequest) Page(page int32) ApiValidationRuleGroupGetObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiValidationRuleGroupGetObjectRequest) PageSize(pageSize int32) ApiValidationRuleGroupGetObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiValidationRuleGroupGetObjectRequest) Paging(paging bool) ApiValidationRuleGroupGetObjectRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiValidationRuleGroupGetObjectRequest) RootJunction(rootJunction string) ApiValidationRuleGroupGetObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiValidationRuleGroupGetObjectRequest) Execute() (*ValidationRuleGroup, *http.Response, error) {
	return r.ApiService.ValidationRuleGroupGetObjectExecute(r)
}

/*
ValidationRuleGroupGetObject Method for ValidationRuleGroupGetObject

View a ValidationRuleGroup

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationRuleGroupGetObjectRequest
*/
func (a *DataAPIService) ValidationRuleGroupGetObject(ctx context.Context, uid string) ApiValidationRuleGroupGetObjectRequest {
	return ApiValidationRuleGroupGetObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return ValidationRuleGroup
func (a *DataAPIService) ValidationRuleGroupGetObjectExecute(r ApiValidationRuleGroupGetObjectRequest) (*ValidationRuleGroup, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ValidationRuleGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupGetObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGroupGetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiValidationRuleGroupGetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiValidationRuleGroupGetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiValidationRuleGroupGetObjectGistAsCsvRequest) Auto(auto string) ApiValidationRuleGroupGetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiValidationRuleGroupGetObjectGistAsCsvRequest) Describe(describe bool) ApiValidationRuleGroupGetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiValidationRuleGroupGetObjectGistAsCsvRequest) Fields(fields string) ApiValidationRuleGroupGetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiValidationRuleGroupGetObjectGistAsCsvRequest) Filter(filter string) ApiValidationRuleGroupGetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiValidationRuleGroupGetObjectGistAsCsvRequest) Headless(headless bool) ApiValidationRuleGroupGetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiValidationRuleGroupGetObjectGistAsCsvRequest) Inverse(inverse bool) ApiValidationRuleGroupGetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiValidationRuleGroupGetObjectGistAsCsvRequest) Locale(locale string) ApiValidationRuleGroupGetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiValidationRuleGroupGetObjectGistAsCsvRequest) Order(order string) ApiValidationRuleGroupGetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiValidationRuleGroupGetObjectGistAsCsvRequest) Page(page int32) ApiValidationRuleGroupGetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupGetObjectGistAsCsvRequest) PageListName(pageListName string) ApiValidationRuleGroupGetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiValidationRuleGroupGetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiValidationRuleGroupGetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiValidationRuleGroupGetObjectGistAsCsvRequest) References(references bool) ApiValidationRuleGroupGetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiValidationRuleGroupGetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiValidationRuleGroupGetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiValidationRuleGroupGetObjectGistAsCsvRequest) Total(total bool) ApiValidationRuleGroupGetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiValidationRuleGroupGetObjectGistAsCsvRequest) Translate(translate bool) ApiValidationRuleGroupGetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiValidationRuleGroupGetObjectGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ValidationRuleGroupGetObjectGistAsCsvExecute(r)
}

/*
ValidationRuleGroupGetObjectGistAsCsv Method for ValidationRuleGroupGetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationRuleGroupGetObjectGistAsCsvRequest
*/
func (a *DataAPIService) ValidationRuleGroupGetObjectGistAsCsv(ctx context.Context, uid string) ApiValidationRuleGroupGetObjectGistAsCsvRequest {
	return ApiValidationRuleGroupGetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *DataAPIService) ValidationRuleGroupGetObjectGistAsCsvExecute(r ApiValidationRuleGroupGetObjectGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupGetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/{uid}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest) Auto(auto string) ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest) Describe(describe bool) ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest) Fields(fields string) ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest) Filter(filter string) ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest) Headless(headless bool) ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest) Inverse(inverse bool) ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest) Locale(locale string) ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest) Order(order string) ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest) Page(page int32) ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest) PageListName(pageListName string) ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest) References(references bool) ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest) Total(total bool) ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest) Translate(translate bool) ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ValidationRuleGroupGetObjectGistgetObjectGistAsCsvExecute(r)
}

/*
ValidationRuleGroupGetObjectGistgetObjectGistAsCsv Method for ValidationRuleGroupGetObjectGistgetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest
*/
func (a *DataAPIService) ValidationRuleGroupGetObjectGistgetObjectGistAsCsv(ctx context.Context, uid string) ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest {
	return ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *DataAPIService) ValidationRuleGroupGetObjectGistgetObjectGistAsCsvExecute(r ApiValidationRuleGroupGetObjectGistgetObjectGistAsCsvRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupGetObjectGistgetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/{uid}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGroupGetObjectListRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	fields       *[]string
	filter       *[]string
	orders       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// &#x60;&lt;field-name&gt;[,&lt;field-name&gt;...]&#x60;
func (r ApiValidationRuleGroupGetObjectListRequest) Fields(fields []string) ApiValidationRuleGroupGetObjectListRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiValidationRuleGroupGetObjectListRequest) Filter(filter []string) ApiValidationRuleGroupGetObjectListRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupGetObjectListRequest) Orders(orders []string) ApiValidationRuleGroupGetObjectListRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiValidationRuleGroupGetObjectListRequest) Page(page int32) ApiValidationRuleGroupGetObjectListRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiValidationRuleGroupGetObjectListRequest) PageSize(pageSize int32) ApiValidationRuleGroupGetObjectListRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiValidationRuleGroupGetObjectListRequest) Paging(paging bool) ApiValidationRuleGroupGetObjectListRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiValidationRuleGroupGetObjectListRequest) RootJunction(rootJunction string) ApiValidationRuleGroupGetObjectListRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiValidationRuleGroupGetObjectListRequest) Execute() (*ValidationRuleGroupGetObjectList200Response, *http.Response, error) {
	return r.ApiService.ValidationRuleGroupGetObjectListExecute(r)
}

/*
ValidationRuleGroupGetObjectList Method for ValidationRuleGroupGetObjectList

List all ValidationRuleGroups

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidationRuleGroupGetObjectListRequest
*/
func (a *DataAPIService) ValidationRuleGroupGetObjectList(ctx context.Context) ApiValidationRuleGroupGetObjectListRequest {
	return ApiValidationRuleGroupGetObjectListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ValidationRuleGroupGetObjectList200Response
func (a *DataAPIService) ValidationRuleGroupGetObjectListExecute(r ApiValidationRuleGroupGetObjectListRequest) (*ValidationRuleGroupGetObjectList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ValidationRuleGroupGetObjectList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupGetObjectList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGroupGetObjectListCsvRequest struct {
	ctx            context.Context
	ApiService     *DataAPIService
	arraySeparator *string
	fields         *[]string
	filter         *[]string
	orders         *[]string
	page           *int32
	pageSize       *int32
	paging         *bool
	rootJunction   *string
	separator      *string
	skipHeader     *bool
}

// [no description yet]
func (r ApiValidationRuleGroupGetObjectListCsvRequest) ArraySeparator(arraySeparator string) ApiValidationRuleGroupGetObjectListCsvRequest {
	r.arraySeparator = &arraySeparator
	return r
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiValidationRuleGroupGetObjectListCsvRequest) Fields(fields []string) ApiValidationRuleGroupGetObjectListCsvRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiValidationRuleGroupGetObjectListCsvRequest) Filter(filter []string) ApiValidationRuleGroupGetObjectListCsvRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupGetObjectListCsvRequest) Orders(orders []string) ApiValidationRuleGroupGetObjectListCsvRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiValidationRuleGroupGetObjectListCsvRequest) Page(page int32) ApiValidationRuleGroupGetObjectListCsvRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiValidationRuleGroupGetObjectListCsvRequest) PageSize(pageSize int32) ApiValidationRuleGroupGetObjectListCsvRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiValidationRuleGroupGetObjectListCsvRequest) Paging(paging bool) ApiValidationRuleGroupGetObjectListCsvRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiValidationRuleGroupGetObjectListCsvRequest) RootJunction(rootJunction string) ApiValidationRuleGroupGetObjectListCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupGetObjectListCsvRequest) Separator(separator string) ApiValidationRuleGroupGetObjectListCsvRequest {
	r.separator = &separator
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupGetObjectListCsvRequest) SkipHeader(skipHeader bool) ApiValidationRuleGroupGetObjectListCsvRequest {
	r.skipHeader = &skipHeader
	return r
}

func (r ApiValidationRuleGroupGetObjectListCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ValidationRuleGroupGetObjectListCsvExecute(r)
}

/*
ValidationRuleGroupGetObjectListCsv Method for ValidationRuleGroupGetObjectListCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidationRuleGroupGetObjectListCsvRequest
*/
func (a *DataAPIService) ValidationRuleGroupGetObjectListCsv(ctx context.Context) ApiValidationRuleGroupGetObjectListCsvRequest {
	return ApiValidationRuleGroupGetObjectListCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *DataAPIService) ValidationRuleGroupGetObjectListCsvExecute(r ApiValidationRuleGroupGetObjectListCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupGetObjectListCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/#getObjectListCsv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.arraySeparator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arraySeparator", r.arraySeparator, "")
	} else {
		var defaultValue string = ";"
		r.arraySeparator = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.separator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "separator", r.separator, "")
	} else {
		var defaultValue string = ","
		r.separator = &defaultValue
	}
	if r.skipHeader != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipHeader", r.skipHeader, "")
	} else {
		var defaultValue bool = false
		r.skipHeader = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/text", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGroupGetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiValidationRuleGroupGetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiValidationRuleGroupGetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiValidationRuleGroupGetObjectListGistAsCsvRequest) Auto(auto string) ApiValidationRuleGroupGetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiValidationRuleGroupGetObjectListGistAsCsvRequest) Describe(describe bool) ApiValidationRuleGroupGetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiValidationRuleGroupGetObjectListGistAsCsvRequest) Fields(fields string) ApiValidationRuleGroupGetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiValidationRuleGroupGetObjectListGistAsCsvRequest) Filter(filter string) ApiValidationRuleGroupGetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiValidationRuleGroupGetObjectListGistAsCsvRequest) Headless(headless bool) ApiValidationRuleGroupGetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiValidationRuleGroupGetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiValidationRuleGroupGetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiValidationRuleGroupGetObjectListGistAsCsvRequest) Locale(locale string) ApiValidationRuleGroupGetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiValidationRuleGroupGetObjectListGistAsCsvRequest) Order(order string) ApiValidationRuleGroupGetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiValidationRuleGroupGetObjectListGistAsCsvRequest) Page(page int32) ApiValidationRuleGroupGetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupGetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiValidationRuleGroupGetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiValidationRuleGroupGetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiValidationRuleGroupGetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiValidationRuleGroupGetObjectListGistAsCsvRequest) References(references bool) ApiValidationRuleGroupGetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiValidationRuleGroupGetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiValidationRuleGroupGetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiValidationRuleGroupGetObjectListGistAsCsvRequest) Total(total bool) ApiValidationRuleGroupGetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiValidationRuleGroupGetObjectListGistAsCsvRequest) Translate(translate bool) ApiValidationRuleGroupGetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiValidationRuleGroupGetObjectListGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ValidationRuleGroupGetObjectListGistAsCsvExecute(r)
}

/*
ValidationRuleGroupGetObjectListGistAsCsv Method for ValidationRuleGroupGetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidationRuleGroupGetObjectListGistAsCsvRequest
*/
func (a *DataAPIService) ValidationRuleGroupGetObjectListGistAsCsv(ctx context.Context) ApiValidationRuleGroupGetObjectListGistAsCsvRequest {
	return ApiValidationRuleGroupGetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *DataAPIService) ValidationRuleGroupGetObjectListGistAsCsvExecute(r ApiValidationRuleGroupGetObjectListGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupGetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/gist.csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest) Auto(auto string) ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest) Describe(describe bool) ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest) Fields(fields string) ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest) Filter(filter string) ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest) Headless(headless bool) ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest) Locale(locale string) ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest) Order(order string) ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest) Page(page int32) ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest) References(references bool) ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest) Total(total bool) ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest) Translate(translate bool) ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest) Execute() (*ValidationRuleGroupGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.ValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvExecute(r)
}

/*
ValidationRuleGroupGetObjectListGistgetObjectListGistAsCsv Method for ValidationRuleGroupGetObjectListGistgetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest
*/
func (a *DataAPIService) ValidationRuleGroupGetObjectListGistgetObjectListGistAsCsv(ctx context.Context) ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	return ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ValidationRuleGroupGetObjectListGistGetObjectListGistAsCsv200Response
func (a *DataAPIService) ValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvExecute(r ApiValidationRuleGroupGetObjectListGistgetObjectListGistAsCsvRequest) (*ValidationRuleGroupGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ValidationRuleGroupGetObjectListGistGetObjectListGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupGetObjectListGistgetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/gist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGroupGetObjectPropertyRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	property     string
	uid          string
	fields       *[]string
	locale       *string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
	translate    *bool
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiValidationRuleGroupGetObjectPropertyRequest) Fields(fields []string) ApiValidationRuleGroupGetObjectPropertyRequest {
	r.fields = &fields
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupGetObjectPropertyRequest) Locale(locale string) ApiValidationRuleGroupGetObjectPropertyRequest {
	r.locale = &locale
	return r
}

// Defines which page number to return.
func (r ApiValidationRuleGroupGetObjectPropertyRequest) Page(page int32) ApiValidationRuleGroupGetObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiValidationRuleGroupGetObjectPropertyRequest) PageSize(pageSize int32) ApiValidationRuleGroupGetObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiValidationRuleGroupGetObjectPropertyRequest) Paging(paging bool) ApiValidationRuleGroupGetObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiValidationRuleGroupGetObjectPropertyRequest) RootJunction(rootJunction string) ApiValidationRuleGroupGetObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupGetObjectPropertyRequest) Translate(translate bool) ApiValidationRuleGroupGetObjectPropertyRequest {
	r.translate = &translate
	return r
}

func (r ApiValidationRuleGroupGetObjectPropertyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ValidationRuleGroupGetObjectPropertyExecute(r)
}

/*
ValidationRuleGroupGetObjectProperty Method for ValidationRuleGroupGetObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationRuleGroupGetObjectPropertyRequest
*/
func (a *DataAPIService) ValidationRuleGroupGetObjectProperty(ctx context.Context, property string, uid string) ApiValidationRuleGroupGetObjectPropertyRequest {
	return ApiValidationRuleGroupGetObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *DataAPIService) ValidationRuleGroupGetObjectPropertyExecute(r ApiValidationRuleGroupGetObjectPropertyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupGetObjectProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest) Order(order string) ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest) Page(page int32) ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest) References(references bool) ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest) Total(total bool) ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ValidationRuleGroupGetObjectPropertyGistAsCsvExecute(r)
}

/*
ValidationRuleGroupGetObjectPropertyGistAsCsv Method for ValidationRuleGroupGetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest
*/
func (a *DataAPIService) ValidationRuleGroupGetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest {
	return ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *DataAPIService) ValidationRuleGroupGetObjectPropertyGistAsCsvExecute(r ApiValidationRuleGroupGetObjectPropertyGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupGetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/{uid}/{property}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *DataAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Order(order string) ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Page(page int32) ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) References(references bool) ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Total(total bool) ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Execute() (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.ValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r)
}

/*
ValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsv Method for ValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest
*/
func (a *DataAPIService) ValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	return ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
func (a *DataAPIService) ValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r ApiValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupGetObjectPropertyGistgetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/{uid}/{property}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGroupPatchObjectRequest struct {
	ctx                context.Context
	ApiService         *DataAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	jsonPatch          *JsonPatch
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiValidationRuleGroupPatchObjectRequest) AtomicMode(atomicMode string) ApiValidationRuleGroupPatchObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiValidationRuleGroupPatchObjectRequest) FlushMode(flushMode string) ApiValidationRuleGroupPatchObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiValidationRuleGroupPatchObjectRequest) Identifier(identifier string) ApiValidationRuleGroupPatchObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiValidationRuleGroupPatchObjectRequest) ImportMode(importMode string) ApiValidationRuleGroupPatchObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiValidationRuleGroupPatchObjectRequest) ImportReportMode(importReportMode string) ApiValidationRuleGroupPatchObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiValidationRuleGroupPatchObjectRequest) ImportStrategy(importStrategy string) ApiValidationRuleGroupPatchObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiValidationRuleGroupPatchObjectRequest) MergeMode(mergeMode string) ApiValidationRuleGroupPatchObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupPatchObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiValidationRuleGroupPatchObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiValidationRuleGroupPatchObjectRequest) Page(page int32) ApiValidationRuleGroupPatchObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiValidationRuleGroupPatchObjectRequest) PageSize(pageSize int32) ApiValidationRuleGroupPatchObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiValidationRuleGroupPatchObjectRequest) Paging(paging bool) ApiValidationRuleGroupPatchObjectRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiValidationRuleGroupPatchObjectRequest) PreheatMode(preheatMode string) ApiValidationRuleGroupPatchObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiValidationRuleGroupPatchObjectRequest) RootJunction(rootJunction string) ApiValidationRuleGroupPatchObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiValidationRuleGroupPatchObjectRequest) SkipSharing(skipSharing bool) ApiValidationRuleGroupPatchObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupPatchObjectRequest) SkipTranslation(skipTranslation bool) ApiValidationRuleGroupPatchObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiValidationRuleGroupPatchObjectRequest) SkipValidation(skipValidation bool) ApiValidationRuleGroupPatchObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiValidationRuleGroupPatchObjectRequest) UserOverrideMode(userOverrideMode string) ApiValidationRuleGroupPatchObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupPatchObjectRequest) JsonPatch(jsonPatch JsonPatch) ApiValidationRuleGroupPatchObjectRequest {
	r.jsonPatch = &jsonPatch
	return r
}

func (r ApiValidationRuleGroupPatchObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleGroupPatchObjectExecute(r)
}

/*
ValidationRuleGroupPatchObject Method for ValidationRuleGroupPatchObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationRuleGroupPatchObjectRequest
*/
func (a *DataAPIService) ValidationRuleGroupPatchObject(ctx context.Context, uid string) ApiValidationRuleGroupPatchObjectRequest {
	return ApiValidationRuleGroupPatchObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleGroupPatchObjectExecute(r ApiValidationRuleGroupPatchObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupPatchObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest struct {
	ctx                 context.Context
	ApiService          *DataAPIService
	atomicMode          *string
	flushMode           *string
	identifier          *string
	importMode          *string
	importReportMode    *string
	importStrategy      *string
	mergeMode           *string
	metadataSyncImport  *bool
	preheatMode         *string
	skipSharing         *bool
	skipTranslation     *bool
	skipValidation      *bool
	userOverrideMode    *string
	validationRuleGroup *ValidationRuleGroup
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest) AtomicMode(atomicMode string) ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest) FlushMode(flushMode string) ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest) Identifier(identifier string) ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest) ImportMode(importMode string) ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest) ImportReportMode(importReportMode string) ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest) ImportStrategy(importStrategy string) ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest) MergeMode(mergeMode string) ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest) PreheatMode(preheatMode string) ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest) SkipSharing(skipSharing bool) ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest) SkipValidation(skipValidation bool) ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest) ValidationRuleGroup(validationRuleGroup ValidationRuleGroup) ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest {
	r.validationRuleGroup = &validationRuleGroup
	return r
}

func (r ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleGroupPostJsonObjectpostXmlObjectExecute(r)
}

/*
ValidationRuleGroupPostJsonObjectpostXmlObject Method for ValidationRuleGroupPostJsonObjectpostXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest
*/
func (a *DataAPIService) ValidationRuleGroupPostJsonObjectpostXmlObject(ctx context.Context) ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest {
	return ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleGroupPostJsonObjectpostXmlObjectExecute(r ApiValidationRuleGroupPostJsonObjectpostXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupPostJsonObjectpostXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.validationRuleGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest struct {
	ctx                 context.Context
	ApiService          *DataAPIService
	uid                 string
	atomicMode          *string
	flushMode           *string
	identifier          *string
	importMode          *string
	importReportMode    *string
	importStrategy      *string
	mergeMode           *string
	metadataSyncImport  *bool
	preheatMode         *string
	skipSharing         *bool
	skipTranslation     *bool
	skipValidation      *bool
	userOverrideMode    *string
	validationRuleGroup *ValidationRuleGroup
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest) AtomicMode(atomicMode string) ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest) FlushMode(flushMode string) ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest) Identifier(identifier string) ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest) ImportMode(importMode string) ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest) ImportReportMode(importReportMode string) ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest) ImportStrategy(importStrategy string) ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest) MergeMode(mergeMode string) ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest) PreheatMode(preheatMode string) ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest) SkipSharing(skipSharing bool) ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest) SkipValidation(skipValidation bool) ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest) ValidationRuleGroup(validationRuleGroup ValidationRuleGroup) ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest {
	r.validationRuleGroup = &validationRuleGroup
	return r
}

func (r ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleGroupPutJsonObjectputXmlObjectExecute(r)
}

/*
ValidationRuleGroupPutJsonObjectputXmlObject Method for ValidationRuleGroupPutJsonObjectputXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest
*/
func (a *DataAPIService) ValidationRuleGroupPutJsonObjectputXmlObject(ctx context.Context, uid string) ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest {
	return ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleGroupPutJsonObjectputXmlObjectExecute(r ApiValidationRuleGroupPutJsonObjectputXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupPutJsonObjectputXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.validationRuleGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGroupRemoveAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
}

func (r ApiValidationRuleGroupRemoveAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleGroupRemoveAsFavoriteExecute(r)
}

/*
ValidationRuleGroupRemoveAsFavorite Method for ValidationRuleGroupRemoveAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationRuleGroupRemoveAsFavoriteRequest
*/
func (a *DataAPIService) ValidationRuleGroupRemoveAsFavorite(ctx context.Context, uid string) ApiValidationRuleGroupRemoveAsFavoriteRequest {
	return ApiValidationRuleGroupRemoveAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleGroupRemoveAsFavoriteExecute(r ApiValidationRuleGroupRemoveAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupRemoveAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGroupReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *DataAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiValidationRuleGroupReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiValidationRuleGroupReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiValidationRuleGroupReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleGroupReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r)
}

/*
ValidationRuleGroupReplaceCollectionItemsJsonreplaceCollectionItemsXml Method for ValidationRuleGroupReplaceCollectionItemsJsonreplaceCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationRuleGroupReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest
*/
func (a *DataAPIService) ValidationRuleGroupReplaceCollectionItemsJsonreplaceCollectionItemsXml(ctx context.Context, property string, uid string) ApiValidationRuleGroupReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	return ApiValidationRuleGroupReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleGroupReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r ApiValidationRuleGroupReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupReplaceCollectionItemsJsonreplaceCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGroupReplaceTranslationsRequest struct {
	ctx                                             context.Context
	ApiService                                      *DataAPIService
	uid                                             string
	aggregateDataExchangeReplaceTranslationsRequest *AggregateDataExchangeReplaceTranslationsRequest
}

// [no description yet]
func (r ApiValidationRuleGroupReplaceTranslationsRequest) AggregateDataExchangeReplaceTranslationsRequest(aggregateDataExchangeReplaceTranslationsRequest AggregateDataExchangeReplaceTranslationsRequest) ApiValidationRuleGroupReplaceTranslationsRequest {
	r.aggregateDataExchangeReplaceTranslationsRequest = &aggregateDataExchangeReplaceTranslationsRequest
	return r
}

func (r ApiValidationRuleGroupReplaceTranslationsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ValidationRuleGroupReplaceTranslationsExecute(r)
}

/*
ValidationRuleGroupReplaceTranslations Method for ValidationRuleGroupReplaceTranslations

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationRuleGroupReplaceTranslationsRequest
*/
func (a *DataAPIService) ValidationRuleGroupReplaceTranslations(ctx context.Context, uid string) ApiValidationRuleGroupReplaceTranslationsRequest {
	return ApiValidationRuleGroupReplaceTranslationsRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *DataAPIService) ValidationRuleGroupReplaceTranslationsExecute(r ApiValidationRuleGroupReplaceTranslationsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupReplaceTranslations")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/{uid}/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateDataExchangeReplaceTranslationsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiValidationRuleGroupSetAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
}

func (r ApiValidationRuleGroupSetAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleGroupSetAsFavoriteExecute(r)
}

/*
ValidationRuleGroupSetAsFavorite Method for ValidationRuleGroupSetAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationRuleGroupSetAsFavoriteRequest
*/
func (a *DataAPIService) ValidationRuleGroupSetAsFavorite(ctx context.Context, uid string) ApiValidationRuleGroupSetAsFavoriteRequest {
	return ApiValidationRuleGroupSetAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleGroupSetAsFavoriteExecute(r ApiValidationRuleGroupSetAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupSetAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGroupSetSharingRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
	sharing    *Sharing
}

// [no description yet]
func (r ApiValidationRuleGroupSetSharingRequest) Sharing(sharing Sharing) ApiValidationRuleGroupSetSharingRequest {
	r.sharing = &sharing
	return r
}

func (r ApiValidationRuleGroupSetSharingRequest) Execute() (*http.Response, error) {
	return r.ApiService.ValidationRuleGroupSetSharingExecute(r)
}

/*
ValidationRuleGroupSetSharing Method for ValidationRuleGroupSetSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationRuleGroupSetSharingRequest
*/
func (a *DataAPIService) ValidationRuleGroupSetSharing(ctx context.Context, uid string) ApiValidationRuleGroupSetSharingRequest {
	return ApiValidationRuleGroupSetSharingRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *DataAPIService) ValidationRuleGroupSetSharingExecute(r ApiValidationRuleGroupSetSharingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupSetSharing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/{uid}/sharing"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharing
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiValidationRuleGroupSubscribeRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
}

func (r ApiValidationRuleGroupSubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleGroupSubscribeExecute(r)
}

/*
ValidationRuleGroupSubscribe Method for ValidationRuleGroupSubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationRuleGroupSubscribeRequest
*/
func (a *DataAPIService) ValidationRuleGroupSubscribe(ctx context.Context, uid string) ApiValidationRuleGroupSubscribeRequest {
	return ApiValidationRuleGroupSubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleGroupSubscribeExecute(r ApiValidationRuleGroupSubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupSubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGroupUnsubscribeRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
}

func (r ApiValidationRuleGroupUnsubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleGroupUnsubscribeExecute(r)
}

/*
ValidationRuleGroupUnsubscribe Method for ValidationRuleGroupUnsubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationRuleGroupUnsubscribeRequest
*/
func (a *DataAPIService) ValidationRuleGroupUnsubscribe(ctx context.Context, uid string) ApiValidationRuleGroupUnsubscribeRequest {
	return ApiValidationRuleGroupUnsubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleGroupUnsubscribeExecute(r ApiValidationRuleGroupUnsubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupUnsubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleGroupUpdateObjectPropertyRequest struct {
	ctx                 context.Context
	ApiService          *DataAPIService
	property            string
	uid                 string
	atomicMode          *string
	flushMode           *string
	identifier          *string
	importMode          *string
	importReportMode    *string
	importStrategy      *string
	mergeMode           *string
	metadataSyncImport  *bool
	page                *int32
	pageSize            *int32
	paging              *bool
	preheatMode         *string
	rootJunction        *string
	skipSharing         *bool
	skipTranslation     *bool
	skipValidation      *bool
	userOverrideMode    *string
	validationRuleGroup *ValidationRuleGroup
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiValidationRuleGroupUpdateObjectPropertyRequest) AtomicMode(atomicMode string) ApiValidationRuleGroupUpdateObjectPropertyRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiValidationRuleGroupUpdateObjectPropertyRequest) FlushMode(flushMode string) ApiValidationRuleGroupUpdateObjectPropertyRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiValidationRuleGroupUpdateObjectPropertyRequest) Identifier(identifier string) ApiValidationRuleGroupUpdateObjectPropertyRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiValidationRuleGroupUpdateObjectPropertyRequest) ImportMode(importMode string) ApiValidationRuleGroupUpdateObjectPropertyRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiValidationRuleGroupUpdateObjectPropertyRequest) ImportReportMode(importReportMode string) ApiValidationRuleGroupUpdateObjectPropertyRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiValidationRuleGroupUpdateObjectPropertyRequest) ImportStrategy(importStrategy string) ApiValidationRuleGroupUpdateObjectPropertyRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiValidationRuleGroupUpdateObjectPropertyRequest) MergeMode(mergeMode string) ApiValidationRuleGroupUpdateObjectPropertyRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupUpdateObjectPropertyRequest) MetadataSyncImport(metadataSyncImport bool) ApiValidationRuleGroupUpdateObjectPropertyRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiValidationRuleGroupUpdateObjectPropertyRequest) Page(page int32) ApiValidationRuleGroupUpdateObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiValidationRuleGroupUpdateObjectPropertyRequest) PageSize(pageSize int32) ApiValidationRuleGroupUpdateObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiValidationRuleGroupUpdateObjectPropertyRequest) Paging(paging bool) ApiValidationRuleGroupUpdateObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiValidationRuleGroupUpdateObjectPropertyRequest) PreheatMode(preheatMode string) ApiValidationRuleGroupUpdateObjectPropertyRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiValidationRuleGroupUpdateObjectPropertyRequest) RootJunction(rootJunction string) ApiValidationRuleGroupUpdateObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiValidationRuleGroupUpdateObjectPropertyRequest) SkipSharing(skipSharing bool) ApiValidationRuleGroupUpdateObjectPropertyRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupUpdateObjectPropertyRequest) SkipTranslation(skipTranslation bool) ApiValidationRuleGroupUpdateObjectPropertyRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiValidationRuleGroupUpdateObjectPropertyRequest) SkipValidation(skipValidation bool) ApiValidationRuleGroupUpdateObjectPropertyRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiValidationRuleGroupUpdateObjectPropertyRequest) UserOverrideMode(userOverrideMode string) ApiValidationRuleGroupUpdateObjectPropertyRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiValidationRuleGroupUpdateObjectPropertyRequest) ValidationRuleGroup(validationRuleGroup ValidationRuleGroup) ApiValidationRuleGroupUpdateObjectPropertyRequest {
	r.validationRuleGroup = &validationRuleGroup
	return r
}

func (r ApiValidationRuleGroupUpdateObjectPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.ValidationRuleGroupUpdateObjectPropertyExecute(r)
}

/*
ValidationRuleGroupUpdateObjectProperty Method for ValidationRuleGroupUpdateObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationRuleGroupUpdateObjectPropertyRequest
*/
func (a *DataAPIService) ValidationRuleGroupUpdateObjectProperty(ctx context.Context, property string, uid string) ApiValidationRuleGroupUpdateObjectPropertyRequest {
	return ApiValidationRuleGroupUpdateObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
func (a *DataAPIService) ValidationRuleGroupUpdateObjectPropertyExecute(r ApiValidationRuleGroupUpdateObjectPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleGroupUpdateObjectProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRuleGroups/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.validationRuleGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiValidationRulePatchObjectRequest struct {
	ctx                context.Context
	ApiService         *DataAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	jsonPatch          *JsonPatch
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiValidationRulePatchObjectRequest) AtomicMode(atomicMode string) ApiValidationRulePatchObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiValidationRulePatchObjectRequest) FlushMode(flushMode string) ApiValidationRulePatchObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiValidationRulePatchObjectRequest) Identifier(identifier string) ApiValidationRulePatchObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiValidationRulePatchObjectRequest) ImportMode(importMode string) ApiValidationRulePatchObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiValidationRulePatchObjectRequest) ImportReportMode(importReportMode string) ApiValidationRulePatchObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiValidationRulePatchObjectRequest) ImportStrategy(importStrategy string) ApiValidationRulePatchObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiValidationRulePatchObjectRequest) MergeMode(mergeMode string) ApiValidationRulePatchObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiValidationRulePatchObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiValidationRulePatchObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiValidationRulePatchObjectRequest) Page(page int32) ApiValidationRulePatchObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiValidationRulePatchObjectRequest) PageSize(pageSize int32) ApiValidationRulePatchObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiValidationRulePatchObjectRequest) Paging(paging bool) ApiValidationRulePatchObjectRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiValidationRulePatchObjectRequest) PreheatMode(preheatMode string) ApiValidationRulePatchObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiValidationRulePatchObjectRequest) RootJunction(rootJunction string) ApiValidationRulePatchObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiValidationRulePatchObjectRequest) SkipSharing(skipSharing bool) ApiValidationRulePatchObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiValidationRulePatchObjectRequest) SkipTranslation(skipTranslation bool) ApiValidationRulePatchObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiValidationRulePatchObjectRequest) SkipValidation(skipValidation bool) ApiValidationRulePatchObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiValidationRulePatchObjectRequest) UserOverrideMode(userOverrideMode string) ApiValidationRulePatchObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiValidationRulePatchObjectRequest) JsonPatch(jsonPatch JsonPatch) ApiValidationRulePatchObjectRequest {
	r.jsonPatch = &jsonPatch
	return r
}

func (r ApiValidationRulePatchObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRulePatchObjectExecute(r)
}

/*
ValidationRulePatchObject Method for ValidationRulePatchObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationRulePatchObjectRequest
*/
func (a *DataAPIService) ValidationRulePatchObject(ctx context.Context, uid string) ApiValidationRulePatchObjectRequest {
	return ApiValidationRulePatchObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRulePatchObjectExecute(r ApiValidationRulePatchObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRulePatchObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRulePostJsonObjectpostXmlObjectRequest struct {
	ctx                context.Context
	ApiService         *DataAPIService
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	preheatMode        *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	validationRule     *ValidationRule
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiValidationRulePostJsonObjectpostXmlObjectRequest) AtomicMode(atomicMode string) ApiValidationRulePostJsonObjectpostXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiValidationRulePostJsonObjectpostXmlObjectRequest) FlushMode(flushMode string) ApiValidationRulePostJsonObjectpostXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiValidationRulePostJsonObjectpostXmlObjectRequest) Identifier(identifier string) ApiValidationRulePostJsonObjectpostXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiValidationRulePostJsonObjectpostXmlObjectRequest) ImportMode(importMode string) ApiValidationRulePostJsonObjectpostXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiValidationRulePostJsonObjectpostXmlObjectRequest) ImportReportMode(importReportMode string) ApiValidationRulePostJsonObjectpostXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiValidationRulePostJsonObjectpostXmlObjectRequest) ImportStrategy(importStrategy string) ApiValidationRulePostJsonObjectpostXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiValidationRulePostJsonObjectpostXmlObjectRequest) MergeMode(mergeMode string) ApiValidationRulePostJsonObjectpostXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiValidationRulePostJsonObjectpostXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiValidationRulePostJsonObjectpostXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiValidationRulePostJsonObjectpostXmlObjectRequest) PreheatMode(preheatMode string) ApiValidationRulePostJsonObjectpostXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiValidationRulePostJsonObjectpostXmlObjectRequest) SkipSharing(skipSharing bool) ApiValidationRulePostJsonObjectpostXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiValidationRulePostJsonObjectpostXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiValidationRulePostJsonObjectpostXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiValidationRulePostJsonObjectpostXmlObjectRequest) SkipValidation(skipValidation bool) ApiValidationRulePostJsonObjectpostXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiValidationRulePostJsonObjectpostXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiValidationRulePostJsonObjectpostXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiValidationRulePostJsonObjectpostXmlObjectRequest) ValidationRule(validationRule ValidationRule) ApiValidationRulePostJsonObjectpostXmlObjectRequest {
	r.validationRule = &validationRule
	return r
}

func (r ApiValidationRulePostJsonObjectpostXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRulePostJsonObjectpostXmlObjectExecute(r)
}

/*
ValidationRulePostJsonObjectpostXmlObject Method for ValidationRulePostJsonObjectpostXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidationRulePostJsonObjectpostXmlObjectRequest
*/
func (a *DataAPIService) ValidationRulePostJsonObjectpostXmlObject(ctx context.Context) ApiValidationRulePostJsonObjectpostXmlObjectRequest {
	return ApiValidationRulePostJsonObjectpostXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRulePostJsonObjectpostXmlObjectExecute(r ApiValidationRulePostJsonObjectpostXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRulePostJsonObjectpostXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.validationRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRulePutJsonObjectputXmlObjectRequest struct {
	ctx                context.Context
	ApiService         *DataAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	preheatMode        *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	validationRule     *ValidationRule
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiValidationRulePutJsonObjectputXmlObjectRequest) AtomicMode(atomicMode string) ApiValidationRulePutJsonObjectputXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiValidationRulePutJsonObjectputXmlObjectRequest) FlushMode(flushMode string) ApiValidationRulePutJsonObjectputXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiValidationRulePutJsonObjectputXmlObjectRequest) Identifier(identifier string) ApiValidationRulePutJsonObjectputXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiValidationRulePutJsonObjectputXmlObjectRequest) ImportMode(importMode string) ApiValidationRulePutJsonObjectputXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiValidationRulePutJsonObjectputXmlObjectRequest) ImportReportMode(importReportMode string) ApiValidationRulePutJsonObjectputXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiValidationRulePutJsonObjectputXmlObjectRequest) ImportStrategy(importStrategy string) ApiValidationRulePutJsonObjectputXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiValidationRulePutJsonObjectputXmlObjectRequest) MergeMode(mergeMode string) ApiValidationRulePutJsonObjectputXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiValidationRulePutJsonObjectputXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiValidationRulePutJsonObjectputXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiValidationRulePutJsonObjectputXmlObjectRequest) PreheatMode(preheatMode string) ApiValidationRulePutJsonObjectputXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiValidationRulePutJsonObjectputXmlObjectRequest) SkipSharing(skipSharing bool) ApiValidationRulePutJsonObjectputXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiValidationRulePutJsonObjectputXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiValidationRulePutJsonObjectputXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiValidationRulePutJsonObjectputXmlObjectRequest) SkipValidation(skipValidation bool) ApiValidationRulePutJsonObjectputXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiValidationRulePutJsonObjectputXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiValidationRulePutJsonObjectputXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiValidationRulePutJsonObjectputXmlObjectRequest) ValidationRule(validationRule ValidationRule) ApiValidationRulePutJsonObjectputXmlObjectRequest {
	r.validationRule = &validationRule
	return r
}

func (r ApiValidationRulePutJsonObjectputXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRulePutJsonObjectputXmlObjectExecute(r)
}

/*
ValidationRulePutJsonObjectputXmlObject Method for ValidationRulePutJsonObjectputXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationRulePutJsonObjectputXmlObjectRequest
*/
func (a *DataAPIService) ValidationRulePutJsonObjectputXmlObject(ctx context.Context, uid string) ApiValidationRulePutJsonObjectputXmlObjectRequest {
	return ApiValidationRulePutJsonObjectputXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRulePutJsonObjectputXmlObjectExecute(r ApiValidationRulePutJsonObjectputXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRulePutJsonObjectputXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.validationRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleRemoveAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
}

func (r ApiValidationRuleRemoveAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleRemoveAsFavoriteExecute(r)
}

/*
ValidationRuleRemoveAsFavorite Method for ValidationRuleRemoveAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationRuleRemoveAsFavoriteRequest
*/
func (a *DataAPIService) ValidationRuleRemoveAsFavorite(ctx context.Context, uid string) ApiValidationRuleRemoveAsFavoriteRequest {
	return ApiValidationRuleRemoveAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleRemoveAsFavoriteExecute(r ApiValidationRuleRemoveAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleRemoveAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *DataAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiValidationRuleReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiValidationRuleReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiValidationRuleReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r)
}

/*
ValidationRuleReplaceCollectionItemsJsonreplaceCollectionItemsXml Method for ValidationRuleReplaceCollectionItemsJsonreplaceCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationRuleReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest
*/
func (a *DataAPIService) ValidationRuleReplaceCollectionItemsJsonreplaceCollectionItemsXml(ctx context.Context, property string, uid string) ApiValidationRuleReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	return ApiValidationRuleReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r ApiValidationRuleReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleReplaceCollectionItemsJsonreplaceCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleReplaceTranslationsRequest struct {
	ctx                                             context.Context
	ApiService                                      *DataAPIService
	uid                                             string
	aggregateDataExchangeReplaceTranslationsRequest *AggregateDataExchangeReplaceTranslationsRequest
}

// [no description yet]
func (r ApiValidationRuleReplaceTranslationsRequest) AggregateDataExchangeReplaceTranslationsRequest(aggregateDataExchangeReplaceTranslationsRequest AggregateDataExchangeReplaceTranslationsRequest) ApiValidationRuleReplaceTranslationsRequest {
	r.aggregateDataExchangeReplaceTranslationsRequest = &aggregateDataExchangeReplaceTranslationsRequest
	return r
}

func (r ApiValidationRuleReplaceTranslationsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ValidationRuleReplaceTranslationsExecute(r)
}

/*
ValidationRuleReplaceTranslations Method for ValidationRuleReplaceTranslations

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationRuleReplaceTranslationsRequest
*/
func (a *DataAPIService) ValidationRuleReplaceTranslations(ctx context.Context, uid string) ApiValidationRuleReplaceTranslationsRequest {
	return ApiValidationRuleReplaceTranslationsRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *DataAPIService) ValidationRuleReplaceTranslationsExecute(r ApiValidationRuleReplaceTranslationsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleReplaceTranslations")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/{uid}/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateDataExchangeReplaceTranslationsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiValidationRuleSetAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
}

func (r ApiValidationRuleSetAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleSetAsFavoriteExecute(r)
}

/*
ValidationRuleSetAsFavorite Method for ValidationRuleSetAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationRuleSetAsFavoriteRequest
*/
func (a *DataAPIService) ValidationRuleSetAsFavorite(ctx context.Context, uid string) ApiValidationRuleSetAsFavoriteRequest {
	return ApiValidationRuleSetAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleSetAsFavoriteExecute(r ApiValidationRuleSetAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleSetAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleSetSharingRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
	sharing    *Sharing
}

// [no description yet]
func (r ApiValidationRuleSetSharingRequest) Sharing(sharing Sharing) ApiValidationRuleSetSharingRequest {
	r.sharing = &sharing
	return r
}

func (r ApiValidationRuleSetSharingRequest) Execute() (*http.Response, error) {
	return r.ApiService.ValidationRuleSetSharingExecute(r)
}

/*
ValidationRuleSetSharing Method for ValidationRuleSetSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationRuleSetSharingRequest
*/
func (a *DataAPIService) ValidationRuleSetSharing(ctx context.Context, uid string) ApiValidationRuleSetSharingRequest {
	return ApiValidationRuleSetSharingRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *DataAPIService) ValidationRuleSetSharingExecute(r ApiValidationRuleSetSharingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleSetSharing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/{uid}/sharing"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharing
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiValidationRuleSubscribeRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
}

func (r ApiValidationRuleSubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleSubscribeExecute(r)
}

/*
ValidationRuleSubscribe Method for ValidationRuleSubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationRuleSubscribeRequest
*/
func (a *DataAPIService) ValidationRuleSubscribe(ctx context.Context, uid string) ApiValidationRuleSubscribeRequest {
	return ApiValidationRuleSubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleSubscribeExecute(r ApiValidationRuleSubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleSubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleUnsubscribeRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	uid        string
}

func (r ApiValidationRuleUnsubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRuleUnsubscribeExecute(r)
}

/*
ValidationRuleUnsubscribe Method for ValidationRuleUnsubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiValidationRuleUnsubscribeRequest
*/
func (a *DataAPIService) ValidationRuleUnsubscribe(ctx context.Context, uid string) ApiValidationRuleUnsubscribeRequest {
	return ApiValidationRuleUnsubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRuleUnsubscribeExecute(r ApiValidationRuleUnsubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleUnsubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRuleUpdateObjectPropertyRequest struct {
	ctx                context.Context
	ApiService         *DataAPIService
	property           string
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	validationRule     *ValidationRule
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiValidationRuleUpdateObjectPropertyRequest) AtomicMode(atomicMode string) ApiValidationRuleUpdateObjectPropertyRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiValidationRuleUpdateObjectPropertyRequest) FlushMode(flushMode string) ApiValidationRuleUpdateObjectPropertyRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiValidationRuleUpdateObjectPropertyRequest) Identifier(identifier string) ApiValidationRuleUpdateObjectPropertyRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiValidationRuleUpdateObjectPropertyRequest) ImportMode(importMode string) ApiValidationRuleUpdateObjectPropertyRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiValidationRuleUpdateObjectPropertyRequest) ImportReportMode(importReportMode string) ApiValidationRuleUpdateObjectPropertyRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiValidationRuleUpdateObjectPropertyRequest) ImportStrategy(importStrategy string) ApiValidationRuleUpdateObjectPropertyRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiValidationRuleUpdateObjectPropertyRequest) MergeMode(mergeMode string) ApiValidationRuleUpdateObjectPropertyRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiValidationRuleUpdateObjectPropertyRequest) MetadataSyncImport(metadataSyncImport bool) ApiValidationRuleUpdateObjectPropertyRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiValidationRuleUpdateObjectPropertyRequest) Page(page int32) ApiValidationRuleUpdateObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiValidationRuleUpdateObjectPropertyRequest) PageSize(pageSize int32) ApiValidationRuleUpdateObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiValidationRuleUpdateObjectPropertyRequest) Paging(paging bool) ApiValidationRuleUpdateObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiValidationRuleUpdateObjectPropertyRequest) PreheatMode(preheatMode string) ApiValidationRuleUpdateObjectPropertyRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiValidationRuleUpdateObjectPropertyRequest) RootJunction(rootJunction string) ApiValidationRuleUpdateObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiValidationRuleUpdateObjectPropertyRequest) SkipSharing(skipSharing bool) ApiValidationRuleUpdateObjectPropertyRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiValidationRuleUpdateObjectPropertyRequest) SkipTranslation(skipTranslation bool) ApiValidationRuleUpdateObjectPropertyRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiValidationRuleUpdateObjectPropertyRequest) SkipValidation(skipValidation bool) ApiValidationRuleUpdateObjectPropertyRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiValidationRuleUpdateObjectPropertyRequest) UserOverrideMode(userOverrideMode string) ApiValidationRuleUpdateObjectPropertyRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiValidationRuleUpdateObjectPropertyRequest) ValidationRule(validationRule ValidationRule) ApiValidationRuleUpdateObjectPropertyRequest {
	r.validationRule = &validationRule
	return r
}

func (r ApiValidationRuleUpdateObjectPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.ValidationRuleUpdateObjectPropertyExecute(r)
}

/*
ValidationRuleUpdateObjectProperty Method for ValidationRuleUpdateObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiValidationRuleUpdateObjectPropertyRequest
*/
func (a *DataAPIService) ValidationRuleUpdateObjectProperty(ctx context.Context, property string, uid string) ApiValidationRuleUpdateObjectPropertyRequest {
	return ApiValidationRuleUpdateObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
func (a *DataAPIService) ValidationRuleUpdateObjectPropertyExecute(r ApiValidationRuleUpdateObjectPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRuleUpdateObjectProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validationRules/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.validationRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiValidationRunValidationNotificationsTaskRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
}

func (r ApiValidationRunValidationNotificationsTaskRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRunValidationNotificationsTaskExecute(r)
}

/*
ValidationRunValidationNotificationsTask Method for ValidationRunValidationNotificationsTask

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidationRunValidationNotificationsTaskRequest
*/
func (a *DataAPIService) ValidationRunValidationNotificationsTask(ctx context.Context) ApiValidationRunValidationNotificationsTaskRequest {
	return ApiValidationRunValidationNotificationsTaskRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRunValidationNotificationsTaskExecute(r ApiValidationRunValidationNotificationsTaskRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRunValidationNotificationsTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validation/sendNotifications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationRunValidationNotificationsTask2Request struct {
	ctx        context.Context
	ApiService *DataAPIService
}

func (r ApiValidationRunValidationNotificationsTask2Request) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.ValidationRunValidationNotificationsTask2Execute(r)
}

/*
ValidationRunValidationNotificationsTask2 Method for ValidationRunValidationNotificationsTask2

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidationRunValidationNotificationsTask2Request
*/
func (a *DataAPIService) ValidationRunValidationNotificationsTask2(ctx context.Context) ApiValidationRunValidationNotificationsTask2Request {
	return ApiValidationRunValidationNotificationsTask2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *DataAPIService) ValidationRunValidationNotificationsTask2Execute(r ApiValidationRunValidationNotificationsTask2Request) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationRunValidationNotificationsTask2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validation/sendNotifications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidationValidateRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	ds         string
	ou         *string
	pe         *string
	aoc        *string
	cc         *string
	cp         *string
}

// [no description yet]
func (r ApiValidationValidateRequest) Ou(ou string) ApiValidationValidateRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiValidationValidateRequest) Pe(pe string) ApiValidationValidateRequest {
	r.pe = &pe
	return r
}

// [no description yet]
func (r ApiValidationValidateRequest) Aoc(aoc string) ApiValidationValidateRequest {
	r.aoc = &aoc
	return r
}

// [no description yet]
func (r ApiValidationValidateRequest) Cc(cc string) ApiValidationValidateRequest {
	r.cc = &cc
	return r
}

// [no description yet]
func (r ApiValidationValidateRequest) Cp(cp string) ApiValidationValidateRequest {
	r.cp = &cp
	return r
}

func (r ApiValidationValidateRequest) Execute() (*ValidationSummary, *http.Response, error) {
	return r.ApiService.ValidationValidateExecute(r)
}

/*
ValidationValidate Method for ValidationValidate

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ds [no description yet]
	@return ApiValidationValidateRequest
*/
func (a *DataAPIService) ValidationValidate(ctx context.Context, ds string) ApiValidationValidateRequest {
	return ApiValidationValidateRequest{
		ApiService: a,
		ctx:        ctx,
		ds:         ds,
	}
}

// Execute executes the request
//
//	@return ValidationSummary
func (a *DataAPIService) ValidationValidateExecute(r ApiValidationValidateRequest) (*ValidationSummary, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ValidationSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ValidationValidate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validation/dataSet/{ds}"
	localVarPath = strings.Replace(localVarPath, "{"+"ds"+"}", url.PathEscape(parameterValueToString(r.ds, "ds")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ou == nil {
		return localVarReturnValue, nil, reportError("ou is required and must be specified")
	}
	if r.pe == nil {
		return localVarReturnValue, nil, reportError("pe is required and must be specified")
	}

	if r.aoc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aoc", r.aoc, "")
	}
	if r.cc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cc", r.cc, "")
	}
	if r.cp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cp", r.cp, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pe", r.pe, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
