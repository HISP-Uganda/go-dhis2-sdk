/*
DHIS2 API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.40
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package models

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
	"time"
)

// ManagementAPIService ManagementAPI service
type ManagementAPIService service

type ApiUserAddCollectionItemRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiUserAddCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserAddCollectionItemExecute(r)
}

/*
UserAddCollectionItem Method for UserAddCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserAddCollectionItemRequest
*/
func (a *ManagementAPIService) UserAddCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiUserAddCollectionItemRequest {
	return ApiUserAddCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserAddCollectionItemExecute(r ApiUserAddCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserAddCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserAddCollectionItemsJsonaddCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *ManagementAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiUserAddCollectionItemsJsonaddCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiUserAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiUserAddCollectionItemsJsonaddCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserAddCollectionItemsJsonaddCollectionItemsXmlExecute(r)
}

/*
UserAddCollectionItemsJsonaddCollectionItemsXml Method for UserAddCollectionItemsJsonaddCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserAddCollectionItemsJsonaddCollectionItemsXmlRequest
*/
func (a *ManagementAPIService) UserAddCollectionItemsJsonaddCollectionItemsXml(ctx context.Context, property string, uid string) ApiUserAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	return ApiUserAddCollectionItemsJsonaddCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserAddCollectionItemsJsonaddCollectionItemsXmlExecute(r ApiUserAddCollectionItemsJsonaddCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserAddCollectionItemsJsonaddCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserBulkSharingRequest struct {
	ctx                context.Context
	ApiService         *ManagementAPIService
	atomic             *bool
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	bulkJsonPatch      *BulkJsonPatch
}

// [no description yet]
func (r ApiUserBulkSharingRequest) Atomic(atomic bool) ApiUserBulkSharingRequest {
	r.atomic = &atomic
	return r
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiUserBulkSharingRequest) AtomicMode(atomicMode string) ApiUserBulkSharingRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiUserBulkSharingRequest) FlushMode(flushMode string) ApiUserBulkSharingRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiUserBulkSharingRequest) Identifier(identifier string) ApiUserBulkSharingRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiUserBulkSharingRequest) ImportMode(importMode string) ApiUserBulkSharingRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiUserBulkSharingRequest) ImportReportMode(importReportMode string) ApiUserBulkSharingRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiUserBulkSharingRequest) ImportStrategy(importStrategy string) ApiUserBulkSharingRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiUserBulkSharingRequest) MergeMode(mergeMode string) ApiUserBulkSharingRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiUserBulkSharingRequest) MetadataSyncImport(metadataSyncImport bool) ApiUserBulkSharingRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiUserBulkSharingRequest) Page(page int32) ApiUserBulkSharingRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiUserBulkSharingRequest) PageSize(pageSize int32) ApiUserBulkSharingRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiUserBulkSharingRequest) Paging(paging bool) ApiUserBulkSharingRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiUserBulkSharingRequest) PreheatMode(preheatMode string) ApiUserBulkSharingRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiUserBulkSharingRequest) RootJunction(rootJunction string) ApiUserBulkSharingRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiUserBulkSharingRequest) SkipSharing(skipSharing bool) ApiUserBulkSharingRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiUserBulkSharingRequest) SkipTranslation(skipTranslation bool) ApiUserBulkSharingRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiUserBulkSharingRequest) SkipValidation(skipValidation bool) ApiUserBulkSharingRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiUserBulkSharingRequest) UserOverrideMode(userOverrideMode string) ApiUserBulkSharingRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiUserBulkSharingRequest) BulkJsonPatch(bulkJsonPatch BulkJsonPatch) ApiUserBulkSharingRequest {
	r.bulkJsonPatch = &bulkJsonPatch
	return r
}

func (r ApiUserBulkSharingRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserBulkSharingExecute(r)
}

/*
UserBulkSharing Method for UserBulkSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUserBulkSharingRequest
*/
func (a *ManagementAPIService) UserBulkSharing(ctx context.Context) ApiUserBulkSharingRequest {
	return ApiUserBulkSharingRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserBulkSharingExecute(r ApiUserBulkSharingRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserBulkSharing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/sharing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomic", r.atomic, "")
	} else {
		var defaultValue bool = false
		r.atomic = &defaultValue
	}
	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkJsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserDeleteCollectionItemRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiUserDeleteCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserDeleteCollectionItemExecute(r)
}

/*
UserDeleteCollectionItem Method for UserDeleteCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserDeleteCollectionItemRequest
*/
func (a *ManagementAPIService) UserDeleteCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiUserDeleteCollectionItemRequest {
	return ApiUserDeleteCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserDeleteCollectionItemExecute(r ApiUserDeleteCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserDeleteCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *ManagementAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiUserDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiUserDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiUserDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r)
}

/*
UserDeleteCollectionItemsJsondeleteCollectionItemsXml Method for UserDeleteCollectionItemsJsondeleteCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest
*/
func (a *ManagementAPIService) UserDeleteCollectionItemsJsondeleteCollectionItemsXml(ctx context.Context, property string, uid string) ApiUserDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	return ApiUserDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r ApiUserDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserDeleteCollectionItemsJsondeleteCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserDeleteObjectRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	uid        string
}

func (r ApiUserDeleteObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserDeleteObjectExecute(r)
}

/*
UserDeleteObject Method for UserDeleteObject

Deletes the User provided by ID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserDeleteObjectRequest
*/
func (a *ManagementAPIService) UserDeleteObject(ctx context.Context, uid string) ApiUserDeleteObjectRequest {
	return ApiUserDeleteObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserDeleteObjectExecute(r ApiUserDeleteObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserDeleteObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserDisableTwoFaRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	uid        string
}

func (r ApiUserDisableTwoFaRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserDisableTwoFaExecute(r)
}

/*
UserDisableTwoFa Method for UserDisableTwoFa

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserDisableTwoFaRequest
*/
func (a *ManagementAPIService) UserDisableTwoFa(ctx context.Context, uid string) ApiUserDisableTwoFaRequest {
	return ApiUserDisableTwoFaRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserDisableTwoFaExecute(r ApiUserDisableTwoFaRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserDisableTwoFa")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}/twoFA/disabled"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserDisableUserRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	uid        string
}

func (r ApiUserDisableUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserDisableUserExecute(r)
}

/*
UserDisableUser Method for UserDisableUser

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserDisableUserRequest
*/
func (a *ManagementAPIService) UserDisableUser(ctx context.Context, uid string) ApiUserDisableUserRequest {
	return ApiUserDisableUserRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *ManagementAPIService) UserDisableUserExecute(r ApiUserDisableUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserDisableUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}/disabled"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserEnableUserRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	uid        string
}

func (r ApiUserEnableUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserEnableUserExecute(r)
}

/*
UserEnableUser Method for UserEnableUser

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserEnableUserRequest
*/
func (a *ManagementAPIService) UserEnableUser(ctx context.Context, uid string) ApiUserEnableUserRequest {
	return ApiUserEnableUserRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *ManagementAPIService) UserEnableUserExecute(r ApiUserEnableUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserEnableUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}/enabled"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserExpireUserRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	date       *time.Time
	uid        string
}

// [no description yet]
func (r ApiUserExpireUserRequest) Date(date time.Time) ApiUserExpireUserRequest {
	r.date = &date
	return r
}

func (r ApiUserExpireUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserExpireUserExecute(r)
}

/*
UserExpireUser Method for UserExpireUser

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserExpireUserRequest
*/
func (a *ManagementAPIService) UserExpireUser(ctx context.Context, uid string) ApiUserExpireUserRequest {
	return ApiUserExpireUserRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *ManagementAPIService) UserExpireUserExecute(r ApiUserExpireUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserExpireUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}/expired"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.date == nil {
		return nil, reportError("date is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserGetObjectRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	uid          string
	fields       *[]string
	filter       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiUserGetObjectRequest) Fields(fields []string) ApiUserGetObjectRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiUserGetObjectRequest) Filter(filter []string) ApiUserGetObjectRequest {
	r.filter = &filter
	return r
}

// Defines which page number to return.
func (r ApiUserGetObjectRequest) Page(page int32) ApiUserGetObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiUserGetObjectRequest) PageSize(pageSize int32) ApiUserGetObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiUserGetObjectRequest) Paging(paging bool) ApiUserGetObjectRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiUserGetObjectRequest) RootJunction(rootJunction string) ApiUserGetObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiUserGetObjectRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.UserGetObjectExecute(r)
}

/*
UserGetObject Method for UserGetObject

View a User

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserGetObjectRequest
*/
func (a *ManagementAPIService) UserGetObject(ctx context.Context, uid string) ApiUserGetObjectRequest {
	return ApiUserGetObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return User
func (a *ManagementAPIService) UserGetObjectExecute(r ApiUserGetObjectRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGetObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiUserGetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiUserGetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiUserGetObjectGistAsCsvRequest) Auto(auto string) ApiUserGetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiUserGetObjectGistAsCsvRequest) Describe(describe bool) ApiUserGetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiUserGetObjectGistAsCsvRequest) Fields(fields string) ApiUserGetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiUserGetObjectGistAsCsvRequest) Filter(filter string) ApiUserGetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiUserGetObjectGistAsCsvRequest) Headless(headless bool) ApiUserGetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiUserGetObjectGistAsCsvRequest) Inverse(inverse bool) ApiUserGetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiUserGetObjectGistAsCsvRequest) Locale(locale string) ApiUserGetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiUserGetObjectGistAsCsvRequest) Order(order string) ApiUserGetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiUserGetObjectGistAsCsvRequest) Page(page int32) ApiUserGetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiUserGetObjectGistAsCsvRequest) PageListName(pageListName string) ApiUserGetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiUserGetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiUserGetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiUserGetObjectGistAsCsvRequest) References(references bool) ApiUserGetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiUserGetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiUserGetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiUserGetObjectGistAsCsvRequest) Total(total bool) ApiUserGetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiUserGetObjectGistAsCsvRequest) Translate(translate bool) ApiUserGetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiUserGetObjectGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.UserGetObjectGistAsCsvExecute(r)
}

/*
UserGetObjectGistAsCsv Method for UserGetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserGetObjectGistAsCsvRequest
*/
func (a *ManagementAPIService) UserGetObjectGistAsCsv(ctx context.Context, uid string) ApiUserGetObjectGistAsCsvRequest {
	return ApiUserGetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *ManagementAPIService) UserGetObjectGistAsCsvExecute(r ApiUserGetObjectGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGetObjectGistgetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiUserGetObjectGistgetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiUserGetObjectGistgetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiUserGetObjectGistgetObjectGistAsCsvRequest) Auto(auto string) ApiUserGetObjectGistgetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiUserGetObjectGistgetObjectGistAsCsvRequest) Describe(describe bool) ApiUserGetObjectGistgetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiUserGetObjectGistgetObjectGistAsCsvRequest) Fields(fields string) ApiUserGetObjectGistgetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiUserGetObjectGistgetObjectGistAsCsvRequest) Filter(filter string) ApiUserGetObjectGistgetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiUserGetObjectGistgetObjectGistAsCsvRequest) Headless(headless bool) ApiUserGetObjectGistgetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiUserGetObjectGistgetObjectGistAsCsvRequest) Inverse(inverse bool) ApiUserGetObjectGistgetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiUserGetObjectGistgetObjectGistAsCsvRequest) Locale(locale string) ApiUserGetObjectGistgetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiUserGetObjectGistgetObjectGistAsCsvRequest) Order(order string) ApiUserGetObjectGistgetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiUserGetObjectGistgetObjectGistAsCsvRequest) Page(page int32) ApiUserGetObjectGistgetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiUserGetObjectGistgetObjectGistAsCsvRequest) PageListName(pageListName string) ApiUserGetObjectGistgetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiUserGetObjectGistgetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiUserGetObjectGistgetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiUserGetObjectGistgetObjectGistAsCsvRequest) References(references bool) ApiUserGetObjectGistgetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiUserGetObjectGistgetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiUserGetObjectGistgetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiUserGetObjectGistgetObjectGistAsCsvRequest) Total(total bool) ApiUserGetObjectGistgetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiUserGetObjectGistgetObjectGistAsCsvRequest) Translate(translate bool) ApiUserGetObjectGistgetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiUserGetObjectGistgetObjectGistAsCsvRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UserGetObjectGistgetObjectGistAsCsvExecute(r)
}

/*
UserGetObjectGistgetObjectGistAsCsv Method for UserGetObjectGistgetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserGetObjectGistgetObjectGistAsCsvRequest
*/
func (a *ManagementAPIService) UserGetObjectGistgetObjectGistAsCsv(ctx context.Context, uid string) ApiUserGetObjectGistgetObjectGistAsCsvRequest {
	return ApiUserGetObjectGistgetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ManagementAPIService) UserGetObjectGistgetObjectGistAsCsvExecute(r ApiUserGetObjectGistgetObjectGistAsCsvRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGetObjectGistgetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGetObjectListRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	fields       *[]string
	filter       *[]string
	orders       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// &#x60;&lt;field-name&gt;[,&lt;field-name&gt;...]&#x60;
func (r ApiUserGetObjectListRequest) Fields(fields []string) ApiUserGetObjectListRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiUserGetObjectListRequest) Filter(filter []string) ApiUserGetObjectListRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiUserGetObjectListRequest) Orders(orders []string) ApiUserGetObjectListRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiUserGetObjectListRequest) Page(page int32) ApiUserGetObjectListRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiUserGetObjectListRequest) PageSize(pageSize int32) ApiUserGetObjectListRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiUserGetObjectListRequest) Paging(paging bool) ApiUserGetObjectListRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiUserGetObjectListRequest) RootJunction(rootJunction string) ApiUserGetObjectListRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiUserGetObjectListRequest) Execute() (*UserGetObjectList200Response, *http.Response, error) {
	return r.ApiService.UserGetObjectListExecute(r)
}

/*
UserGetObjectList Method for UserGetObjectList

List all Users

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUserGetObjectListRequest
*/
func (a *ManagementAPIService) UserGetObjectList(ctx context.Context) ApiUserGetObjectListRequest {
	return ApiUserGetObjectListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserGetObjectList200Response
func (a *ManagementAPIService) UserGetObjectListExecute(r ApiUserGetObjectListRequest) (*UserGetObjectList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserGetObjectList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGetObjectList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGetObjectListCsvRequest struct {
	ctx            context.Context
	ApiService     *ManagementAPIService
	arraySeparator *string
	fields         *[]string
	filter         *[]string
	orders         *[]string
	page           *int32
	pageSize       *int32
	paging         *bool
	rootJunction   *string
	separator      *string
	skipHeader     *bool
}

// [no description yet]
func (r ApiUserGetObjectListCsvRequest) ArraySeparator(arraySeparator string) ApiUserGetObjectListCsvRequest {
	r.arraySeparator = &arraySeparator
	return r
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiUserGetObjectListCsvRequest) Fields(fields []string) ApiUserGetObjectListCsvRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiUserGetObjectListCsvRequest) Filter(filter []string) ApiUserGetObjectListCsvRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiUserGetObjectListCsvRequest) Orders(orders []string) ApiUserGetObjectListCsvRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiUserGetObjectListCsvRequest) Page(page int32) ApiUserGetObjectListCsvRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiUserGetObjectListCsvRequest) PageSize(pageSize int32) ApiUserGetObjectListCsvRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiUserGetObjectListCsvRequest) Paging(paging bool) ApiUserGetObjectListCsvRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiUserGetObjectListCsvRequest) RootJunction(rootJunction string) ApiUserGetObjectListCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiUserGetObjectListCsvRequest) Separator(separator string) ApiUserGetObjectListCsvRequest {
	r.separator = &separator
	return r
}

// [no description yet]
func (r ApiUserGetObjectListCsvRequest) SkipHeader(skipHeader bool) ApiUserGetObjectListCsvRequest {
	r.skipHeader = &skipHeader
	return r
}

func (r ApiUserGetObjectListCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.UserGetObjectListCsvExecute(r)
}

/*
UserGetObjectListCsv Method for UserGetObjectListCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUserGetObjectListCsvRequest
*/
func (a *ManagementAPIService) UserGetObjectListCsv(ctx context.Context) ApiUserGetObjectListCsvRequest {
	return ApiUserGetObjectListCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *ManagementAPIService) UserGetObjectListCsvExecute(r ApiUserGetObjectListCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGetObjectListCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/#getObjectListCsv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.arraySeparator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arraySeparator", r.arraySeparator, "")
	} else {
		var defaultValue string = ";"
		r.arraySeparator = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.separator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "separator", r.separator, "")
	} else {
		var defaultValue string = ","
		r.separator = &defaultValue
	}
	if r.skipHeader != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipHeader", r.skipHeader, "")
	} else {
		var defaultValue bool = false
		r.skipHeader = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/text", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiUserGetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiUserGetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiUserGetObjectListGistAsCsvRequest) Auto(auto string) ApiUserGetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiUserGetObjectListGistAsCsvRequest) Describe(describe bool) ApiUserGetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiUserGetObjectListGistAsCsvRequest) Fields(fields string) ApiUserGetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiUserGetObjectListGistAsCsvRequest) Filter(filter string) ApiUserGetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiUserGetObjectListGistAsCsvRequest) Headless(headless bool) ApiUserGetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiUserGetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiUserGetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiUserGetObjectListGistAsCsvRequest) Locale(locale string) ApiUserGetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiUserGetObjectListGistAsCsvRequest) Order(order string) ApiUserGetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiUserGetObjectListGistAsCsvRequest) Page(page int32) ApiUserGetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiUserGetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiUserGetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiUserGetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiUserGetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiUserGetObjectListGistAsCsvRequest) References(references bool) ApiUserGetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiUserGetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiUserGetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiUserGetObjectListGistAsCsvRequest) Total(total bool) ApiUserGetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiUserGetObjectListGistAsCsvRequest) Translate(translate bool) ApiUserGetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiUserGetObjectListGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.UserGetObjectListGistAsCsvExecute(r)
}

/*
UserGetObjectListGistAsCsv Method for UserGetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUserGetObjectListGistAsCsvRequest
*/
func (a *ManagementAPIService) UserGetObjectListGistAsCsv(ctx context.Context) ApiUserGetObjectListGistAsCsvRequest {
	return ApiUserGetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *ManagementAPIService) UserGetObjectListGistAsCsvExecute(r ApiUserGetObjectListGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/gist.csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGetObjectListGistgetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiUserGetObjectListGistgetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiUserGetObjectListGistgetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiUserGetObjectListGistgetObjectListGistAsCsvRequest) Auto(auto string) ApiUserGetObjectListGistgetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiUserGetObjectListGistgetObjectListGistAsCsvRequest) Describe(describe bool) ApiUserGetObjectListGistgetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiUserGetObjectListGistgetObjectListGistAsCsvRequest) Fields(fields string) ApiUserGetObjectListGistgetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiUserGetObjectListGistgetObjectListGistAsCsvRequest) Filter(filter string) ApiUserGetObjectListGistgetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiUserGetObjectListGistgetObjectListGistAsCsvRequest) Headless(headless bool) ApiUserGetObjectListGistgetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiUserGetObjectListGistgetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiUserGetObjectListGistgetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiUserGetObjectListGistgetObjectListGistAsCsvRequest) Locale(locale string) ApiUserGetObjectListGistgetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiUserGetObjectListGistgetObjectListGistAsCsvRequest) Order(order string) ApiUserGetObjectListGistgetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiUserGetObjectListGistgetObjectListGistAsCsvRequest) Page(page int32) ApiUserGetObjectListGistgetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiUserGetObjectListGistgetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiUserGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiUserGetObjectListGistgetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiUserGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiUserGetObjectListGistgetObjectListGistAsCsvRequest) References(references bool) ApiUserGetObjectListGistgetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiUserGetObjectListGistgetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiUserGetObjectListGistgetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiUserGetObjectListGistgetObjectListGistAsCsvRequest) Total(total bool) ApiUserGetObjectListGistgetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiUserGetObjectListGistgetObjectListGistAsCsvRequest) Translate(translate bool) ApiUserGetObjectListGistgetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiUserGetObjectListGistgetObjectListGistAsCsvRequest) Execute() (*UserGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.UserGetObjectListGistgetObjectListGistAsCsvExecute(r)
}

/*
UserGetObjectListGistgetObjectListGistAsCsv Method for UserGetObjectListGistgetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUserGetObjectListGistgetObjectListGistAsCsvRequest
*/
func (a *ManagementAPIService) UserGetObjectListGistgetObjectListGistAsCsv(ctx context.Context) ApiUserGetObjectListGistgetObjectListGistAsCsvRequest {
	return ApiUserGetObjectListGistgetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserGetObjectListGistGetObjectListGistAsCsv200Response
func (a *ManagementAPIService) UserGetObjectListGistgetObjectListGistAsCsvExecute(r ApiUserGetObjectListGistgetObjectListGistAsCsvRequest) (*UserGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserGetObjectListGistGetObjectListGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGetObjectListGistgetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/gist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGetObjectPropertyRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	property     string
	uid          string
	fields       *[]string
	locale       *string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
	translate    *bool
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiUserGetObjectPropertyRequest) Fields(fields []string) ApiUserGetObjectPropertyRequest {
	r.fields = &fields
	return r
}

// [no description yet]
func (r ApiUserGetObjectPropertyRequest) Locale(locale string) ApiUserGetObjectPropertyRequest {
	r.locale = &locale
	return r
}

// Defines which page number to return.
func (r ApiUserGetObjectPropertyRequest) Page(page int32) ApiUserGetObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiUserGetObjectPropertyRequest) PageSize(pageSize int32) ApiUserGetObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiUserGetObjectPropertyRequest) Paging(paging bool) ApiUserGetObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiUserGetObjectPropertyRequest) RootJunction(rootJunction string) ApiUserGetObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiUserGetObjectPropertyRequest) Translate(translate bool) ApiUserGetObjectPropertyRequest {
	r.translate = &translate
	return r
}

func (r ApiUserGetObjectPropertyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UserGetObjectPropertyExecute(r)
}

/*
UserGetObjectProperty Method for UserGetObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserGetObjectPropertyRequest
*/
func (a *ManagementAPIService) UserGetObjectProperty(ctx context.Context, property string, uid string) ApiUserGetObjectPropertyRequest {
	return ApiUserGetObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ManagementAPIService) UserGetObjectPropertyExecute(r ApiUserGetObjectPropertyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGetObjectProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiUserGetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiUserGetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiUserGetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiUserGetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiUserGetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiUserGetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiUserGetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiUserGetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiUserGetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiUserGetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiUserGetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiUserGetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiUserGetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiUserGetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiUserGetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiUserGetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiUserGetObjectPropertyGistAsCsvRequest) Order(order string) ApiUserGetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiUserGetObjectPropertyGistAsCsvRequest) Page(page int32) ApiUserGetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiUserGetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiUserGetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiUserGetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiUserGetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiUserGetObjectPropertyGistAsCsvRequest) References(references bool) ApiUserGetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiUserGetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiUserGetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiUserGetObjectPropertyGistAsCsvRequest) Total(total bool) ApiUserGetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiUserGetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiUserGetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiUserGetObjectPropertyGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.UserGetObjectPropertyGistAsCsvExecute(r)
}

/*
UserGetObjectPropertyGistAsCsv Method for UserGetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserGetObjectPropertyGistAsCsvRequest
*/
func (a *ManagementAPIService) UserGetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiUserGetObjectPropertyGistAsCsvRequest {
	return ApiUserGetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *ManagementAPIService) UserGetObjectPropertyGistAsCsvExecute(r ApiUserGetObjectPropertyGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}/{property}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Order(order string) ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Page(page int32) ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) References(references bool) ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Total(total bool) ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Execute() (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.UserGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r)
}

/*
UserGetObjectPropertyGistgetObjectPropertyGistAsCsv Method for UserGetObjectPropertyGistgetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest
*/
func (a *ManagementAPIService) UserGetObjectPropertyGistgetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	return ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
func (a *ManagementAPIService) UserGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r ApiUserGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGetObjectPropertyGistgetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}/{property}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGroupAddCollectionItemRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiUserGroupAddCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserGroupAddCollectionItemExecute(r)
}

/*
UserGroupAddCollectionItem Method for UserGroupAddCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserGroupAddCollectionItemRequest
*/
func (a *ManagementAPIService) UserGroupAddCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiUserGroupAddCollectionItemRequest {
	return ApiUserGroupAddCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserGroupAddCollectionItemExecute(r ApiUserGroupAddCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupAddCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGroupAddCollectionItemsJsonaddCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *ManagementAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiUserGroupAddCollectionItemsJsonaddCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiUserGroupAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiUserGroupAddCollectionItemsJsonaddCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserGroupAddCollectionItemsJsonaddCollectionItemsXmlExecute(r)
}

/*
UserGroupAddCollectionItemsJsonaddCollectionItemsXml Method for UserGroupAddCollectionItemsJsonaddCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserGroupAddCollectionItemsJsonaddCollectionItemsXmlRequest
*/
func (a *ManagementAPIService) UserGroupAddCollectionItemsJsonaddCollectionItemsXml(ctx context.Context, property string, uid string) ApiUserGroupAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	return ApiUserGroupAddCollectionItemsJsonaddCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserGroupAddCollectionItemsJsonaddCollectionItemsXmlExecute(r ApiUserGroupAddCollectionItemsJsonaddCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupAddCollectionItemsJsonaddCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGroupBulkSharingRequest struct {
	ctx                context.Context
	ApiService         *ManagementAPIService
	atomic             *bool
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	bulkJsonPatch      *BulkJsonPatch
}

// [no description yet]
func (r ApiUserGroupBulkSharingRequest) Atomic(atomic bool) ApiUserGroupBulkSharingRequest {
	r.atomic = &atomic
	return r
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiUserGroupBulkSharingRequest) AtomicMode(atomicMode string) ApiUserGroupBulkSharingRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiUserGroupBulkSharingRequest) FlushMode(flushMode string) ApiUserGroupBulkSharingRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiUserGroupBulkSharingRequest) Identifier(identifier string) ApiUserGroupBulkSharingRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiUserGroupBulkSharingRequest) ImportMode(importMode string) ApiUserGroupBulkSharingRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiUserGroupBulkSharingRequest) ImportReportMode(importReportMode string) ApiUserGroupBulkSharingRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiUserGroupBulkSharingRequest) ImportStrategy(importStrategy string) ApiUserGroupBulkSharingRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiUserGroupBulkSharingRequest) MergeMode(mergeMode string) ApiUserGroupBulkSharingRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiUserGroupBulkSharingRequest) MetadataSyncImport(metadataSyncImport bool) ApiUserGroupBulkSharingRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiUserGroupBulkSharingRequest) Page(page int32) ApiUserGroupBulkSharingRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiUserGroupBulkSharingRequest) PageSize(pageSize int32) ApiUserGroupBulkSharingRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiUserGroupBulkSharingRequest) Paging(paging bool) ApiUserGroupBulkSharingRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiUserGroupBulkSharingRequest) PreheatMode(preheatMode string) ApiUserGroupBulkSharingRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiUserGroupBulkSharingRequest) RootJunction(rootJunction string) ApiUserGroupBulkSharingRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiUserGroupBulkSharingRequest) SkipSharing(skipSharing bool) ApiUserGroupBulkSharingRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiUserGroupBulkSharingRequest) SkipTranslation(skipTranslation bool) ApiUserGroupBulkSharingRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiUserGroupBulkSharingRequest) SkipValidation(skipValidation bool) ApiUserGroupBulkSharingRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiUserGroupBulkSharingRequest) UserOverrideMode(userOverrideMode string) ApiUserGroupBulkSharingRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiUserGroupBulkSharingRequest) BulkJsonPatch(bulkJsonPatch BulkJsonPatch) ApiUserGroupBulkSharingRequest {
	r.bulkJsonPatch = &bulkJsonPatch
	return r
}

func (r ApiUserGroupBulkSharingRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserGroupBulkSharingExecute(r)
}

/*
UserGroupBulkSharing Method for UserGroupBulkSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUserGroupBulkSharingRequest
*/
func (a *ManagementAPIService) UserGroupBulkSharing(ctx context.Context) ApiUserGroupBulkSharingRequest {
	return ApiUserGroupBulkSharingRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserGroupBulkSharingExecute(r ApiUserGroupBulkSharingRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupBulkSharing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/sharing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomic", r.atomic, "")
	} else {
		var defaultValue bool = false
		r.atomic = &defaultValue
	}
	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkJsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGroupDeleteCollectionItemRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiUserGroupDeleteCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserGroupDeleteCollectionItemExecute(r)
}

/*
UserGroupDeleteCollectionItem Method for UserGroupDeleteCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserGroupDeleteCollectionItemRequest
*/
func (a *ManagementAPIService) UserGroupDeleteCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiUserGroupDeleteCollectionItemRequest {
	return ApiUserGroupDeleteCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserGroupDeleteCollectionItemExecute(r ApiUserGroupDeleteCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupDeleteCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGroupDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *ManagementAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiUserGroupDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiUserGroupDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiUserGroupDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserGroupDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r)
}

/*
UserGroupDeleteCollectionItemsJsondeleteCollectionItemsXml Method for UserGroupDeleteCollectionItemsJsondeleteCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserGroupDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest
*/
func (a *ManagementAPIService) UserGroupDeleteCollectionItemsJsondeleteCollectionItemsXml(ctx context.Context, property string, uid string) ApiUserGroupDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	return ApiUserGroupDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserGroupDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r ApiUserGroupDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupDeleteCollectionItemsJsondeleteCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGroupDeleteObjectRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	uid        string
}

func (r ApiUserGroupDeleteObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserGroupDeleteObjectExecute(r)
}

/*
UserGroupDeleteObject Method for UserGroupDeleteObject

Deletes the UserGroup provided by ID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserGroupDeleteObjectRequest
*/
func (a *ManagementAPIService) UserGroupDeleteObject(ctx context.Context, uid string) ApiUserGroupDeleteObjectRequest {
	return ApiUserGroupDeleteObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserGroupDeleteObjectExecute(r ApiUserGroupDeleteObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupDeleteObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGroupGetObjectRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	uid          string
	fields       *[]string
	filter       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiUserGroupGetObjectRequest) Fields(fields []string) ApiUserGroupGetObjectRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiUserGroupGetObjectRequest) Filter(filter []string) ApiUserGroupGetObjectRequest {
	r.filter = &filter
	return r
}

// Defines which page number to return.
func (r ApiUserGroupGetObjectRequest) Page(page int32) ApiUserGroupGetObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiUserGroupGetObjectRequest) PageSize(pageSize int32) ApiUserGroupGetObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiUserGroupGetObjectRequest) Paging(paging bool) ApiUserGroupGetObjectRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiUserGroupGetObjectRequest) RootJunction(rootJunction string) ApiUserGroupGetObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiUserGroupGetObjectRequest) Execute() (*UserGroup, *http.Response, error) {
	return r.ApiService.UserGroupGetObjectExecute(r)
}

/*
UserGroupGetObject Method for UserGroupGetObject

View a UserGroup

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserGroupGetObjectRequest
*/
func (a *ManagementAPIService) UserGroupGetObject(ctx context.Context, uid string) ApiUserGroupGetObjectRequest {
	return ApiUserGroupGetObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return UserGroup
func (a *ManagementAPIService) UserGroupGetObjectExecute(r ApiUserGroupGetObjectRequest) (*UserGroup, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupGetObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGroupGetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiUserGroupGetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiUserGroupGetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiUserGroupGetObjectGistAsCsvRequest) Auto(auto string) ApiUserGroupGetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiUserGroupGetObjectGistAsCsvRequest) Describe(describe bool) ApiUserGroupGetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiUserGroupGetObjectGistAsCsvRequest) Fields(fields string) ApiUserGroupGetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiUserGroupGetObjectGistAsCsvRequest) Filter(filter string) ApiUserGroupGetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiUserGroupGetObjectGistAsCsvRequest) Headless(headless bool) ApiUserGroupGetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiUserGroupGetObjectGistAsCsvRequest) Inverse(inverse bool) ApiUserGroupGetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiUserGroupGetObjectGistAsCsvRequest) Locale(locale string) ApiUserGroupGetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiUserGroupGetObjectGistAsCsvRequest) Order(order string) ApiUserGroupGetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiUserGroupGetObjectGistAsCsvRequest) Page(page int32) ApiUserGroupGetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiUserGroupGetObjectGistAsCsvRequest) PageListName(pageListName string) ApiUserGroupGetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiUserGroupGetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiUserGroupGetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiUserGroupGetObjectGistAsCsvRequest) References(references bool) ApiUserGroupGetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiUserGroupGetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiUserGroupGetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiUserGroupGetObjectGistAsCsvRequest) Total(total bool) ApiUserGroupGetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiUserGroupGetObjectGistAsCsvRequest) Translate(translate bool) ApiUserGroupGetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiUserGroupGetObjectGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.UserGroupGetObjectGistAsCsvExecute(r)
}

/*
UserGroupGetObjectGistAsCsv Method for UserGroupGetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserGroupGetObjectGistAsCsvRequest
*/
func (a *ManagementAPIService) UserGroupGetObjectGistAsCsv(ctx context.Context, uid string) ApiUserGroupGetObjectGistAsCsvRequest {
	return ApiUserGroupGetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *ManagementAPIService) UserGroupGetObjectGistAsCsvExecute(r ApiUserGroupGetObjectGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupGetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/{uid}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest) Auto(auto string) ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest) Describe(describe bool) ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest) Fields(fields string) ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest) Filter(filter string) ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest) Headless(headless bool) ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest) Inverse(inverse bool) ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest) Locale(locale string) ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest) Order(order string) ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest) Page(page int32) ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest) PageListName(pageListName string) ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest) References(references bool) ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest) Total(total bool) ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest) Translate(translate bool) ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UserGroupGetObjectGistgetObjectGistAsCsvExecute(r)
}

/*
UserGroupGetObjectGistgetObjectGistAsCsv Method for UserGroupGetObjectGistgetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest
*/
func (a *ManagementAPIService) UserGroupGetObjectGistgetObjectGistAsCsv(ctx context.Context, uid string) ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest {
	return ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ManagementAPIService) UserGroupGetObjectGistgetObjectGistAsCsvExecute(r ApiUserGroupGetObjectGistgetObjectGistAsCsvRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupGetObjectGistgetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/{uid}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGroupGetObjectListRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	fields       *[]string
	filter       *[]string
	orders       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// &#x60;&lt;field-name&gt;[,&lt;field-name&gt;...]&#x60;
func (r ApiUserGroupGetObjectListRequest) Fields(fields []string) ApiUserGroupGetObjectListRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiUserGroupGetObjectListRequest) Filter(filter []string) ApiUserGroupGetObjectListRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiUserGroupGetObjectListRequest) Orders(orders []string) ApiUserGroupGetObjectListRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiUserGroupGetObjectListRequest) Page(page int32) ApiUserGroupGetObjectListRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiUserGroupGetObjectListRequest) PageSize(pageSize int32) ApiUserGroupGetObjectListRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiUserGroupGetObjectListRequest) Paging(paging bool) ApiUserGroupGetObjectListRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiUserGroupGetObjectListRequest) RootJunction(rootJunction string) ApiUserGroupGetObjectListRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiUserGroupGetObjectListRequest) Execute() (*UserGroupGetObjectList200Response, *http.Response, error) {
	return r.ApiService.UserGroupGetObjectListExecute(r)
}

/*
UserGroupGetObjectList Method for UserGroupGetObjectList

List all UserGroups

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUserGroupGetObjectListRequest
*/
func (a *ManagementAPIService) UserGroupGetObjectList(ctx context.Context) ApiUserGroupGetObjectListRequest {
	return ApiUserGroupGetObjectListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserGroupGetObjectList200Response
func (a *ManagementAPIService) UserGroupGetObjectListExecute(r ApiUserGroupGetObjectListRequest) (*UserGroupGetObjectList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserGroupGetObjectList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupGetObjectList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGroupGetObjectListCsvRequest struct {
	ctx            context.Context
	ApiService     *ManagementAPIService
	arraySeparator *string
	fields         *[]string
	filter         *[]string
	orders         *[]string
	page           *int32
	pageSize       *int32
	paging         *bool
	rootJunction   *string
	separator      *string
	skipHeader     *bool
}

// [no description yet]
func (r ApiUserGroupGetObjectListCsvRequest) ArraySeparator(arraySeparator string) ApiUserGroupGetObjectListCsvRequest {
	r.arraySeparator = &arraySeparator
	return r
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiUserGroupGetObjectListCsvRequest) Fields(fields []string) ApiUserGroupGetObjectListCsvRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiUserGroupGetObjectListCsvRequest) Filter(filter []string) ApiUserGroupGetObjectListCsvRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiUserGroupGetObjectListCsvRequest) Orders(orders []string) ApiUserGroupGetObjectListCsvRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiUserGroupGetObjectListCsvRequest) Page(page int32) ApiUserGroupGetObjectListCsvRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiUserGroupGetObjectListCsvRequest) PageSize(pageSize int32) ApiUserGroupGetObjectListCsvRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiUserGroupGetObjectListCsvRequest) Paging(paging bool) ApiUserGroupGetObjectListCsvRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiUserGroupGetObjectListCsvRequest) RootJunction(rootJunction string) ApiUserGroupGetObjectListCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiUserGroupGetObjectListCsvRequest) Separator(separator string) ApiUserGroupGetObjectListCsvRequest {
	r.separator = &separator
	return r
}

// [no description yet]
func (r ApiUserGroupGetObjectListCsvRequest) SkipHeader(skipHeader bool) ApiUserGroupGetObjectListCsvRequest {
	r.skipHeader = &skipHeader
	return r
}

func (r ApiUserGroupGetObjectListCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.UserGroupGetObjectListCsvExecute(r)
}

/*
UserGroupGetObjectListCsv Method for UserGroupGetObjectListCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUserGroupGetObjectListCsvRequest
*/
func (a *ManagementAPIService) UserGroupGetObjectListCsv(ctx context.Context) ApiUserGroupGetObjectListCsvRequest {
	return ApiUserGroupGetObjectListCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *ManagementAPIService) UserGroupGetObjectListCsvExecute(r ApiUserGroupGetObjectListCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupGetObjectListCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/#getObjectListCsv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.arraySeparator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arraySeparator", r.arraySeparator, "")
	} else {
		var defaultValue string = ";"
		r.arraySeparator = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.separator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "separator", r.separator, "")
	} else {
		var defaultValue string = ","
		r.separator = &defaultValue
	}
	if r.skipHeader != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipHeader", r.skipHeader, "")
	} else {
		var defaultValue bool = false
		r.skipHeader = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/text", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGroupGetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiUserGroupGetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiUserGroupGetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiUserGroupGetObjectListGistAsCsvRequest) Auto(auto string) ApiUserGroupGetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiUserGroupGetObjectListGistAsCsvRequest) Describe(describe bool) ApiUserGroupGetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiUserGroupGetObjectListGistAsCsvRequest) Fields(fields string) ApiUserGroupGetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiUserGroupGetObjectListGistAsCsvRequest) Filter(filter string) ApiUserGroupGetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiUserGroupGetObjectListGistAsCsvRequest) Headless(headless bool) ApiUserGroupGetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiUserGroupGetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiUserGroupGetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiUserGroupGetObjectListGistAsCsvRequest) Locale(locale string) ApiUserGroupGetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiUserGroupGetObjectListGistAsCsvRequest) Order(order string) ApiUserGroupGetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiUserGroupGetObjectListGistAsCsvRequest) Page(page int32) ApiUserGroupGetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiUserGroupGetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiUserGroupGetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiUserGroupGetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiUserGroupGetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiUserGroupGetObjectListGistAsCsvRequest) References(references bool) ApiUserGroupGetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiUserGroupGetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiUserGroupGetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiUserGroupGetObjectListGistAsCsvRequest) Total(total bool) ApiUserGroupGetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiUserGroupGetObjectListGistAsCsvRequest) Translate(translate bool) ApiUserGroupGetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiUserGroupGetObjectListGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.UserGroupGetObjectListGistAsCsvExecute(r)
}

/*
UserGroupGetObjectListGistAsCsv Method for UserGroupGetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUserGroupGetObjectListGistAsCsvRequest
*/
func (a *ManagementAPIService) UserGroupGetObjectListGistAsCsv(ctx context.Context) ApiUserGroupGetObjectListGistAsCsvRequest {
	return ApiUserGroupGetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *ManagementAPIService) UserGroupGetObjectListGistAsCsvExecute(r ApiUserGroupGetObjectListGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupGetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/gist.csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest) Auto(auto string) ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest) Describe(describe bool) ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest) Fields(fields string) ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest) Filter(filter string) ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest) Headless(headless bool) ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest) Locale(locale string) ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest) Order(order string) ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest) Page(page int32) ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest) References(references bool) ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest) Total(total bool) ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest) Translate(translate bool) ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest) Execute() (*UserGroupGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.UserGroupGetObjectListGistgetObjectListGistAsCsvExecute(r)
}

/*
UserGroupGetObjectListGistgetObjectListGistAsCsv Method for UserGroupGetObjectListGistgetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest
*/
func (a *ManagementAPIService) UserGroupGetObjectListGistgetObjectListGistAsCsv(ctx context.Context) ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest {
	return ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserGroupGetObjectListGistGetObjectListGistAsCsv200Response
func (a *ManagementAPIService) UserGroupGetObjectListGistgetObjectListGistAsCsvExecute(r ApiUserGroupGetObjectListGistgetObjectListGistAsCsvRequest) (*UserGroupGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserGroupGetObjectListGistGetObjectListGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupGetObjectListGistgetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/gist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGroupGetObjectPropertyRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	property     string
	uid          string
	fields       *[]string
	locale       *string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
	translate    *bool
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiUserGroupGetObjectPropertyRequest) Fields(fields []string) ApiUserGroupGetObjectPropertyRequest {
	r.fields = &fields
	return r
}

// [no description yet]
func (r ApiUserGroupGetObjectPropertyRequest) Locale(locale string) ApiUserGroupGetObjectPropertyRequest {
	r.locale = &locale
	return r
}

// Defines which page number to return.
func (r ApiUserGroupGetObjectPropertyRequest) Page(page int32) ApiUserGroupGetObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiUserGroupGetObjectPropertyRequest) PageSize(pageSize int32) ApiUserGroupGetObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiUserGroupGetObjectPropertyRequest) Paging(paging bool) ApiUserGroupGetObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiUserGroupGetObjectPropertyRequest) RootJunction(rootJunction string) ApiUserGroupGetObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiUserGroupGetObjectPropertyRequest) Translate(translate bool) ApiUserGroupGetObjectPropertyRequest {
	r.translate = &translate
	return r
}

func (r ApiUserGroupGetObjectPropertyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UserGroupGetObjectPropertyExecute(r)
}

/*
UserGroupGetObjectProperty Method for UserGroupGetObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserGroupGetObjectPropertyRequest
*/
func (a *ManagementAPIService) UserGroupGetObjectProperty(ctx context.Context, property string, uid string) ApiUserGroupGetObjectPropertyRequest {
	return ApiUserGroupGetObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ManagementAPIService) UserGroupGetObjectPropertyExecute(r ApiUserGroupGetObjectPropertyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupGetObjectProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGroupGetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiUserGroupGetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiUserGroupGetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiUserGroupGetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiUserGroupGetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiUserGroupGetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiUserGroupGetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiUserGroupGetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiUserGroupGetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiUserGroupGetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiUserGroupGetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiUserGroupGetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiUserGroupGetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiUserGroupGetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiUserGroupGetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiUserGroupGetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiUserGroupGetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiUserGroupGetObjectPropertyGistAsCsvRequest) Order(order string) ApiUserGroupGetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiUserGroupGetObjectPropertyGistAsCsvRequest) Page(page int32) ApiUserGroupGetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiUserGroupGetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiUserGroupGetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiUserGroupGetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiUserGroupGetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiUserGroupGetObjectPropertyGistAsCsvRequest) References(references bool) ApiUserGroupGetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiUserGroupGetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiUserGroupGetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiUserGroupGetObjectPropertyGistAsCsvRequest) Total(total bool) ApiUserGroupGetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiUserGroupGetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiUserGroupGetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiUserGroupGetObjectPropertyGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.UserGroupGetObjectPropertyGistAsCsvExecute(r)
}

/*
UserGroupGetObjectPropertyGistAsCsv Method for UserGroupGetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserGroupGetObjectPropertyGistAsCsvRequest
*/
func (a *ManagementAPIService) UserGroupGetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiUserGroupGetObjectPropertyGistAsCsvRequest {
	return ApiUserGroupGetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *ManagementAPIService) UserGroupGetObjectPropertyGistAsCsvExecute(r ApiUserGroupGetObjectPropertyGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupGetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/{uid}/{property}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Order(order string) ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Page(page int32) ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) References(references bool) ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Total(total bool) ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Execute() (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.UserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r)
}

/*
UserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsv Method for UserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest
*/
func (a *ManagementAPIService) UserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	return ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
func (a *ManagementAPIService) UserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r ApiUserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupGetObjectPropertyGistgetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/{uid}/{property}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGroupPatchObjectRequest struct {
	ctx                context.Context
	ApiService         *ManagementAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	jsonPatch          *JsonPatch
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiUserGroupPatchObjectRequest) AtomicMode(atomicMode string) ApiUserGroupPatchObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiUserGroupPatchObjectRequest) FlushMode(flushMode string) ApiUserGroupPatchObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiUserGroupPatchObjectRequest) Identifier(identifier string) ApiUserGroupPatchObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiUserGroupPatchObjectRequest) ImportMode(importMode string) ApiUserGroupPatchObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiUserGroupPatchObjectRequest) ImportReportMode(importReportMode string) ApiUserGroupPatchObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiUserGroupPatchObjectRequest) ImportStrategy(importStrategy string) ApiUserGroupPatchObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiUserGroupPatchObjectRequest) MergeMode(mergeMode string) ApiUserGroupPatchObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiUserGroupPatchObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiUserGroupPatchObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiUserGroupPatchObjectRequest) Page(page int32) ApiUserGroupPatchObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiUserGroupPatchObjectRequest) PageSize(pageSize int32) ApiUserGroupPatchObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiUserGroupPatchObjectRequest) Paging(paging bool) ApiUserGroupPatchObjectRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiUserGroupPatchObjectRequest) PreheatMode(preheatMode string) ApiUserGroupPatchObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiUserGroupPatchObjectRequest) RootJunction(rootJunction string) ApiUserGroupPatchObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiUserGroupPatchObjectRequest) SkipSharing(skipSharing bool) ApiUserGroupPatchObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiUserGroupPatchObjectRequest) SkipTranslation(skipTranslation bool) ApiUserGroupPatchObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiUserGroupPatchObjectRequest) SkipValidation(skipValidation bool) ApiUserGroupPatchObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiUserGroupPatchObjectRequest) UserOverrideMode(userOverrideMode string) ApiUserGroupPatchObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiUserGroupPatchObjectRequest) JsonPatch(jsonPatch JsonPatch) ApiUserGroupPatchObjectRequest {
	r.jsonPatch = &jsonPatch
	return r
}

func (r ApiUserGroupPatchObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserGroupPatchObjectExecute(r)
}

/*
UserGroupPatchObject Method for UserGroupPatchObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserGroupPatchObjectRequest
*/
func (a *ManagementAPIService) UserGroupPatchObject(ctx context.Context, uid string) ApiUserGroupPatchObjectRequest {
	return ApiUserGroupPatchObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserGroupPatchObjectExecute(r ApiUserGroupPatchObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupPatchObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGroupPostJsonObjectpostXmlObjectRequest struct {
	ctx                context.Context
	ApiService         *ManagementAPIService
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	preheatMode        *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	userGroup          *UserGroup
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiUserGroupPostJsonObjectpostXmlObjectRequest) AtomicMode(atomicMode string) ApiUserGroupPostJsonObjectpostXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiUserGroupPostJsonObjectpostXmlObjectRequest) FlushMode(flushMode string) ApiUserGroupPostJsonObjectpostXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiUserGroupPostJsonObjectpostXmlObjectRequest) Identifier(identifier string) ApiUserGroupPostJsonObjectpostXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiUserGroupPostJsonObjectpostXmlObjectRequest) ImportMode(importMode string) ApiUserGroupPostJsonObjectpostXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiUserGroupPostJsonObjectpostXmlObjectRequest) ImportReportMode(importReportMode string) ApiUserGroupPostJsonObjectpostXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiUserGroupPostJsonObjectpostXmlObjectRequest) ImportStrategy(importStrategy string) ApiUserGroupPostJsonObjectpostXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiUserGroupPostJsonObjectpostXmlObjectRequest) MergeMode(mergeMode string) ApiUserGroupPostJsonObjectpostXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiUserGroupPostJsonObjectpostXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiUserGroupPostJsonObjectpostXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiUserGroupPostJsonObjectpostXmlObjectRequest) PreheatMode(preheatMode string) ApiUserGroupPostJsonObjectpostXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiUserGroupPostJsonObjectpostXmlObjectRequest) SkipSharing(skipSharing bool) ApiUserGroupPostJsonObjectpostXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiUserGroupPostJsonObjectpostXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiUserGroupPostJsonObjectpostXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiUserGroupPostJsonObjectpostXmlObjectRequest) SkipValidation(skipValidation bool) ApiUserGroupPostJsonObjectpostXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiUserGroupPostJsonObjectpostXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiUserGroupPostJsonObjectpostXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiUserGroupPostJsonObjectpostXmlObjectRequest) UserGroup(userGroup UserGroup) ApiUserGroupPostJsonObjectpostXmlObjectRequest {
	r.userGroup = &userGroup
	return r
}

func (r ApiUserGroupPostJsonObjectpostXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserGroupPostJsonObjectpostXmlObjectExecute(r)
}

/*
UserGroupPostJsonObjectpostXmlObject Method for UserGroupPostJsonObjectpostXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUserGroupPostJsonObjectpostXmlObjectRequest
*/
func (a *ManagementAPIService) UserGroupPostJsonObjectpostXmlObject(ctx context.Context) ApiUserGroupPostJsonObjectpostXmlObjectRequest {
	return ApiUserGroupPostJsonObjectpostXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserGroupPostJsonObjectpostXmlObjectExecute(r ApiUserGroupPostJsonObjectpostXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupPostJsonObjectpostXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGroupPutJsonObjectputXmlObjectRequest struct {
	ctx                context.Context
	ApiService         *ManagementAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	preheatMode        *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	userGroup          *UserGroup
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiUserGroupPutJsonObjectputXmlObjectRequest) AtomicMode(atomicMode string) ApiUserGroupPutJsonObjectputXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiUserGroupPutJsonObjectputXmlObjectRequest) FlushMode(flushMode string) ApiUserGroupPutJsonObjectputXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiUserGroupPutJsonObjectputXmlObjectRequest) Identifier(identifier string) ApiUserGroupPutJsonObjectputXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiUserGroupPutJsonObjectputXmlObjectRequest) ImportMode(importMode string) ApiUserGroupPutJsonObjectputXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiUserGroupPutJsonObjectputXmlObjectRequest) ImportReportMode(importReportMode string) ApiUserGroupPutJsonObjectputXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiUserGroupPutJsonObjectputXmlObjectRequest) ImportStrategy(importStrategy string) ApiUserGroupPutJsonObjectputXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiUserGroupPutJsonObjectputXmlObjectRequest) MergeMode(mergeMode string) ApiUserGroupPutJsonObjectputXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiUserGroupPutJsonObjectputXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiUserGroupPutJsonObjectputXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiUserGroupPutJsonObjectputXmlObjectRequest) PreheatMode(preheatMode string) ApiUserGroupPutJsonObjectputXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiUserGroupPutJsonObjectputXmlObjectRequest) SkipSharing(skipSharing bool) ApiUserGroupPutJsonObjectputXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiUserGroupPutJsonObjectputXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiUserGroupPutJsonObjectputXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiUserGroupPutJsonObjectputXmlObjectRequest) SkipValidation(skipValidation bool) ApiUserGroupPutJsonObjectputXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiUserGroupPutJsonObjectputXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiUserGroupPutJsonObjectputXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiUserGroupPutJsonObjectputXmlObjectRequest) UserGroup(userGroup UserGroup) ApiUserGroupPutJsonObjectputXmlObjectRequest {
	r.userGroup = &userGroup
	return r
}

func (r ApiUserGroupPutJsonObjectputXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserGroupPutJsonObjectputXmlObjectExecute(r)
}

/*
UserGroupPutJsonObjectputXmlObject Method for UserGroupPutJsonObjectputXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserGroupPutJsonObjectputXmlObjectRequest
*/
func (a *ManagementAPIService) UserGroupPutJsonObjectputXmlObject(ctx context.Context, uid string) ApiUserGroupPutJsonObjectputXmlObjectRequest {
	return ApiUserGroupPutJsonObjectputXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserGroupPutJsonObjectputXmlObjectExecute(r ApiUserGroupPutJsonObjectputXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupPutJsonObjectputXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGroupRemoveAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	uid        string
}

func (r ApiUserGroupRemoveAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserGroupRemoveAsFavoriteExecute(r)
}

/*
UserGroupRemoveAsFavorite Method for UserGroupRemoveAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserGroupRemoveAsFavoriteRequest
*/
func (a *ManagementAPIService) UserGroupRemoveAsFavorite(ctx context.Context, uid string) ApiUserGroupRemoveAsFavoriteRequest {
	return ApiUserGroupRemoveAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserGroupRemoveAsFavoriteExecute(r ApiUserGroupRemoveAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupRemoveAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGroupReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *ManagementAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiUserGroupReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiUserGroupReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiUserGroupReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserGroupReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r)
}

/*
UserGroupReplaceCollectionItemsJsonreplaceCollectionItemsXml Method for UserGroupReplaceCollectionItemsJsonreplaceCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserGroupReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest
*/
func (a *ManagementAPIService) UserGroupReplaceCollectionItemsJsonreplaceCollectionItemsXml(ctx context.Context, property string, uid string) ApiUserGroupReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	return ApiUserGroupReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserGroupReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r ApiUserGroupReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupReplaceCollectionItemsJsonreplaceCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGroupReplaceTranslationsRequest struct {
	ctx                                             context.Context
	ApiService                                      *ManagementAPIService
	uid                                             string
	aggregateDataExchangeReplaceTranslationsRequest *AggregateDataExchangeReplaceTranslationsRequest
}

// [no description yet]
func (r ApiUserGroupReplaceTranslationsRequest) AggregateDataExchangeReplaceTranslationsRequest(aggregateDataExchangeReplaceTranslationsRequest AggregateDataExchangeReplaceTranslationsRequest) ApiUserGroupReplaceTranslationsRequest {
	r.aggregateDataExchangeReplaceTranslationsRequest = &aggregateDataExchangeReplaceTranslationsRequest
	return r
}

func (r ApiUserGroupReplaceTranslationsRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserGroupReplaceTranslationsExecute(r)
}

/*
UserGroupReplaceTranslations Method for UserGroupReplaceTranslations

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserGroupReplaceTranslationsRequest
*/
func (a *ManagementAPIService) UserGroupReplaceTranslations(ctx context.Context, uid string) ApiUserGroupReplaceTranslationsRequest {
	return ApiUserGroupReplaceTranslationsRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *ManagementAPIService) UserGroupReplaceTranslationsExecute(r ApiUserGroupReplaceTranslationsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupReplaceTranslations")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/{uid}/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateDataExchangeReplaceTranslationsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserGroupSetAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	uid        string
}

func (r ApiUserGroupSetAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserGroupSetAsFavoriteExecute(r)
}

/*
UserGroupSetAsFavorite Method for UserGroupSetAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserGroupSetAsFavoriteRequest
*/
func (a *ManagementAPIService) UserGroupSetAsFavorite(ctx context.Context, uid string) ApiUserGroupSetAsFavoriteRequest {
	return ApiUserGroupSetAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserGroupSetAsFavoriteExecute(r ApiUserGroupSetAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupSetAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGroupSetSharingRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	uid        string
	sharing    *Sharing
}

// [no description yet]
func (r ApiUserGroupSetSharingRequest) Sharing(sharing Sharing) ApiUserGroupSetSharingRequest {
	r.sharing = &sharing
	return r
}

func (r ApiUserGroupSetSharingRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserGroupSetSharingExecute(r)
}

/*
UserGroupSetSharing Method for UserGroupSetSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserGroupSetSharingRequest
*/
func (a *ManagementAPIService) UserGroupSetSharing(ctx context.Context, uid string) ApiUserGroupSetSharingRequest {
	return ApiUserGroupSetSharingRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *ManagementAPIService) UserGroupSetSharingExecute(r ApiUserGroupSetSharingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupSetSharing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/{uid}/sharing"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharing
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserGroupSubscribeRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	uid        string
}

func (r ApiUserGroupSubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserGroupSubscribeExecute(r)
}

/*
UserGroupSubscribe Method for UserGroupSubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserGroupSubscribeRequest
*/
func (a *ManagementAPIService) UserGroupSubscribe(ctx context.Context, uid string) ApiUserGroupSubscribeRequest {
	return ApiUserGroupSubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserGroupSubscribeExecute(r ApiUserGroupSubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupSubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGroupUnsubscribeRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	uid        string
}

func (r ApiUserGroupUnsubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserGroupUnsubscribeExecute(r)
}

/*
UserGroupUnsubscribe Method for UserGroupUnsubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserGroupUnsubscribeRequest
*/
func (a *ManagementAPIService) UserGroupUnsubscribe(ctx context.Context, uid string) ApiUserGroupUnsubscribeRequest {
	return ApiUserGroupUnsubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserGroupUnsubscribeExecute(r ApiUserGroupUnsubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupUnsubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGroupUpdateObjectPropertyRequest struct {
	ctx                context.Context
	ApiService         *ManagementAPIService
	property           string
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	userGroup          *UserGroup
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiUserGroupUpdateObjectPropertyRequest) AtomicMode(atomicMode string) ApiUserGroupUpdateObjectPropertyRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiUserGroupUpdateObjectPropertyRequest) FlushMode(flushMode string) ApiUserGroupUpdateObjectPropertyRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiUserGroupUpdateObjectPropertyRequest) Identifier(identifier string) ApiUserGroupUpdateObjectPropertyRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiUserGroupUpdateObjectPropertyRequest) ImportMode(importMode string) ApiUserGroupUpdateObjectPropertyRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiUserGroupUpdateObjectPropertyRequest) ImportReportMode(importReportMode string) ApiUserGroupUpdateObjectPropertyRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiUserGroupUpdateObjectPropertyRequest) ImportStrategy(importStrategy string) ApiUserGroupUpdateObjectPropertyRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiUserGroupUpdateObjectPropertyRequest) MergeMode(mergeMode string) ApiUserGroupUpdateObjectPropertyRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiUserGroupUpdateObjectPropertyRequest) MetadataSyncImport(metadataSyncImport bool) ApiUserGroupUpdateObjectPropertyRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiUserGroupUpdateObjectPropertyRequest) Page(page int32) ApiUserGroupUpdateObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiUserGroupUpdateObjectPropertyRequest) PageSize(pageSize int32) ApiUserGroupUpdateObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiUserGroupUpdateObjectPropertyRequest) Paging(paging bool) ApiUserGroupUpdateObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiUserGroupUpdateObjectPropertyRequest) PreheatMode(preheatMode string) ApiUserGroupUpdateObjectPropertyRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiUserGroupUpdateObjectPropertyRequest) RootJunction(rootJunction string) ApiUserGroupUpdateObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiUserGroupUpdateObjectPropertyRequest) SkipSharing(skipSharing bool) ApiUserGroupUpdateObjectPropertyRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiUserGroupUpdateObjectPropertyRequest) SkipTranslation(skipTranslation bool) ApiUserGroupUpdateObjectPropertyRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiUserGroupUpdateObjectPropertyRequest) SkipValidation(skipValidation bool) ApiUserGroupUpdateObjectPropertyRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiUserGroupUpdateObjectPropertyRequest) UserOverrideMode(userOverrideMode string) ApiUserGroupUpdateObjectPropertyRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiUserGroupUpdateObjectPropertyRequest) UserGroup(userGroup UserGroup) ApiUserGroupUpdateObjectPropertyRequest {
	r.userGroup = &userGroup
	return r
}

func (r ApiUserGroupUpdateObjectPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserGroupUpdateObjectPropertyExecute(r)
}

/*
UserGroupUpdateObjectProperty Method for UserGroupUpdateObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserGroupUpdateObjectPropertyRequest
*/
func (a *ManagementAPIService) UserGroupUpdateObjectProperty(ctx context.Context, property string, uid string) ApiUserGroupUpdateObjectPropertyRequest {
	return ApiUserGroupUpdateObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
func (a *ManagementAPIService) UserGroupUpdateObjectPropertyExecute(r ApiUserGroupUpdateObjectPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserGroupUpdateObjectProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userGroups/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserPatchObjectRequest struct {
	ctx                context.Context
	ApiService         *ManagementAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	jsonPatch          *JsonPatch
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiUserPatchObjectRequest) AtomicMode(atomicMode string) ApiUserPatchObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiUserPatchObjectRequest) FlushMode(flushMode string) ApiUserPatchObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiUserPatchObjectRequest) Identifier(identifier string) ApiUserPatchObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiUserPatchObjectRequest) ImportMode(importMode string) ApiUserPatchObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiUserPatchObjectRequest) ImportReportMode(importReportMode string) ApiUserPatchObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiUserPatchObjectRequest) ImportStrategy(importStrategy string) ApiUserPatchObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiUserPatchObjectRequest) MergeMode(mergeMode string) ApiUserPatchObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiUserPatchObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiUserPatchObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiUserPatchObjectRequest) Page(page int32) ApiUserPatchObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiUserPatchObjectRequest) PageSize(pageSize int32) ApiUserPatchObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiUserPatchObjectRequest) Paging(paging bool) ApiUserPatchObjectRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiUserPatchObjectRequest) PreheatMode(preheatMode string) ApiUserPatchObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiUserPatchObjectRequest) RootJunction(rootJunction string) ApiUserPatchObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiUserPatchObjectRequest) SkipSharing(skipSharing bool) ApiUserPatchObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiUserPatchObjectRequest) SkipTranslation(skipTranslation bool) ApiUserPatchObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiUserPatchObjectRequest) SkipValidation(skipValidation bool) ApiUserPatchObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiUserPatchObjectRequest) UserOverrideMode(userOverrideMode string) ApiUserPatchObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiUserPatchObjectRequest) JsonPatch(jsonPatch JsonPatch) ApiUserPatchObjectRequest {
	r.jsonPatch = &jsonPatch
	return r
}

func (r ApiUserPatchObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserPatchObjectExecute(r)
}

/*
UserPatchObject Method for UserPatchObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserPatchObjectRequest
*/
func (a *ManagementAPIService) UserPatchObject(ctx context.Context, uid string) ApiUserPatchObjectRequest {
	return ApiUserPatchObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserPatchObjectExecute(r ApiUserPatchObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserPatchObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserPostJsonInvitepostXmlInviteRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
}

func (r ApiUserPostJsonInvitepostXmlInviteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserPostJsonInvitepostXmlInviteExecute(r)
}

/*
UserPostJsonInvitepostXmlInvite Method for UserPostJsonInvitepostXmlInvite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUserPostJsonInvitepostXmlInviteRequest
*/
func (a *ManagementAPIService) UserPostJsonInvitepostXmlInvite(ctx context.Context) ApiUserPostJsonInvitepostXmlInviteRequest {
	return ApiUserPostJsonInvitepostXmlInviteRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserPostJsonInvitepostXmlInviteExecute(r ApiUserPostJsonInvitepostXmlInviteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserPostJsonInvitepostXmlInvite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/invite"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserPostJsonInvitespostXmlInvitesRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
}

func (r ApiUserPostJsonInvitespostXmlInvitesRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserPostJsonInvitespostXmlInvitesExecute(r)
}

/*
UserPostJsonInvitespostXmlInvites Method for UserPostJsonInvitespostXmlInvites

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUserPostJsonInvitespostXmlInvitesRequest
*/
func (a *ManagementAPIService) UserPostJsonInvitespostXmlInvites(ctx context.Context) ApiUserPostJsonInvitespostXmlInvitesRequest {
	return ApiUserPostJsonInvitespostXmlInvitesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ManagementAPIService) UserPostJsonInvitespostXmlInvitesExecute(r ApiUserPostJsonInvitespostXmlInvitesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserPostJsonInvitespostXmlInvites")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/invites"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest struct {
	ctx                context.Context
	ApiService         *ManagementAPIService
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	preheatMode        *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	user               *User
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest) AtomicMode(atomicMode string) ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest) FlushMode(flushMode string) ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest) Identifier(identifier string) ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest) ImportMode(importMode string) ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest) ImportReportMode(importReportMode string) ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest) ImportStrategy(importStrategy string) ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest) MergeMode(mergeMode string) ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest) PreheatMode(preheatMode string) ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest) SkipSharing(skipSharing bool) ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest) SkipValidation(skipValidation bool) ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest) User(user User) ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest {
	r.user = &user
	return r
}

func (r ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectExecute(r)
}

/*
UserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObject Method for UserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest
*/
func (a *ManagementAPIService) UserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObject(ctx context.Context) ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest {
	return ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectExecute(r ApiUserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserPostJsonObjectpostXmlObjectpostJsonObjectpostXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.user
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest struct {
	ctx                context.Context
	ApiService         *ManagementAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	preheatMode        *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	user               *User
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest) AtomicMode(atomicMode string) ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest) FlushMode(flushMode string) ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest) Identifier(identifier string) ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest) ImportMode(importMode string) ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest) ImportReportMode(importReportMode string) ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest) ImportStrategy(importStrategy string) ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest) MergeMode(mergeMode string) ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest) PreheatMode(preheatMode string) ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest) SkipSharing(skipSharing bool) ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest) SkipValidation(skipValidation bool) ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest) User(user User) ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest {
	r.user = &user
	return r
}

func (r ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectExecute(r)
}

/*
UserPutJsonObjectputXmlObjectputJsonObjectputXmlObject Method for UserPutJsonObjectputXmlObjectputJsonObjectputXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest
*/
func (a *ManagementAPIService) UserPutJsonObjectputXmlObjectputJsonObjectputXmlObject(ctx context.Context, uid string) ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest {
	return ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectExecute(r ApiUserPutJsonObjectputXmlObjectputJsonObjectputXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserPutJsonObjectputXmlObjectputJsonObjectputXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.user
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRemoveAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	uid        string
}

func (r ApiUserRemoveAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserRemoveAsFavoriteExecute(r)
}

/*
UserRemoveAsFavorite Method for UserRemoveAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserRemoveAsFavoriteRequest
*/
func (a *ManagementAPIService) UserRemoveAsFavorite(ctx context.Context, uid string) ApiUserRemoveAsFavoriteRequest {
	return ApiUserRemoveAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserRemoveAsFavoriteExecute(r ApiUserRemoveAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRemoveAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *ManagementAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiUserReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiUserReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiUserReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r)
}

/*
UserReplaceCollectionItemsJsonreplaceCollectionItemsXml Method for UserReplaceCollectionItemsJsonreplaceCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest
*/
func (a *ManagementAPIService) UserReplaceCollectionItemsJsonreplaceCollectionItemsXml(ctx context.Context, property string, uid string) ApiUserReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	return ApiUserReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r ApiUserReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserReplaceCollectionItemsJsonreplaceCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserReplaceTranslationsRequest struct {
	ctx                                             context.Context
	ApiService                                      *ManagementAPIService
	uid                                             string
	aggregateDataExchangeReplaceTranslationsRequest *AggregateDataExchangeReplaceTranslationsRequest
}

// [no description yet]
func (r ApiUserReplaceTranslationsRequest) AggregateDataExchangeReplaceTranslationsRequest(aggregateDataExchangeReplaceTranslationsRequest AggregateDataExchangeReplaceTranslationsRequest) ApiUserReplaceTranslationsRequest {
	r.aggregateDataExchangeReplaceTranslationsRequest = &aggregateDataExchangeReplaceTranslationsRequest
	return r
}

func (r ApiUserReplaceTranslationsRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserReplaceTranslationsExecute(r)
}

/*
UserReplaceTranslations Method for UserReplaceTranslations

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserReplaceTranslationsRequest
*/
func (a *ManagementAPIService) UserReplaceTranslations(ctx context.Context, uid string) ApiUserReplaceTranslationsRequest {
	return ApiUserReplaceTranslationsRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *ManagementAPIService) UserReplaceTranslationsExecute(r ApiUserReplaceTranslationsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserReplaceTranslations")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateDataExchangeReplaceTranslationsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserReplicateUserRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	uid        string
}

func (r ApiUserReplicateUserRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserReplicateUserExecute(r)
}

/*
UserReplicateUser Method for UserReplicateUser

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserReplicateUserRequest
*/
func (a *ManagementAPIService) UserReplicateUser(ctx context.Context, uid string) ApiUserReplicateUserRequest {
	return ApiUserReplicateUserRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserReplicateUserExecute(r ApiUserReplicateUserRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserReplicateUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}/replica"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserResendInviteRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	id         string
}

func (r ApiUserResendInviteRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserResendInviteExecute(r)
}

/*
UserResendInvite Method for UserResendInvite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id [no description yet]
	@return ApiUserResendInviteRequest
*/
func (a *ManagementAPIService) UserResendInvite(ctx context.Context, id string) ApiUserResendInviteRequest {
	return ApiUserResendInviteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *ManagementAPIService) UserResendInviteExecute(r ApiUserResendInviteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserResendInvite")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{id}/invite"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserResetToInviteRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	id         string
}

func (r ApiUserResetToInviteRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserResetToInviteExecute(r)
}

/*
UserResetToInvite Method for UserResetToInvite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id [no description yet]
	@return ApiUserResetToInviteRequest
*/
func (a *ManagementAPIService) UserResetToInvite(ctx context.Context, id string) ApiUserResetToInviteRequest {
	return ApiUserResetToInviteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *ManagementAPIService) UserResetToInviteExecute(r ApiUserResetToInviteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserResetToInvite")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{id}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserRoleAddCollectionItemRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiUserRoleAddCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserRoleAddCollectionItemExecute(r)
}

/*
UserRoleAddCollectionItem Method for UserRoleAddCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserRoleAddCollectionItemRequest
*/
func (a *ManagementAPIService) UserRoleAddCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiUserRoleAddCollectionItemRequest {
	return ApiUserRoleAddCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserRoleAddCollectionItemExecute(r ApiUserRoleAddCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleAddCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRoleAddCollectionItemsJsonaddCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *ManagementAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiUserRoleAddCollectionItemsJsonaddCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiUserRoleAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiUserRoleAddCollectionItemsJsonaddCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserRoleAddCollectionItemsJsonaddCollectionItemsXmlExecute(r)
}

/*
UserRoleAddCollectionItemsJsonaddCollectionItemsXml Method for UserRoleAddCollectionItemsJsonaddCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserRoleAddCollectionItemsJsonaddCollectionItemsXmlRequest
*/
func (a *ManagementAPIService) UserRoleAddCollectionItemsJsonaddCollectionItemsXml(ctx context.Context, property string, uid string) ApiUserRoleAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	return ApiUserRoleAddCollectionItemsJsonaddCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserRoleAddCollectionItemsJsonaddCollectionItemsXmlExecute(r ApiUserRoleAddCollectionItemsJsonaddCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleAddCollectionItemsJsonaddCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRoleAddUserToRoleRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	id         string
	userId     string
}

func (r ApiUserRoleAddUserToRoleRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserRoleAddUserToRoleExecute(r)
}

/*
UserRoleAddUserToRole Method for UserRoleAddUserToRole

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id [no description yet]
	@param userId [no description yet]
	@return ApiUserRoleAddUserToRoleRequest
*/
func (a *ManagementAPIService) UserRoleAddUserToRole(ctx context.Context, id string, userId string) ApiUserRoleAddUserToRoleRequest {
	return ApiUserRoleAddUserToRoleRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		userId:     userId,
	}
}

// Execute executes the request
func (a *ManagementAPIService) UserRoleAddUserToRoleExecute(r ApiUserRoleAddUserToRoleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleAddUserToRole")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/{id}/users/{userId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserRoleAddUserToRole2Request struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	id         string
	userId     string
}

func (r ApiUserRoleAddUserToRole2Request) Execute() (*http.Response, error) {
	return r.ApiService.UserRoleAddUserToRole2Execute(r)
}

/*
UserRoleAddUserToRole2 Method for UserRoleAddUserToRole2

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id [no description yet]
	@param userId [no description yet]
	@return ApiUserRoleAddUserToRole2Request
*/
func (a *ManagementAPIService) UserRoleAddUserToRole2(ctx context.Context, id string, userId string) ApiUserRoleAddUserToRole2Request {
	return ApiUserRoleAddUserToRole2Request{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		userId:     userId,
	}
}

// Execute executes the request
func (a *ManagementAPIService) UserRoleAddUserToRole2Execute(r ApiUserRoleAddUserToRole2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleAddUserToRole2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/{id}/users/{userId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserRoleBulkSharingRequest struct {
	ctx                context.Context
	ApiService         *ManagementAPIService
	atomic             *bool
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	bulkJsonPatch      *BulkJsonPatch
}

// [no description yet]
func (r ApiUserRoleBulkSharingRequest) Atomic(atomic bool) ApiUserRoleBulkSharingRequest {
	r.atomic = &atomic
	return r
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiUserRoleBulkSharingRequest) AtomicMode(atomicMode string) ApiUserRoleBulkSharingRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiUserRoleBulkSharingRequest) FlushMode(flushMode string) ApiUserRoleBulkSharingRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiUserRoleBulkSharingRequest) Identifier(identifier string) ApiUserRoleBulkSharingRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiUserRoleBulkSharingRequest) ImportMode(importMode string) ApiUserRoleBulkSharingRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiUserRoleBulkSharingRequest) ImportReportMode(importReportMode string) ApiUserRoleBulkSharingRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiUserRoleBulkSharingRequest) ImportStrategy(importStrategy string) ApiUserRoleBulkSharingRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiUserRoleBulkSharingRequest) MergeMode(mergeMode string) ApiUserRoleBulkSharingRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiUserRoleBulkSharingRequest) MetadataSyncImport(metadataSyncImport bool) ApiUserRoleBulkSharingRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiUserRoleBulkSharingRequest) Page(page int32) ApiUserRoleBulkSharingRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiUserRoleBulkSharingRequest) PageSize(pageSize int32) ApiUserRoleBulkSharingRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiUserRoleBulkSharingRequest) Paging(paging bool) ApiUserRoleBulkSharingRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiUserRoleBulkSharingRequest) PreheatMode(preheatMode string) ApiUserRoleBulkSharingRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiUserRoleBulkSharingRequest) RootJunction(rootJunction string) ApiUserRoleBulkSharingRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiUserRoleBulkSharingRequest) SkipSharing(skipSharing bool) ApiUserRoleBulkSharingRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiUserRoleBulkSharingRequest) SkipTranslation(skipTranslation bool) ApiUserRoleBulkSharingRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiUserRoleBulkSharingRequest) SkipValidation(skipValidation bool) ApiUserRoleBulkSharingRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiUserRoleBulkSharingRequest) UserOverrideMode(userOverrideMode string) ApiUserRoleBulkSharingRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiUserRoleBulkSharingRequest) BulkJsonPatch(bulkJsonPatch BulkJsonPatch) ApiUserRoleBulkSharingRequest {
	r.bulkJsonPatch = &bulkJsonPatch
	return r
}

func (r ApiUserRoleBulkSharingRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserRoleBulkSharingExecute(r)
}

/*
UserRoleBulkSharing Method for UserRoleBulkSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUserRoleBulkSharingRequest
*/
func (a *ManagementAPIService) UserRoleBulkSharing(ctx context.Context) ApiUserRoleBulkSharingRequest {
	return ApiUserRoleBulkSharingRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserRoleBulkSharingExecute(r ApiUserRoleBulkSharingRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleBulkSharing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/sharing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomic", r.atomic, "")
	} else {
		var defaultValue bool = false
		r.atomic = &defaultValue
	}
	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkJsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRoleDeleteCollectionItemRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiUserRoleDeleteCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserRoleDeleteCollectionItemExecute(r)
}

/*
UserRoleDeleteCollectionItem Method for UserRoleDeleteCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserRoleDeleteCollectionItemRequest
*/
func (a *ManagementAPIService) UserRoleDeleteCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiUserRoleDeleteCollectionItemRequest {
	return ApiUserRoleDeleteCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserRoleDeleteCollectionItemExecute(r ApiUserRoleDeleteCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleDeleteCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRoleDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *ManagementAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiUserRoleDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiUserRoleDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiUserRoleDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserRoleDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r)
}

/*
UserRoleDeleteCollectionItemsJsondeleteCollectionItemsXml Method for UserRoleDeleteCollectionItemsJsondeleteCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserRoleDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest
*/
func (a *ManagementAPIService) UserRoleDeleteCollectionItemsJsondeleteCollectionItemsXml(ctx context.Context, property string, uid string) ApiUserRoleDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	return ApiUserRoleDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserRoleDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r ApiUserRoleDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleDeleteCollectionItemsJsondeleteCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRoleDeleteObjectRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	uid        string
}

func (r ApiUserRoleDeleteObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserRoleDeleteObjectExecute(r)
}

/*
UserRoleDeleteObject Method for UserRoleDeleteObject

Deletes the UserRole provided by ID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserRoleDeleteObjectRequest
*/
func (a *ManagementAPIService) UserRoleDeleteObject(ctx context.Context, uid string) ApiUserRoleDeleteObjectRequest {
	return ApiUserRoleDeleteObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserRoleDeleteObjectExecute(r ApiUserRoleDeleteObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleDeleteObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRoleGetObjectRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	uid          string
	fields       *[]string
	filter       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiUserRoleGetObjectRequest) Fields(fields []string) ApiUserRoleGetObjectRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiUserRoleGetObjectRequest) Filter(filter []string) ApiUserRoleGetObjectRequest {
	r.filter = &filter
	return r
}

// Defines which page number to return.
func (r ApiUserRoleGetObjectRequest) Page(page int32) ApiUserRoleGetObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiUserRoleGetObjectRequest) PageSize(pageSize int32) ApiUserRoleGetObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiUserRoleGetObjectRequest) Paging(paging bool) ApiUserRoleGetObjectRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiUserRoleGetObjectRequest) RootJunction(rootJunction string) ApiUserRoleGetObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiUserRoleGetObjectRequest) Execute() (*UserRole, *http.Response, error) {
	return r.ApiService.UserRoleGetObjectExecute(r)
}

/*
UserRoleGetObject Method for UserRoleGetObject

View a UserRole

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserRoleGetObjectRequest
*/
func (a *ManagementAPIService) UserRoleGetObject(ctx context.Context, uid string) ApiUserRoleGetObjectRequest {
	return ApiUserRoleGetObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return UserRole
func (a *ManagementAPIService) UserRoleGetObjectExecute(r ApiUserRoleGetObjectRequest) (*UserRole, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleGetObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRoleGetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiUserRoleGetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiUserRoleGetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiUserRoleGetObjectGistAsCsvRequest) Auto(auto string) ApiUserRoleGetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiUserRoleGetObjectGistAsCsvRequest) Describe(describe bool) ApiUserRoleGetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiUserRoleGetObjectGistAsCsvRequest) Fields(fields string) ApiUserRoleGetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiUserRoleGetObjectGistAsCsvRequest) Filter(filter string) ApiUserRoleGetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiUserRoleGetObjectGistAsCsvRequest) Headless(headless bool) ApiUserRoleGetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiUserRoleGetObjectGistAsCsvRequest) Inverse(inverse bool) ApiUserRoleGetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiUserRoleGetObjectGistAsCsvRequest) Locale(locale string) ApiUserRoleGetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiUserRoleGetObjectGistAsCsvRequest) Order(order string) ApiUserRoleGetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiUserRoleGetObjectGistAsCsvRequest) Page(page int32) ApiUserRoleGetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiUserRoleGetObjectGistAsCsvRequest) PageListName(pageListName string) ApiUserRoleGetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiUserRoleGetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiUserRoleGetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiUserRoleGetObjectGistAsCsvRequest) References(references bool) ApiUserRoleGetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiUserRoleGetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiUserRoleGetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiUserRoleGetObjectGistAsCsvRequest) Total(total bool) ApiUserRoleGetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiUserRoleGetObjectGistAsCsvRequest) Translate(translate bool) ApiUserRoleGetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiUserRoleGetObjectGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.UserRoleGetObjectGistAsCsvExecute(r)
}

/*
UserRoleGetObjectGistAsCsv Method for UserRoleGetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserRoleGetObjectGistAsCsvRequest
*/
func (a *ManagementAPIService) UserRoleGetObjectGistAsCsv(ctx context.Context, uid string) ApiUserRoleGetObjectGistAsCsvRequest {
	return ApiUserRoleGetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *ManagementAPIService) UserRoleGetObjectGistAsCsvExecute(r ApiUserRoleGetObjectGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleGetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/{uid}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest) Auto(auto string) ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest) Describe(describe bool) ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest) Fields(fields string) ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest) Filter(filter string) ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest) Headless(headless bool) ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest) Inverse(inverse bool) ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest) Locale(locale string) ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest) Order(order string) ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest) Page(page int32) ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest) PageListName(pageListName string) ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest) References(references bool) ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest) Total(total bool) ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest) Translate(translate bool) ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UserRoleGetObjectGistgetObjectGistAsCsvExecute(r)
}

/*
UserRoleGetObjectGistgetObjectGistAsCsv Method for UserRoleGetObjectGistgetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest
*/
func (a *ManagementAPIService) UserRoleGetObjectGistgetObjectGistAsCsv(ctx context.Context, uid string) ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest {
	return ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ManagementAPIService) UserRoleGetObjectGistgetObjectGistAsCsvExecute(r ApiUserRoleGetObjectGistgetObjectGistAsCsvRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleGetObjectGistgetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/{uid}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRoleGetObjectListRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	fields       *[]string
	filter       *[]string
	orders       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// &#x60;&lt;field-name&gt;[,&lt;field-name&gt;...]&#x60;
func (r ApiUserRoleGetObjectListRequest) Fields(fields []string) ApiUserRoleGetObjectListRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiUserRoleGetObjectListRequest) Filter(filter []string) ApiUserRoleGetObjectListRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiUserRoleGetObjectListRequest) Orders(orders []string) ApiUserRoleGetObjectListRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiUserRoleGetObjectListRequest) Page(page int32) ApiUserRoleGetObjectListRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiUserRoleGetObjectListRequest) PageSize(pageSize int32) ApiUserRoleGetObjectListRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiUserRoleGetObjectListRequest) Paging(paging bool) ApiUserRoleGetObjectListRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiUserRoleGetObjectListRequest) RootJunction(rootJunction string) ApiUserRoleGetObjectListRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiUserRoleGetObjectListRequest) Execute() (*UserRoleGetObjectList200Response, *http.Response, error) {
	return r.ApiService.UserRoleGetObjectListExecute(r)
}

/*
UserRoleGetObjectList Method for UserRoleGetObjectList

List all UserRoles

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUserRoleGetObjectListRequest
*/
func (a *ManagementAPIService) UserRoleGetObjectList(ctx context.Context) ApiUserRoleGetObjectListRequest {
	return ApiUserRoleGetObjectListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserRoleGetObjectList200Response
func (a *ManagementAPIService) UserRoleGetObjectListExecute(r ApiUserRoleGetObjectListRequest) (*UserRoleGetObjectList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserRoleGetObjectList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleGetObjectList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRoleGetObjectListCsvRequest struct {
	ctx            context.Context
	ApiService     *ManagementAPIService
	arraySeparator *string
	fields         *[]string
	filter         *[]string
	orders         *[]string
	page           *int32
	pageSize       *int32
	paging         *bool
	rootJunction   *string
	separator      *string
	skipHeader     *bool
}

// [no description yet]
func (r ApiUserRoleGetObjectListCsvRequest) ArraySeparator(arraySeparator string) ApiUserRoleGetObjectListCsvRequest {
	r.arraySeparator = &arraySeparator
	return r
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiUserRoleGetObjectListCsvRequest) Fields(fields []string) ApiUserRoleGetObjectListCsvRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiUserRoleGetObjectListCsvRequest) Filter(filter []string) ApiUserRoleGetObjectListCsvRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiUserRoleGetObjectListCsvRequest) Orders(orders []string) ApiUserRoleGetObjectListCsvRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiUserRoleGetObjectListCsvRequest) Page(page int32) ApiUserRoleGetObjectListCsvRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiUserRoleGetObjectListCsvRequest) PageSize(pageSize int32) ApiUserRoleGetObjectListCsvRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiUserRoleGetObjectListCsvRequest) Paging(paging bool) ApiUserRoleGetObjectListCsvRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiUserRoleGetObjectListCsvRequest) RootJunction(rootJunction string) ApiUserRoleGetObjectListCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiUserRoleGetObjectListCsvRequest) Separator(separator string) ApiUserRoleGetObjectListCsvRequest {
	r.separator = &separator
	return r
}

// [no description yet]
func (r ApiUserRoleGetObjectListCsvRequest) SkipHeader(skipHeader bool) ApiUserRoleGetObjectListCsvRequest {
	r.skipHeader = &skipHeader
	return r
}

func (r ApiUserRoleGetObjectListCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.UserRoleGetObjectListCsvExecute(r)
}

/*
UserRoleGetObjectListCsv Method for UserRoleGetObjectListCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUserRoleGetObjectListCsvRequest
*/
func (a *ManagementAPIService) UserRoleGetObjectListCsv(ctx context.Context) ApiUserRoleGetObjectListCsvRequest {
	return ApiUserRoleGetObjectListCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *ManagementAPIService) UserRoleGetObjectListCsvExecute(r ApiUserRoleGetObjectListCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleGetObjectListCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/#getObjectListCsv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.arraySeparator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arraySeparator", r.arraySeparator, "")
	} else {
		var defaultValue string = ";"
		r.arraySeparator = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.separator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "separator", r.separator, "")
	} else {
		var defaultValue string = ","
		r.separator = &defaultValue
	}
	if r.skipHeader != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipHeader", r.skipHeader, "")
	} else {
		var defaultValue bool = false
		r.skipHeader = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/text", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRoleGetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiUserRoleGetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiUserRoleGetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiUserRoleGetObjectListGistAsCsvRequest) Auto(auto string) ApiUserRoleGetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiUserRoleGetObjectListGistAsCsvRequest) Describe(describe bool) ApiUserRoleGetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiUserRoleGetObjectListGistAsCsvRequest) Fields(fields string) ApiUserRoleGetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiUserRoleGetObjectListGistAsCsvRequest) Filter(filter string) ApiUserRoleGetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiUserRoleGetObjectListGistAsCsvRequest) Headless(headless bool) ApiUserRoleGetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiUserRoleGetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiUserRoleGetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiUserRoleGetObjectListGistAsCsvRequest) Locale(locale string) ApiUserRoleGetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiUserRoleGetObjectListGistAsCsvRequest) Order(order string) ApiUserRoleGetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiUserRoleGetObjectListGistAsCsvRequest) Page(page int32) ApiUserRoleGetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiUserRoleGetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiUserRoleGetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiUserRoleGetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiUserRoleGetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiUserRoleGetObjectListGistAsCsvRequest) References(references bool) ApiUserRoleGetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiUserRoleGetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiUserRoleGetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiUserRoleGetObjectListGistAsCsvRequest) Total(total bool) ApiUserRoleGetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiUserRoleGetObjectListGistAsCsvRequest) Translate(translate bool) ApiUserRoleGetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiUserRoleGetObjectListGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.UserRoleGetObjectListGistAsCsvExecute(r)
}

/*
UserRoleGetObjectListGistAsCsv Method for UserRoleGetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUserRoleGetObjectListGistAsCsvRequest
*/
func (a *ManagementAPIService) UserRoleGetObjectListGistAsCsv(ctx context.Context) ApiUserRoleGetObjectListGistAsCsvRequest {
	return ApiUserRoleGetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *ManagementAPIService) UserRoleGetObjectListGistAsCsvExecute(r ApiUserRoleGetObjectListGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleGetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/gist.csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest) Auto(auto string) ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest) Describe(describe bool) ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest) Fields(fields string) ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest) Filter(filter string) ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest) Headless(headless bool) ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest) Locale(locale string) ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest) Order(order string) ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest) Page(page int32) ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest) References(references bool) ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest) Total(total bool) ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest) Translate(translate bool) ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest) Execute() (*UserRoleGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.UserRoleGetObjectListGistgetObjectListGistAsCsvExecute(r)
}

/*
UserRoleGetObjectListGistgetObjectListGistAsCsv Method for UserRoleGetObjectListGistgetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest
*/
func (a *ManagementAPIService) UserRoleGetObjectListGistgetObjectListGistAsCsv(ctx context.Context) ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest {
	return ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserRoleGetObjectListGistGetObjectListGistAsCsv200Response
func (a *ManagementAPIService) UserRoleGetObjectListGistgetObjectListGistAsCsvExecute(r ApiUserRoleGetObjectListGistgetObjectListGistAsCsvRequest) (*UserRoleGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserRoleGetObjectListGistGetObjectListGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleGetObjectListGistgetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/gist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRoleGetObjectPropertyRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	property     string
	uid          string
	fields       *[]string
	locale       *string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
	translate    *bool
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiUserRoleGetObjectPropertyRequest) Fields(fields []string) ApiUserRoleGetObjectPropertyRequest {
	r.fields = &fields
	return r
}

// [no description yet]
func (r ApiUserRoleGetObjectPropertyRequest) Locale(locale string) ApiUserRoleGetObjectPropertyRequest {
	r.locale = &locale
	return r
}

// Defines which page number to return.
func (r ApiUserRoleGetObjectPropertyRequest) Page(page int32) ApiUserRoleGetObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiUserRoleGetObjectPropertyRequest) PageSize(pageSize int32) ApiUserRoleGetObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiUserRoleGetObjectPropertyRequest) Paging(paging bool) ApiUserRoleGetObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiUserRoleGetObjectPropertyRequest) RootJunction(rootJunction string) ApiUserRoleGetObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiUserRoleGetObjectPropertyRequest) Translate(translate bool) ApiUserRoleGetObjectPropertyRequest {
	r.translate = &translate
	return r
}

func (r ApiUserRoleGetObjectPropertyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UserRoleGetObjectPropertyExecute(r)
}

/*
UserRoleGetObjectProperty Method for UserRoleGetObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserRoleGetObjectPropertyRequest
*/
func (a *ManagementAPIService) UserRoleGetObjectProperty(ctx context.Context, property string, uid string) ApiUserRoleGetObjectPropertyRequest {
	return ApiUserRoleGetObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ManagementAPIService) UserRoleGetObjectPropertyExecute(r ApiUserRoleGetObjectPropertyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleGetObjectProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRoleGetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiUserRoleGetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiUserRoleGetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiUserRoleGetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiUserRoleGetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiUserRoleGetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiUserRoleGetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiUserRoleGetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiUserRoleGetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiUserRoleGetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiUserRoleGetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiUserRoleGetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiUserRoleGetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiUserRoleGetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiUserRoleGetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiUserRoleGetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiUserRoleGetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiUserRoleGetObjectPropertyGistAsCsvRequest) Order(order string) ApiUserRoleGetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiUserRoleGetObjectPropertyGistAsCsvRequest) Page(page int32) ApiUserRoleGetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiUserRoleGetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiUserRoleGetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiUserRoleGetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiUserRoleGetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiUserRoleGetObjectPropertyGistAsCsvRequest) References(references bool) ApiUserRoleGetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiUserRoleGetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiUserRoleGetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiUserRoleGetObjectPropertyGistAsCsvRequest) Total(total bool) ApiUserRoleGetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiUserRoleGetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiUserRoleGetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiUserRoleGetObjectPropertyGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.UserRoleGetObjectPropertyGistAsCsvExecute(r)
}

/*
UserRoleGetObjectPropertyGistAsCsv Method for UserRoleGetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserRoleGetObjectPropertyGistAsCsvRequest
*/
func (a *ManagementAPIService) UserRoleGetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiUserRoleGetObjectPropertyGistAsCsvRequest {
	return ApiUserRoleGetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *ManagementAPIService) UserRoleGetObjectPropertyGistAsCsvExecute(r ApiUserRoleGetObjectPropertyGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleGetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/{uid}/{property}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *ManagementAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Order(order string) ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Page(page int32) ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) References(references bool) ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Total(total bool) ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Execute() (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.UserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r)
}

/*
UserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsv Method for UserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest
*/
func (a *ManagementAPIService) UserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	return ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
func (a *ManagementAPIService) UserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r ApiUserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleGetObjectPropertyGistgetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/{uid}/{property}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRolePatchObjectRequest struct {
	ctx                context.Context
	ApiService         *ManagementAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	jsonPatch          *JsonPatch
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiUserRolePatchObjectRequest) AtomicMode(atomicMode string) ApiUserRolePatchObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiUserRolePatchObjectRequest) FlushMode(flushMode string) ApiUserRolePatchObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiUserRolePatchObjectRequest) Identifier(identifier string) ApiUserRolePatchObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiUserRolePatchObjectRequest) ImportMode(importMode string) ApiUserRolePatchObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiUserRolePatchObjectRequest) ImportReportMode(importReportMode string) ApiUserRolePatchObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiUserRolePatchObjectRequest) ImportStrategy(importStrategy string) ApiUserRolePatchObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiUserRolePatchObjectRequest) MergeMode(mergeMode string) ApiUserRolePatchObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiUserRolePatchObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiUserRolePatchObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiUserRolePatchObjectRequest) Page(page int32) ApiUserRolePatchObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiUserRolePatchObjectRequest) PageSize(pageSize int32) ApiUserRolePatchObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiUserRolePatchObjectRequest) Paging(paging bool) ApiUserRolePatchObjectRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiUserRolePatchObjectRequest) PreheatMode(preheatMode string) ApiUserRolePatchObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiUserRolePatchObjectRequest) RootJunction(rootJunction string) ApiUserRolePatchObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiUserRolePatchObjectRequest) SkipSharing(skipSharing bool) ApiUserRolePatchObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiUserRolePatchObjectRequest) SkipTranslation(skipTranslation bool) ApiUserRolePatchObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiUserRolePatchObjectRequest) SkipValidation(skipValidation bool) ApiUserRolePatchObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiUserRolePatchObjectRequest) UserOverrideMode(userOverrideMode string) ApiUserRolePatchObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiUserRolePatchObjectRequest) JsonPatch(jsonPatch JsonPatch) ApiUserRolePatchObjectRequest {
	r.jsonPatch = &jsonPatch
	return r
}

func (r ApiUserRolePatchObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserRolePatchObjectExecute(r)
}

/*
UserRolePatchObject Method for UserRolePatchObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserRolePatchObjectRequest
*/
func (a *ManagementAPIService) UserRolePatchObject(ctx context.Context, uid string) ApiUserRolePatchObjectRequest {
	return ApiUserRolePatchObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserRolePatchObjectExecute(r ApiUserRolePatchObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRolePatchObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRolePostJsonObjectpostXmlObjectRequest struct {
	ctx                context.Context
	ApiService         *ManagementAPIService
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	preheatMode        *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	userRole           *UserRole
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiUserRolePostJsonObjectpostXmlObjectRequest) AtomicMode(atomicMode string) ApiUserRolePostJsonObjectpostXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiUserRolePostJsonObjectpostXmlObjectRequest) FlushMode(flushMode string) ApiUserRolePostJsonObjectpostXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiUserRolePostJsonObjectpostXmlObjectRequest) Identifier(identifier string) ApiUserRolePostJsonObjectpostXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiUserRolePostJsonObjectpostXmlObjectRequest) ImportMode(importMode string) ApiUserRolePostJsonObjectpostXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiUserRolePostJsonObjectpostXmlObjectRequest) ImportReportMode(importReportMode string) ApiUserRolePostJsonObjectpostXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiUserRolePostJsonObjectpostXmlObjectRequest) ImportStrategy(importStrategy string) ApiUserRolePostJsonObjectpostXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiUserRolePostJsonObjectpostXmlObjectRequest) MergeMode(mergeMode string) ApiUserRolePostJsonObjectpostXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiUserRolePostJsonObjectpostXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiUserRolePostJsonObjectpostXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiUserRolePostJsonObjectpostXmlObjectRequest) PreheatMode(preheatMode string) ApiUserRolePostJsonObjectpostXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiUserRolePostJsonObjectpostXmlObjectRequest) SkipSharing(skipSharing bool) ApiUserRolePostJsonObjectpostXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiUserRolePostJsonObjectpostXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiUserRolePostJsonObjectpostXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiUserRolePostJsonObjectpostXmlObjectRequest) SkipValidation(skipValidation bool) ApiUserRolePostJsonObjectpostXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiUserRolePostJsonObjectpostXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiUserRolePostJsonObjectpostXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiUserRolePostJsonObjectpostXmlObjectRequest) UserRole(userRole UserRole) ApiUserRolePostJsonObjectpostXmlObjectRequest {
	r.userRole = &userRole
	return r
}

func (r ApiUserRolePostJsonObjectpostXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserRolePostJsonObjectpostXmlObjectExecute(r)
}

/*
UserRolePostJsonObjectpostXmlObject Method for UserRolePostJsonObjectpostXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUserRolePostJsonObjectpostXmlObjectRequest
*/
func (a *ManagementAPIService) UserRolePostJsonObjectpostXmlObject(ctx context.Context) ApiUserRolePostJsonObjectpostXmlObjectRequest {
	return ApiUserRolePostJsonObjectpostXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserRolePostJsonObjectpostXmlObjectExecute(r ApiUserRolePostJsonObjectpostXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRolePostJsonObjectpostXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userRole
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRolePutJsonObjectputXmlObjectRequest struct {
	ctx                context.Context
	ApiService         *ManagementAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	preheatMode        *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	userRole           *UserRole
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiUserRolePutJsonObjectputXmlObjectRequest) AtomicMode(atomicMode string) ApiUserRolePutJsonObjectputXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiUserRolePutJsonObjectputXmlObjectRequest) FlushMode(flushMode string) ApiUserRolePutJsonObjectputXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiUserRolePutJsonObjectputXmlObjectRequest) Identifier(identifier string) ApiUserRolePutJsonObjectputXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiUserRolePutJsonObjectputXmlObjectRequest) ImportMode(importMode string) ApiUserRolePutJsonObjectputXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiUserRolePutJsonObjectputXmlObjectRequest) ImportReportMode(importReportMode string) ApiUserRolePutJsonObjectputXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiUserRolePutJsonObjectputXmlObjectRequest) ImportStrategy(importStrategy string) ApiUserRolePutJsonObjectputXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiUserRolePutJsonObjectputXmlObjectRequest) MergeMode(mergeMode string) ApiUserRolePutJsonObjectputXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiUserRolePutJsonObjectputXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiUserRolePutJsonObjectputXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiUserRolePutJsonObjectputXmlObjectRequest) PreheatMode(preheatMode string) ApiUserRolePutJsonObjectputXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiUserRolePutJsonObjectputXmlObjectRequest) SkipSharing(skipSharing bool) ApiUserRolePutJsonObjectputXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiUserRolePutJsonObjectputXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiUserRolePutJsonObjectputXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiUserRolePutJsonObjectputXmlObjectRequest) SkipValidation(skipValidation bool) ApiUserRolePutJsonObjectputXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiUserRolePutJsonObjectputXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiUserRolePutJsonObjectputXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiUserRolePutJsonObjectputXmlObjectRequest) UserRole(userRole UserRole) ApiUserRolePutJsonObjectputXmlObjectRequest {
	r.userRole = &userRole
	return r
}

func (r ApiUserRolePutJsonObjectputXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserRolePutJsonObjectputXmlObjectExecute(r)
}

/*
UserRolePutJsonObjectputXmlObject Method for UserRolePutJsonObjectputXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserRolePutJsonObjectputXmlObjectRequest
*/
func (a *ManagementAPIService) UserRolePutJsonObjectputXmlObject(ctx context.Context, uid string) ApiUserRolePutJsonObjectputXmlObjectRequest {
	return ApiUserRolePutJsonObjectputXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserRolePutJsonObjectputXmlObjectExecute(r ApiUserRolePutJsonObjectputXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRolePutJsonObjectputXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userRole
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRoleRemoveAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	uid        string
}

func (r ApiUserRoleRemoveAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserRoleRemoveAsFavoriteExecute(r)
}

/*
UserRoleRemoveAsFavorite Method for UserRoleRemoveAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserRoleRemoveAsFavoriteRequest
*/
func (a *ManagementAPIService) UserRoleRemoveAsFavorite(ctx context.Context, uid string) ApiUserRoleRemoveAsFavoriteRequest {
	return ApiUserRoleRemoveAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserRoleRemoveAsFavoriteExecute(r ApiUserRoleRemoveAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleRemoveAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRoleRemoveUserFromRoleRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	id         string
	userId     string
}

func (r ApiUserRoleRemoveUserFromRoleRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserRoleRemoveUserFromRoleExecute(r)
}

/*
UserRoleRemoveUserFromRole Method for UserRoleRemoveUserFromRole

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id [no description yet]
	@param userId [no description yet]
	@return ApiUserRoleRemoveUserFromRoleRequest
*/
func (a *ManagementAPIService) UserRoleRemoveUserFromRole(ctx context.Context, id string, userId string) ApiUserRoleRemoveUserFromRoleRequest {
	return ApiUserRoleRemoveUserFromRoleRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		userId:     userId,
	}
}

// Execute executes the request
func (a *ManagementAPIService) UserRoleRemoveUserFromRoleExecute(r ApiUserRoleRemoveUserFromRoleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleRemoveUserFromRole")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/{id}/users/{userId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserRoleReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *ManagementAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiUserRoleReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiUserRoleReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiUserRoleReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserRoleReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r)
}

/*
UserRoleReplaceCollectionItemsJsonreplaceCollectionItemsXml Method for UserRoleReplaceCollectionItemsJsonreplaceCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserRoleReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest
*/
func (a *ManagementAPIService) UserRoleReplaceCollectionItemsJsonreplaceCollectionItemsXml(ctx context.Context, property string, uid string) ApiUserRoleReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	return ApiUserRoleReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserRoleReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r ApiUserRoleReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleReplaceCollectionItemsJsonreplaceCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRoleReplaceTranslationsRequest struct {
	ctx                                             context.Context
	ApiService                                      *ManagementAPIService
	uid                                             string
	aggregateDataExchangeReplaceTranslationsRequest *AggregateDataExchangeReplaceTranslationsRequest
}

// [no description yet]
func (r ApiUserRoleReplaceTranslationsRequest) AggregateDataExchangeReplaceTranslationsRequest(aggregateDataExchangeReplaceTranslationsRequest AggregateDataExchangeReplaceTranslationsRequest) ApiUserRoleReplaceTranslationsRequest {
	r.aggregateDataExchangeReplaceTranslationsRequest = &aggregateDataExchangeReplaceTranslationsRequest
	return r
}

func (r ApiUserRoleReplaceTranslationsRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserRoleReplaceTranslationsExecute(r)
}

/*
UserRoleReplaceTranslations Method for UserRoleReplaceTranslations

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserRoleReplaceTranslationsRequest
*/
func (a *ManagementAPIService) UserRoleReplaceTranslations(ctx context.Context, uid string) ApiUserRoleReplaceTranslationsRequest {
	return ApiUserRoleReplaceTranslationsRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *ManagementAPIService) UserRoleReplaceTranslationsExecute(r ApiUserRoleReplaceTranslationsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleReplaceTranslations")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/{uid}/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateDataExchangeReplaceTranslationsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserRoleSetAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	uid        string
}

func (r ApiUserRoleSetAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserRoleSetAsFavoriteExecute(r)
}

/*
UserRoleSetAsFavorite Method for UserRoleSetAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserRoleSetAsFavoriteRequest
*/
func (a *ManagementAPIService) UserRoleSetAsFavorite(ctx context.Context, uid string) ApiUserRoleSetAsFavoriteRequest {
	return ApiUserRoleSetAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserRoleSetAsFavoriteExecute(r ApiUserRoleSetAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleSetAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRoleSetSharingRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	uid        string
	sharing    *Sharing
}

// [no description yet]
func (r ApiUserRoleSetSharingRequest) Sharing(sharing Sharing) ApiUserRoleSetSharingRequest {
	r.sharing = &sharing
	return r
}

func (r ApiUserRoleSetSharingRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserRoleSetSharingExecute(r)
}

/*
UserRoleSetSharing Method for UserRoleSetSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserRoleSetSharingRequest
*/
func (a *ManagementAPIService) UserRoleSetSharing(ctx context.Context, uid string) ApiUserRoleSetSharingRequest {
	return ApiUserRoleSetSharingRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *ManagementAPIService) UserRoleSetSharingExecute(r ApiUserRoleSetSharingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleSetSharing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/{uid}/sharing"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharing
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserRoleSubscribeRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	uid        string
}

func (r ApiUserRoleSubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserRoleSubscribeExecute(r)
}

/*
UserRoleSubscribe Method for UserRoleSubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserRoleSubscribeRequest
*/
func (a *ManagementAPIService) UserRoleSubscribe(ctx context.Context, uid string) ApiUserRoleSubscribeRequest {
	return ApiUserRoleSubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserRoleSubscribeExecute(r ApiUserRoleSubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleSubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRoleUnsubscribeRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	uid        string
}

func (r ApiUserRoleUnsubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserRoleUnsubscribeExecute(r)
}

/*
UserRoleUnsubscribe Method for UserRoleUnsubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserRoleUnsubscribeRequest
*/
func (a *ManagementAPIService) UserRoleUnsubscribe(ctx context.Context, uid string) ApiUserRoleUnsubscribeRequest {
	return ApiUserRoleUnsubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserRoleUnsubscribeExecute(r ApiUserRoleUnsubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleUnsubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRoleUpdateObjectPropertyRequest struct {
	ctx                context.Context
	ApiService         *ManagementAPIService
	property           string
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	userRole           *UserRole
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiUserRoleUpdateObjectPropertyRequest) AtomicMode(atomicMode string) ApiUserRoleUpdateObjectPropertyRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiUserRoleUpdateObjectPropertyRequest) FlushMode(flushMode string) ApiUserRoleUpdateObjectPropertyRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiUserRoleUpdateObjectPropertyRequest) Identifier(identifier string) ApiUserRoleUpdateObjectPropertyRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiUserRoleUpdateObjectPropertyRequest) ImportMode(importMode string) ApiUserRoleUpdateObjectPropertyRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiUserRoleUpdateObjectPropertyRequest) ImportReportMode(importReportMode string) ApiUserRoleUpdateObjectPropertyRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiUserRoleUpdateObjectPropertyRequest) ImportStrategy(importStrategy string) ApiUserRoleUpdateObjectPropertyRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiUserRoleUpdateObjectPropertyRequest) MergeMode(mergeMode string) ApiUserRoleUpdateObjectPropertyRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiUserRoleUpdateObjectPropertyRequest) MetadataSyncImport(metadataSyncImport bool) ApiUserRoleUpdateObjectPropertyRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiUserRoleUpdateObjectPropertyRequest) Page(page int32) ApiUserRoleUpdateObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiUserRoleUpdateObjectPropertyRequest) PageSize(pageSize int32) ApiUserRoleUpdateObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiUserRoleUpdateObjectPropertyRequest) Paging(paging bool) ApiUserRoleUpdateObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiUserRoleUpdateObjectPropertyRequest) PreheatMode(preheatMode string) ApiUserRoleUpdateObjectPropertyRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiUserRoleUpdateObjectPropertyRequest) RootJunction(rootJunction string) ApiUserRoleUpdateObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiUserRoleUpdateObjectPropertyRequest) SkipSharing(skipSharing bool) ApiUserRoleUpdateObjectPropertyRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiUserRoleUpdateObjectPropertyRequest) SkipTranslation(skipTranslation bool) ApiUserRoleUpdateObjectPropertyRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiUserRoleUpdateObjectPropertyRequest) SkipValidation(skipValidation bool) ApiUserRoleUpdateObjectPropertyRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiUserRoleUpdateObjectPropertyRequest) UserOverrideMode(userOverrideMode string) ApiUserRoleUpdateObjectPropertyRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiUserRoleUpdateObjectPropertyRequest) UserRole(userRole UserRole) ApiUserRoleUpdateObjectPropertyRequest {
	r.userRole = &userRole
	return r
}

func (r ApiUserRoleUpdateObjectPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserRoleUpdateObjectPropertyExecute(r)
}

/*
UserRoleUpdateObjectProperty Method for UserRoleUpdateObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserRoleUpdateObjectPropertyRequest
*/
func (a *ManagementAPIService) UserRoleUpdateObjectProperty(ctx context.Context, property string, uid string) ApiUserRoleUpdateObjectPropertyRequest {
	return ApiUserRoleUpdateObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
func (a *ManagementAPIService) UserRoleUpdateObjectPropertyExecute(r ApiUserRoleUpdateObjectPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserRoleUpdateObjectProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userRoles/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userRole
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserSetAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	uid        string
}

func (r ApiUserSetAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserSetAsFavoriteExecute(r)
}

/*
UserSetAsFavorite Method for UserSetAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserSetAsFavoriteRequest
*/
func (a *ManagementAPIService) UserSetAsFavorite(ctx context.Context, uid string) ApiUserSetAsFavoriteRequest {
	return ApiUserSetAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserSetAsFavoriteExecute(r ApiUserSetAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserSetAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserSetSharingRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	uid        string
	sharing    *Sharing
}

// [no description yet]
func (r ApiUserSetSharingRequest) Sharing(sharing Sharing) ApiUserSetSharingRequest {
	r.sharing = &sharing
	return r
}

func (r ApiUserSetSharingRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserSetSharingExecute(r)
}

/*
UserSetSharing Method for UserSetSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserSetSharingRequest
*/
func (a *ManagementAPIService) UserSetSharing(ctx context.Context, uid string) ApiUserSetSharingRequest {
	return ApiUserSetSharingRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *ManagementAPIService) UserSetSharingExecute(r ApiUserSetSharingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserSetSharing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}/sharing"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharing
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserSettingDeleteUserSettingByKeyRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	key        string
	user       *string
	userId     *string
}

// [no description yet]
func (r ApiUserSettingDeleteUserSettingByKeyRequest) User(user string) ApiUserSettingDeleteUserSettingByKeyRequest {
	r.user = &user
	return r
}

// [no description yet]
func (r ApiUserSettingDeleteUserSettingByKeyRequest) UserId(userId string) ApiUserSettingDeleteUserSettingByKeyRequest {
	r.userId = &userId
	return r
}

func (r ApiUserSettingDeleteUserSettingByKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserSettingDeleteUserSettingByKeyExecute(r)
}

/*
UserSettingDeleteUserSettingByKey Method for UserSettingDeleteUserSettingByKey

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param key [no description yet]
	@return ApiUserSettingDeleteUserSettingByKeyRequest
*/
func (a *ManagementAPIService) UserSettingDeleteUserSettingByKey(ctx context.Context, key string) ApiUserSettingDeleteUserSettingByKeyRequest {
	return ApiUserSettingDeleteUserSettingByKeyRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
	}
}

// Execute executes the request
func (a *ManagementAPIService) UserSettingDeleteUserSettingByKeyExecute(r ApiUserSettingDeleteUserSettingByKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserSettingDeleteUserSettingByKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userSettings/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserSettingGetAllUserSettingsRequest struct {
	ctx         context.Context
	ApiService  *ManagementAPIService
	key         *[]string
	useFallback *bool
	user        *string
	userId      *string
}

// [no description yet]
func (r ApiUserSettingGetAllUserSettingsRequest) Key(key []string) ApiUserSettingGetAllUserSettingsRequest {
	r.key = &key
	return r
}

// [no description yet]
func (r ApiUserSettingGetAllUserSettingsRequest) UseFallback(useFallback bool) ApiUserSettingGetAllUserSettingsRequest {
	r.useFallback = &useFallback
	return r
}

// [no description yet]
func (r ApiUserSettingGetAllUserSettingsRequest) User(user string) ApiUserSettingGetAllUserSettingsRequest {
	r.user = &user
	return r
}

// [no description yet]
func (r ApiUserSettingGetAllUserSettingsRequest) UserId(userId string) ApiUserSettingGetAllUserSettingsRequest {
	r.userId = &userId
	return r
}

func (r ApiUserSettingGetAllUserSettingsRequest) Execute() (*map[string]FileGetCustomScript200Response, *http.Response, error) {
	return r.ApiService.UserSettingGetAllUserSettingsExecute(r)
}

/*
UserSettingGetAllUserSettings Method for UserSettingGetAllUserSettings

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUserSettingGetAllUserSettingsRequest
*/
func (a *ManagementAPIService) UserSettingGetAllUserSettings(ctx context.Context) ApiUserSettingGetAllUserSettingsRequest {
	return ApiUserSettingGetAllUserSettingsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]FileGetCustomScript200Response
func (a *ManagementAPIService) UserSettingGetAllUserSettingsExecute(r ApiUserSettingGetAllUserSettingsRequest) (*map[string]FileGetCustomScript200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *map[string]FileGetCustomScript200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserSettingGetAllUserSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userSettings/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		t := *r.key
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "key", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "key", t, "multi")
		}
	}
	if r.useFallback != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useFallback", r.useFallback, "")
	} else {
		var defaultValue bool = true
		r.useFallback = &defaultValue
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserSettingGetUserSettingByKeyRequest struct {
	ctx         context.Context
	ApiService  *ManagementAPIService
	key         string
	useFallback *bool
	user        *string
	userId      *string
}

// [no description yet]
func (r ApiUserSettingGetUserSettingByKeyRequest) UseFallback(useFallback bool) ApiUserSettingGetUserSettingByKeyRequest {
	r.useFallback = &useFallback
	return r
}

// [no description yet]
func (r ApiUserSettingGetUserSettingByKeyRequest) User(user string) ApiUserSettingGetUserSettingByKeyRequest {
	r.user = &user
	return r
}

// [no description yet]
func (r ApiUserSettingGetUserSettingByKeyRequest) UserId(userId string) ApiUserSettingGetUserSettingByKeyRequest {
	r.userId = &userId
	return r
}

func (r ApiUserSettingGetUserSettingByKeyRequest) Execute() (*FileGetCustomScript200Response, *http.Response, error) {
	return r.ApiService.UserSettingGetUserSettingByKeyExecute(r)
}

/*
UserSettingGetUserSettingByKey Method for UserSettingGetUserSettingByKey

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param key [no description yet]
	@return ApiUserSettingGetUserSettingByKeyRequest
*/
func (a *ManagementAPIService) UserSettingGetUserSettingByKey(ctx context.Context, key string) ApiUserSettingGetUserSettingByKeyRequest {
	return ApiUserSettingGetUserSettingByKeyRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
	}
}

// Execute executes the request
//
//	@return FileGetCustomScript200Response
func (a *ManagementAPIService) UserSettingGetUserSettingByKeyExecute(r ApiUserSettingGetUserSettingByKeyRequest) (*FileGetCustomScript200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FileGetCustomScript200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserSettingGetUserSettingByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userSettings/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.useFallback != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useFallback", r.useFallback, "")
	} else {
		var defaultValue bool = true
		r.useFallback = &defaultValue
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserSettingSetUserSettingByKeyRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	key        string
	user       *string
	userId     *string
	value      *string
	body       *string
}

// [no description yet]
func (r ApiUserSettingSetUserSettingByKeyRequest) User(user string) ApiUserSettingSetUserSettingByKeyRequest {
	r.user = &user
	return r
}

// [no description yet]
func (r ApiUserSettingSetUserSettingByKeyRequest) UserId(userId string) ApiUserSettingSetUserSettingByKeyRequest {
	r.userId = &userId
	return r
}

// [no description yet]
func (r ApiUserSettingSetUserSettingByKeyRequest) Value(value string) ApiUserSettingSetUserSettingByKeyRequest {
	r.value = &value
	return r
}

// [no description yet]
func (r ApiUserSettingSetUserSettingByKeyRequest) Body(body string) ApiUserSettingSetUserSettingByKeyRequest {
	r.body = &body
	return r
}

func (r ApiUserSettingSetUserSettingByKeyRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserSettingSetUserSettingByKeyExecute(r)
}

/*
UserSettingSetUserSettingByKey Method for UserSettingSetUserSettingByKey

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param key [no description yet]
	@return ApiUserSettingSetUserSettingByKeyRequest
*/
func (a *ManagementAPIService) UserSettingSetUserSettingByKey(ctx context.Context, key string) ApiUserSettingSetUserSettingByKeyRequest {
	return ApiUserSettingSetUserSettingByKeyRequest{
		ApiService: a,
		ctx:        ctx,
		key:        key,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserSettingSetUserSettingByKeyExecute(r ApiUserSettingSetUserSettingByKeyRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserSettingSetUserSettingByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userSettings/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.value != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "value", r.value, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserSubscribeRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	uid        string
}

func (r ApiUserSubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserSubscribeExecute(r)
}

/*
UserSubscribe Method for UserSubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserSubscribeRequest
*/
func (a *ManagementAPIService) UserSubscribe(ctx context.Context, uid string) ApiUserSubscribeRequest {
	return ApiUserSubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserSubscribeExecute(r ApiUserSubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserSubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserUnexpireUserRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	uid        string
}

func (r ApiUserUnexpireUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserUnexpireUserExecute(r)
}

/*
UserUnexpireUser Method for UserUnexpireUser

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserUnexpireUserRequest
*/
func (a *ManagementAPIService) UserUnexpireUser(ctx context.Context, uid string) ApiUserUnexpireUserRequest {
	return ApiUserUnexpireUserRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *ManagementAPIService) UserUnexpireUserExecute(r ApiUserUnexpireUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserUnexpireUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}/unexpired"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserUnsubscribeRequest struct {
	ctx        context.Context
	ApiService *ManagementAPIService
	uid        string
}

func (r ApiUserUnsubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.UserUnsubscribeExecute(r)
}

/*
UserUnsubscribe Method for UserUnsubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiUserUnsubscribeRequest
*/
func (a *ManagementAPIService) UserUnsubscribe(ctx context.Context, uid string) ApiUserUnsubscribeRequest {
	return ApiUserUnsubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *ManagementAPIService) UserUnsubscribeExecute(r ApiUserUnsubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserUnsubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserUpdateObjectPropertyRequest struct {
	ctx                context.Context
	ApiService         *ManagementAPIService
	property           string
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	user               *User
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiUserUpdateObjectPropertyRequest) AtomicMode(atomicMode string) ApiUserUpdateObjectPropertyRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiUserUpdateObjectPropertyRequest) FlushMode(flushMode string) ApiUserUpdateObjectPropertyRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiUserUpdateObjectPropertyRequest) Identifier(identifier string) ApiUserUpdateObjectPropertyRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiUserUpdateObjectPropertyRequest) ImportMode(importMode string) ApiUserUpdateObjectPropertyRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiUserUpdateObjectPropertyRequest) ImportReportMode(importReportMode string) ApiUserUpdateObjectPropertyRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiUserUpdateObjectPropertyRequest) ImportStrategy(importStrategy string) ApiUserUpdateObjectPropertyRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiUserUpdateObjectPropertyRequest) MergeMode(mergeMode string) ApiUserUpdateObjectPropertyRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiUserUpdateObjectPropertyRequest) MetadataSyncImport(metadataSyncImport bool) ApiUserUpdateObjectPropertyRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiUserUpdateObjectPropertyRequest) Page(page int32) ApiUserUpdateObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiUserUpdateObjectPropertyRequest) PageSize(pageSize int32) ApiUserUpdateObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiUserUpdateObjectPropertyRequest) Paging(paging bool) ApiUserUpdateObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiUserUpdateObjectPropertyRequest) PreheatMode(preheatMode string) ApiUserUpdateObjectPropertyRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiUserUpdateObjectPropertyRequest) RootJunction(rootJunction string) ApiUserUpdateObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiUserUpdateObjectPropertyRequest) SkipSharing(skipSharing bool) ApiUserUpdateObjectPropertyRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiUserUpdateObjectPropertyRequest) SkipTranslation(skipTranslation bool) ApiUserUpdateObjectPropertyRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiUserUpdateObjectPropertyRequest) SkipValidation(skipValidation bool) ApiUserUpdateObjectPropertyRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiUserUpdateObjectPropertyRequest) UserOverrideMode(userOverrideMode string) ApiUserUpdateObjectPropertyRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiUserUpdateObjectPropertyRequest) User(user User) ApiUserUpdateObjectPropertyRequest {
	r.user = &user
	return r
}

func (r ApiUserUpdateObjectPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserUpdateObjectPropertyExecute(r)
}

/*
UserUpdateObjectProperty Method for UserUpdateObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiUserUpdateObjectPropertyRequest
*/
func (a *ManagementAPIService) UserUpdateObjectProperty(ctx context.Context, property string, uid string) ApiUserUpdateObjectPropertyRequest {
	return ApiUserUpdateObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
func (a *ManagementAPIService) UserUpdateObjectPropertyExecute(r ApiUserUpdateObjectPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementAPIService.UserUpdateObjectProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.user
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
