/*
DHIS2 API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.40
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package models

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"reflect"
	"strings"
	"time"
)

// UiAPIService UiAPI service
type UiAPIService service

type ApiAppDeleteAppRequest struct {
	ctx           context.Context
	ApiService    *UiAPIService
	app           string
	deleteAppData *bool
}

// [no description yet]
func (r ApiAppDeleteAppRequest) DeleteAppData(deleteAppData bool) ApiAppDeleteAppRequest {
	r.deleteAppData = &deleteAppData
	return r
}

func (r ApiAppDeleteAppRequest) Execute() (*http.Response, error) {
	return r.ApiService.AppDeleteAppExecute(r)
}

/*
AppDeleteApp Method for AppDeleteApp

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param app [no description yet]
	@return ApiAppDeleteAppRequest
*/
func (a *UiAPIService) AppDeleteApp(ctx context.Context, app string) ApiAppDeleteAppRequest {
	return ApiAppDeleteAppRequest{
		ApiService: a,
		ctx:        ctx,
		app:        app,
	}
}

// Execute executes the request
func (a *UiAPIService) AppDeleteAppExecute(r ApiAppDeleteAppRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.AppDeleteApp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/{app}"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterValueToString(r.app, "app")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deleteAppData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteAppData", r.deleteAppData, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAppGetAppsRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	key        *string
}

// [no description yet]
func (r ApiAppGetAppsRequest) Key(key string) ApiAppGetAppsRequest {
	r.key = &key
	return r
}

func (r ApiAppGetAppsRequest) Execute() ([]App, *http.Response, error) {
	return r.ApiService.AppGetAppsExecute(r)
}

/*
AppGetApps Method for AppGetApps

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAppGetAppsRequest
*/
func (a *UiAPIService) AppGetApps(ctx context.Context) ApiAppGetAppsRequest {
	return ApiAppGetAppsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []App
func (a *UiAPIService) AppGetAppsExecute(r ApiAppGetAppsRequest) ([]App, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []App
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.AppGetApps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppGetWebModulesRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
}

func (r ApiAppGetWebModulesRequest) Execute() (*map[string][]WebModule, *http.Response, error) {
	return r.ApiService.AppGetWebModulesExecute(r)
}

/*
AppGetWebModules Method for AppGetWebModules

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAppGetWebModulesRequest
*/
func (a *UiAPIService) AppGetWebModules(ctx context.Context) ApiAppGetWebModulesRequest {
	return ApiAppGetWebModulesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string][]WebModule
func (a *UiAPIService) AppGetWebModulesExecute(r ApiAppGetWebModulesRequest) (*map[string][]WebModule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *map[string][]WebModule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.AppGetWebModules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/menu"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppHubGetAppHubApiResponseRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	apiVersion string
}

func (r ApiAppHubGetAppHubApiResponseRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.AppHubGetAppHubApiResponseExecute(r)
}

/*
AppHubGetAppHubApiResponse Method for AppHubGetAppHubApiResponse

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiVersion [no description yet]
	@return ApiAppHubGetAppHubApiResponseRequest
*/
func (a *UiAPIService) AppHubGetAppHubApiResponse(ctx context.Context, apiVersion string) ApiAppHubGetAppHubApiResponseRequest {
	return ApiAppHubGetAppHubApiResponseRequest{
		ApiService: a,
		ctx:        ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//
//	@return string
func (a *UiAPIService) AppHubGetAppHubApiResponseExecute(r ApiAppHubGetAppHubApiResponseRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.AppHubGetAppHubApiResponse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appHub/{apiVersion}/**"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppHubInstallAppFromAppHubRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	versionId  string
}

func (r ApiAppHubInstallAppFromAppHubRequest) Execute() (*http.Response, error) {
	return r.ApiService.AppHubInstallAppFromAppHubExecute(r)
}

/*
AppHubInstallAppFromAppHub Method for AppHubInstallAppFromAppHub

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param versionId [no description yet]
	@return ApiAppHubInstallAppFromAppHubRequest
*/
func (a *UiAPIService) AppHubInstallAppFromAppHub(ctx context.Context, versionId string) ApiAppHubInstallAppFromAppHubRequest {
	return ApiAppHubInstallAppFromAppHubRequest{
		ApiService: a,
		ctx:        ctx,
		versionId:  versionId,
	}
}

// Execute executes the request
func (a *UiAPIService) AppHubInstallAppFromAppHubExecute(r ApiAppHubInstallAppFromAppHubRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.AppHubInstallAppFromAppHub")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appHub/{versionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"versionId"+"}", url.PathEscape(parameterValueToString(r.versionId, "versionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAppHubListAppHubRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
}

func (r ApiAppHubListAppHubRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.AppHubListAppHubExecute(r)
}

/*
AppHubListAppHub Method for AppHubListAppHub

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAppHubListAppHubRequest
*/
func (a *UiAPIService) AppHubListAppHub(ctx context.Context) ApiAppHubListAppHubRequest {
	return ApiAppHubListAppHubRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *UiAPIService) AppHubListAppHubExecute(r ApiAppHubListAppHubRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.AppHubListAppHub")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appHub/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppInstallAppRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	file       *os.File
}

// [no description yet]
func (r ApiAppInstallAppRequest) File(file *os.File) ApiAppInstallAppRequest {
	r.file = file
	return r
}

func (r ApiAppInstallAppRequest) Execute() (*http.Response, error) {
	return r.ApiService.AppInstallAppExecute(r)
}

/*
AppInstallApp Method for AppInstallApp

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAppInstallAppRequest
*/
func (a *UiAPIService) AppInstallApp(ctx context.Context) ApiAppInstallAppRequest {
	return ApiAppInstallAppRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *UiAPIService) AppInstallAppExecute(r ApiAppInstallAppRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.AppInstallApp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.file == nil {
		return nil, reportError("file is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "file", r.file, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAppReloadAppsRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
}

func (r ApiAppReloadAppsRequest) Execute() (*http.Response, error) {
	return r.ApiService.AppReloadAppsExecute(r)
}

/*
AppReloadApps Method for AppReloadApps

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAppReloadAppsRequest
*/
func (a *UiAPIService) AppReloadApps(ctx context.Context) ApiAppReloadAppsRequest {
	return ApiAppReloadAppsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *UiAPIService) AppReloadAppsExecute(r ApiAppReloadAppsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.AppReloadApps")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAppRenderAppRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	app        string
}

func (r ApiAppRenderAppRequest) Execute() (*http.Response, error) {
	return r.ApiService.AppRenderAppExecute(r)
}

/*
AppRenderApp Method for AppRenderApp

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param app [no description yet]
	@return ApiAppRenderAppRequest
*/
func (a *UiAPIService) AppRenderApp(ctx context.Context, app string) ApiAppRenderAppRequest {
	return ApiAppRenderAppRequest{
		ApiService: a,
		ctx:        ctx,
		app:        app,
	}
}

// Execute executes the request
func (a *UiAPIService) AppRenderAppExecute(r ApiAppRenderAppRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.AppRenderApp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/{app}/**"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterValueToString(r.app, "app")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAppSetConfigRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
}

func (r ApiAppSetConfigRequest) Execute() (*http.Response, error) {
	return r.ApiService.AppSetConfigExecute(r)
}

/*
AppSetConfig Method for AppSetConfig

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAppSetConfigRequest
*/
func (a *UiAPIService) AppSetConfig(ctx context.Context) ApiAppSetConfigRequest {
	return ApiAppSetConfigRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *UiAPIService) AppSetConfigExecute(r ApiAppSetConfigRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.AppSetConfig")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDashboardAddCollectionItemRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiDashboardAddCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardAddCollectionItemExecute(r)
}

/*
DashboardAddCollectionItem Method for DashboardAddCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiDashboardAddCollectionItemRequest
*/
func (a *UiAPIService) DashboardAddCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiDashboardAddCollectionItemRequest {
	return ApiDashboardAddCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardAddCollectionItemExecute(r ApiDashboardAddCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardAddCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardAddCollectionItemsJsonaddCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *UiAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiDashboardAddCollectionItemsJsonaddCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiDashboardAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiDashboardAddCollectionItemsJsonaddCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardAddCollectionItemsJsonaddCollectionItemsXmlExecute(r)
}

/*
DashboardAddCollectionItemsJsonaddCollectionItemsXml Method for DashboardAddCollectionItemsJsonaddCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiDashboardAddCollectionItemsJsonaddCollectionItemsXmlRequest
*/
func (a *UiAPIService) DashboardAddCollectionItemsJsonaddCollectionItemsXml(ctx context.Context, property string, uid string) ApiDashboardAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	return ApiDashboardAddCollectionItemsJsonaddCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardAddCollectionItemsJsonaddCollectionItemsXmlExecute(r ApiDashboardAddCollectionItemsJsonaddCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardAddCollectionItemsJsonaddCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardBulkSharingRequest struct {
	ctx                context.Context
	ApiService         *UiAPIService
	atomic             *bool
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	bulkJsonPatch      *BulkJsonPatch
}

// [no description yet]
func (r ApiDashboardBulkSharingRequest) Atomic(atomic bool) ApiDashboardBulkSharingRequest {
	r.atomic = &atomic
	return r
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiDashboardBulkSharingRequest) AtomicMode(atomicMode string) ApiDashboardBulkSharingRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiDashboardBulkSharingRequest) FlushMode(flushMode string) ApiDashboardBulkSharingRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiDashboardBulkSharingRequest) Identifier(identifier string) ApiDashboardBulkSharingRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiDashboardBulkSharingRequest) ImportMode(importMode string) ApiDashboardBulkSharingRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiDashboardBulkSharingRequest) ImportReportMode(importReportMode string) ApiDashboardBulkSharingRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiDashboardBulkSharingRequest) ImportStrategy(importStrategy string) ApiDashboardBulkSharingRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiDashboardBulkSharingRequest) MergeMode(mergeMode string) ApiDashboardBulkSharingRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiDashboardBulkSharingRequest) MetadataSyncImport(metadataSyncImport bool) ApiDashboardBulkSharingRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiDashboardBulkSharingRequest) Page(page int32) ApiDashboardBulkSharingRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiDashboardBulkSharingRequest) PageSize(pageSize int32) ApiDashboardBulkSharingRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiDashboardBulkSharingRequest) Paging(paging bool) ApiDashboardBulkSharingRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiDashboardBulkSharingRequest) PreheatMode(preheatMode string) ApiDashboardBulkSharingRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiDashboardBulkSharingRequest) RootJunction(rootJunction string) ApiDashboardBulkSharingRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiDashboardBulkSharingRequest) SkipSharing(skipSharing bool) ApiDashboardBulkSharingRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiDashboardBulkSharingRequest) SkipTranslation(skipTranslation bool) ApiDashboardBulkSharingRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiDashboardBulkSharingRequest) SkipValidation(skipValidation bool) ApiDashboardBulkSharingRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiDashboardBulkSharingRequest) UserOverrideMode(userOverrideMode string) ApiDashboardBulkSharingRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiDashboardBulkSharingRequest) BulkJsonPatch(bulkJsonPatch BulkJsonPatch) ApiDashboardBulkSharingRequest {
	r.bulkJsonPatch = &bulkJsonPatch
	return r
}

func (r ApiDashboardBulkSharingRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardBulkSharingExecute(r)
}

/*
DashboardBulkSharing Method for DashboardBulkSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDashboardBulkSharingRequest
*/
func (a *UiAPIService) DashboardBulkSharing(ctx context.Context) ApiDashboardBulkSharingRequest {
	return ApiDashboardBulkSharingRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardBulkSharingExecute(r ApiDashboardBulkSharingRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardBulkSharing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/sharing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomic", r.atomic, "")
	} else {
		var defaultValue bool = false
		r.atomic = &defaultValue
	}
	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkJsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardCascadeSharingRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
	atomic     *bool
	dryRun     *bool
}

// [no description yet]
func (r ApiDashboardCascadeSharingRequest) Atomic(atomic bool) ApiDashboardCascadeSharingRequest {
	r.atomic = &atomic
	return r
}

// [no description yet]
func (r ApiDashboardCascadeSharingRequest) DryRun(dryRun bool) ApiDashboardCascadeSharingRequest {
	r.dryRun = &dryRun
	return r
}

func (r ApiDashboardCascadeSharingRequest) Execute() (*CascadeSharingReport, *http.Response, error) {
	return r.ApiService.DashboardCascadeSharingExecute(r)
}

/*
DashboardCascadeSharing Method for DashboardCascadeSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardCascadeSharingRequest
*/
func (a *UiAPIService) DashboardCascadeSharing(ctx context.Context, uid string) ApiDashboardCascadeSharingRequest {
	return ApiDashboardCascadeSharingRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return CascadeSharingReport
func (a *UiAPIService) DashboardCascadeSharingExecute(r ApiDashboardCascadeSharingRequest) (*CascadeSharingReport, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CascadeSharingReport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardCascadeSharing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/cascadeSharing/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomic", r.atomic, "")
	}
	if r.dryRun != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dryRun", r.dryRun, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardDeleteCollectionItemRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiDashboardDeleteCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardDeleteCollectionItemExecute(r)
}

/*
DashboardDeleteCollectionItem Method for DashboardDeleteCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiDashboardDeleteCollectionItemRequest
*/
func (a *UiAPIService) DashboardDeleteCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiDashboardDeleteCollectionItemRequest {
	return ApiDashboardDeleteCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardDeleteCollectionItemExecute(r ApiDashboardDeleteCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardDeleteCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *UiAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiDashboardDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiDashboardDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiDashboardDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r)
}

/*
DashboardDeleteCollectionItemsJsondeleteCollectionItemsXml Method for DashboardDeleteCollectionItemsJsondeleteCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiDashboardDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest
*/
func (a *UiAPIService) DashboardDeleteCollectionItemsJsondeleteCollectionItemsXml(ctx context.Context, property string, uid string) ApiDashboardDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	return ApiDashboardDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r ApiDashboardDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardDeleteCollectionItemsJsondeleteCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardDeleteObjectRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
}

func (r ApiDashboardDeleteObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardDeleteObjectExecute(r)
}

/*
DashboardDeleteObject Method for DashboardDeleteObject

Deletes the Dashboard provided by ID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardDeleteObjectRequest
*/
func (a *UiAPIService) DashboardDeleteObject(ctx context.Context, uid string) ApiDashboardDeleteObjectRequest {
	return ApiDashboardDeleteObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardDeleteObjectExecute(r ApiDashboardDeleteObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardDeleteObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardGetDataSetWithDependenciesRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
	download   *bool
}

// [no description yet]
func (r ApiDashboardGetDataSetWithDependenciesRequest) Download(download bool) ApiDashboardGetDataSetWithDependenciesRequest {
	r.download = &download
	return r
}

func (r ApiDashboardGetDataSetWithDependenciesRequest) Execute() (*MetadataExportParams, *http.Response, error) {
	return r.ApiService.DashboardGetDataSetWithDependenciesExecute(r)
}

/*
DashboardGetDataSetWithDependencies Method for DashboardGetDataSetWithDependencies

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardGetDataSetWithDependenciesRequest
*/
func (a *UiAPIService) DashboardGetDataSetWithDependencies(ctx context.Context, uid string) ApiDashboardGetDataSetWithDependenciesRequest {
	return ApiDashboardGetDataSetWithDependenciesRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return MetadataExportParams
func (a *UiAPIService) DashboardGetDataSetWithDependenciesExecute(r ApiDashboardGetDataSetWithDependenciesRequest) (*MetadataExportParams, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MetadataExportParams
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardGetDataSetWithDependencies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{uid}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.download != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "download", r.download, "")
	} else {
		var defaultValue bool = false
		r.download = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardGetObjectRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	uid          string
	fields       *[]string
	filter       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiDashboardGetObjectRequest) Fields(fields []string) ApiDashboardGetObjectRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiDashboardGetObjectRequest) Filter(filter []string) ApiDashboardGetObjectRequest {
	r.filter = &filter
	return r
}

// Defines which page number to return.
func (r ApiDashboardGetObjectRequest) Page(page int32) ApiDashboardGetObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiDashboardGetObjectRequest) PageSize(pageSize int32) ApiDashboardGetObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiDashboardGetObjectRequest) Paging(paging bool) ApiDashboardGetObjectRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiDashboardGetObjectRequest) RootJunction(rootJunction string) ApiDashboardGetObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiDashboardGetObjectRequest) Execute() (*Dashboard, *http.Response, error) {
	return r.ApiService.DashboardGetObjectExecute(r)
}

/*
DashboardGetObject Method for DashboardGetObject

View a Dashboard

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardGetObjectRequest
*/
func (a *UiAPIService) DashboardGetObject(ctx context.Context, uid string) ApiDashboardGetObjectRequest {
	return ApiDashboardGetObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return Dashboard
func (a *UiAPIService) DashboardGetObjectExecute(r ApiDashboardGetObjectRequest) (*Dashboard, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Dashboard
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardGetObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardGetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiDashboardGetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiDashboardGetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiDashboardGetObjectGistAsCsvRequest) Auto(auto string) ApiDashboardGetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiDashboardGetObjectGistAsCsvRequest) Describe(describe bool) ApiDashboardGetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiDashboardGetObjectGistAsCsvRequest) Fields(fields string) ApiDashboardGetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiDashboardGetObjectGistAsCsvRequest) Filter(filter string) ApiDashboardGetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiDashboardGetObjectGistAsCsvRequest) Headless(headless bool) ApiDashboardGetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiDashboardGetObjectGistAsCsvRequest) Inverse(inverse bool) ApiDashboardGetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiDashboardGetObjectGistAsCsvRequest) Locale(locale string) ApiDashboardGetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiDashboardGetObjectGistAsCsvRequest) Order(order string) ApiDashboardGetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiDashboardGetObjectGistAsCsvRequest) Page(page int32) ApiDashboardGetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiDashboardGetObjectGistAsCsvRequest) PageListName(pageListName string) ApiDashboardGetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiDashboardGetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiDashboardGetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiDashboardGetObjectGistAsCsvRequest) References(references bool) ApiDashboardGetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiDashboardGetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiDashboardGetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiDashboardGetObjectGistAsCsvRequest) Total(total bool) ApiDashboardGetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiDashboardGetObjectGistAsCsvRequest) Translate(translate bool) ApiDashboardGetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiDashboardGetObjectGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.DashboardGetObjectGistAsCsvExecute(r)
}

/*
DashboardGetObjectGistAsCsv Method for DashboardGetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardGetObjectGistAsCsvRequest
*/
func (a *UiAPIService) DashboardGetObjectGistAsCsv(ctx context.Context, uid string) ApiDashboardGetObjectGistAsCsvRequest {
	return ApiDashboardGetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *UiAPIService) DashboardGetObjectGistAsCsvExecute(r ApiDashboardGetObjectGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardGetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{uid}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardGetObjectGistgetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiDashboardGetObjectGistgetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiDashboardGetObjectGistgetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiDashboardGetObjectGistgetObjectGistAsCsvRequest) Auto(auto string) ApiDashboardGetObjectGistgetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiDashboardGetObjectGistgetObjectGistAsCsvRequest) Describe(describe bool) ApiDashboardGetObjectGistgetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiDashboardGetObjectGistgetObjectGistAsCsvRequest) Fields(fields string) ApiDashboardGetObjectGistgetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiDashboardGetObjectGistgetObjectGistAsCsvRequest) Filter(filter string) ApiDashboardGetObjectGistgetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiDashboardGetObjectGistgetObjectGistAsCsvRequest) Headless(headless bool) ApiDashboardGetObjectGistgetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiDashboardGetObjectGistgetObjectGistAsCsvRequest) Inverse(inverse bool) ApiDashboardGetObjectGistgetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiDashboardGetObjectGistgetObjectGistAsCsvRequest) Locale(locale string) ApiDashboardGetObjectGistgetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiDashboardGetObjectGistgetObjectGistAsCsvRequest) Order(order string) ApiDashboardGetObjectGistgetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiDashboardGetObjectGistgetObjectGistAsCsvRequest) Page(page int32) ApiDashboardGetObjectGistgetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiDashboardGetObjectGistgetObjectGistAsCsvRequest) PageListName(pageListName string) ApiDashboardGetObjectGistgetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiDashboardGetObjectGistgetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiDashboardGetObjectGistgetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiDashboardGetObjectGistgetObjectGistAsCsvRequest) References(references bool) ApiDashboardGetObjectGistgetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiDashboardGetObjectGistgetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiDashboardGetObjectGistgetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiDashboardGetObjectGistgetObjectGistAsCsvRequest) Total(total bool) ApiDashboardGetObjectGistgetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiDashboardGetObjectGistgetObjectGistAsCsvRequest) Translate(translate bool) ApiDashboardGetObjectGistgetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiDashboardGetObjectGistgetObjectGistAsCsvRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DashboardGetObjectGistgetObjectGistAsCsvExecute(r)
}

/*
DashboardGetObjectGistgetObjectGistAsCsv Method for DashboardGetObjectGistgetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardGetObjectGistgetObjectGistAsCsvRequest
*/
func (a *UiAPIService) DashboardGetObjectGistgetObjectGistAsCsv(ctx context.Context, uid string) ApiDashboardGetObjectGistgetObjectGistAsCsvRequest {
	return ApiDashboardGetObjectGistgetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *UiAPIService) DashboardGetObjectGistgetObjectGistAsCsvExecute(r ApiDashboardGetObjectGistgetObjectGistAsCsvRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardGetObjectGistgetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{uid}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardGetObjectListRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	fields       *[]string
	filter       *[]string
	orders       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// &#x60;&lt;field-name&gt;[,&lt;field-name&gt;...]&#x60;
func (r ApiDashboardGetObjectListRequest) Fields(fields []string) ApiDashboardGetObjectListRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiDashboardGetObjectListRequest) Filter(filter []string) ApiDashboardGetObjectListRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiDashboardGetObjectListRequest) Orders(orders []string) ApiDashboardGetObjectListRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiDashboardGetObjectListRequest) Page(page int32) ApiDashboardGetObjectListRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiDashboardGetObjectListRequest) PageSize(pageSize int32) ApiDashboardGetObjectListRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiDashboardGetObjectListRequest) Paging(paging bool) ApiDashboardGetObjectListRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiDashboardGetObjectListRequest) RootJunction(rootJunction string) ApiDashboardGetObjectListRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiDashboardGetObjectListRequest) Execute() (*DashboardGetObjectList200Response, *http.Response, error) {
	return r.ApiService.DashboardGetObjectListExecute(r)
}

/*
DashboardGetObjectList Method for DashboardGetObjectList

List all Dashboards

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDashboardGetObjectListRequest
*/
func (a *UiAPIService) DashboardGetObjectList(ctx context.Context) ApiDashboardGetObjectListRequest {
	return ApiDashboardGetObjectListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DashboardGetObjectList200Response
func (a *UiAPIService) DashboardGetObjectListExecute(r ApiDashboardGetObjectListRequest) (*DashboardGetObjectList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DashboardGetObjectList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardGetObjectList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardGetObjectListCsvRequest struct {
	ctx            context.Context
	ApiService     *UiAPIService
	arraySeparator *string
	fields         *[]string
	filter         *[]string
	orders         *[]string
	page           *int32
	pageSize       *int32
	paging         *bool
	rootJunction   *string
	separator      *string
	skipHeader     *bool
}

// [no description yet]
func (r ApiDashboardGetObjectListCsvRequest) ArraySeparator(arraySeparator string) ApiDashboardGetObjectListCsvRequest {
	r.arraySeparator = &arraySeparator
	return r
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiDashboardGetObjectListCsvRequest) Fields(fields []string) ApiDashboardGetObjectListCsvRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiDashboardGetObjectListCsvRequest) Filter(filter []string) ApiDashboardGetObjectListCsvRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiDashboardGetObjectListCsvRequest) Orders(orders []string) ApiDashboardGetObjectListCsvRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiDashboardGetObjectListCsvRequest) Page(page int32) ApiDashboardGetObjectListCsvRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiDashboardGetObjectListCsvRequest) PageSize(pageSize int32) ApiDashboardGetObjectListCsvRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiDashboardGetObjectListCsvRequest) Paging(paging bool) ApiDashboardGetObjectListCsvRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiDashboardGetObjectListCsvRequest) RootJunction(rootJunction string) ApiDashboardGetObjectListCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiDashboardGetObjectListCsvRequest) Separator(separator string) ApiDashboardGetObjectListCsvRequest {
	r.separator = &separator
	return r
}

// [no description yet]
func (r ApiDashboardGetObjectListCsvRequest) SkipHeader(skipHeader bool) ApiDashboardGetObjectListCsvRequest {
	r.skipHeader = &skipHeader
	return r
}

func (r ApiDashboardGetObjectListCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.DashboardGetObjectListCsvExecute(r)
}

/*
DashboardGetObjectListCsv Method for DashboardGetObjectListCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDashboardGetObjectListCsvRequest
*/
func (a *UiAPIService) DashboardGetObjectListCsv(ctx context.Context) ApiDashboardGetObjectListCsvRequest {
	return ApiDashboardGetObjectListCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *UiAPIService) DashboardGetObjectListCsvExecute(r ApiDashboardGetObjectListCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardGetObjectListCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/#getObjectListCsv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.arraySeparator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arraySeparator", r.arraySeparator, "")
	} else {
		var defaultValue string = ";"
		r.arraySeparator = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.separator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "separator", r.separator, "")
	} else {
		var defaultValue string = ","
		r.separator = &defaultValue
	}
	if r.skipHeader != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipHeader", r.skipHeader, "")
	} else {
		var defaultValue bool = false
		r.skipHeader = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/text", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardGetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiDashboardGetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiDashboardGetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiDashboardGetObjectListGistAsCsvRequest) Auto(auto string) ApiDashboardGetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiDashboardGetObjectListGistAsCsvRequest) Describe(describe bool) ApiDashboardGetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiDashboardGetObjectListGistAsCsvRequest) Fields(fields string) ApiDashboardGetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiDashboardGetObjectListGistAsCsvRequest) Filter(filter string) ApiDashboardGetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiDashboardGetObjectListGistAsCsvRequest) Headless(headless bool) ApiDashboardGetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiDashboardGetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiDashboardGetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiDashboardGetObjectListGistAsCsvRequest) Locale(locale string) ApiDashboardGetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiDashboardGetObjectListGistAsCsvRequest) Order(order string) ApiDashboardGetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiDashboardGetObjectListGistAsCsvRequest) Page(page int32) ApiDashboardGetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiDashboardGetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiDashboardGetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiDashboardGetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiDashboardGetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiDashboardGetObjectListGistAsCsvRequest) References(references bool) ApiDashboardGetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiDashboardGetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiDashboardGetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiDashboardGetObjectListGistAsCsvRequest) Total(total bool) ApiDashboardGetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiDashboardGetObjectListGistAsCsvRequest) Translate(translate bool) ApiDashboardGetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiDashboardGetObjectListGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.DashboardGetObjectListGistAsCsvExecute(r)
}

/*
DashboardGetObjectListGistAsCsv Method for DashboardGetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDashboardGetObjectListGistAsCsvRequest
*/
func (a *UiAPIService) DashboardGetObjectListGistAsCsv(ctx context.Context) ApiDashboardGetObjectListGistAsCsvRequest {
	return ApiDashboardGetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *UiAPIService) DashboardGetObjectListGistAsCsvExecute(r ApiDashboardGetObjectListGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardGetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/gist.csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest) Auto(auto string) ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest) Describe(describe bool) ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest) Fields(fields string) ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest) Filter(filter string) ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest) Headless(headless bool) ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest) Locale(locale string) ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest) Order(order string) ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest) Page(page int32) ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest) References(references bool) ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest) Total(total bool) ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest) Translate(translate bool) ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest) Execute() (*DashboardGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.DashboardGetObjectListGistgetObjectListGistAsCsvExecute(r)
}

/*
DashboardGetObjectListGistgetObjectListGistAsCsv Method for DashboardGetObjectListGistgetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest
*/
func (a *UiAPIService) DashboardGetObjectListGistgetObjectListGistAsCsv(ctx context.Context) ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest {
	return ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DashboardGetObjectListGistGetObjectListGistAsCsv200Response
func (a *UiAPIService) DashboardGetObjectListGistgetObjectListGistAsCsvExecute(r ApiDashboardGetObjectListGistgetObjectListGistAsCsvRequest) (*DashboardGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DashboardGetObjectListGistGetObjectListGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardGetObjectListGistgetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/gist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardGetObjectPropertyRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	property     string
	uid          string
	fields       *[]string
	locale       *string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
	translate    *bool
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiDashboardGetObjectPropertyRequest) Fields(fields []string) ApiDashboardGetObjectPropertyRequest {
	r.fields = &fields
	return r
}

// [no description yet]
func (r ApiDashboardGetObjectPropertyRequest) Locale(locale string) ApiDashboardGetObjectPropertyRequest {
	r.locale = &locale
	return r
}

// Defines which page number to return.
func (r ApiDashboardGetObjectPropertyRequest) Page(page int32) ApiDashboardGetObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiDashboardGetObjectPropertyRequest) PageSize(pageSize int32) ApiDashboardGetObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiDashboardGetObjectPropertyRequest) Paging(paging bool) ApiDashboardGetObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiDashboardGetObjectPropertyRequest) RootJunction(rootJunction string) ApiDashboardGetObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiDashboardGetObjectPropertyRequest) Translate(translate bool) ApiDashboardGetObjectPropertyRequest {
	r.translate = &translate
	return r
}

func (r ApiDashboardGetObjectPropertyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DashboardGetObjectPropertyExecute(r)
}

/*
DashboardGetObjectProperty Method for DashboardGetObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiDashboardGetObjectPropertyRequest
*/
func (a *UiAPIService) DashboardGetObjectProperty(ctx context.Context, property string, uid string) ApiDashboardGetObjectPropertyRequest {
	return ApiDashboardGetObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *UiAPIService) DashboardGetObjectPropertyExecute(r ApiDashboardGetObjectPropertyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardGetObjectProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardGetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiDashboardGetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiDashboardGetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiDashboardGetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiDashboardGetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiDashboardGetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiDashboardGetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiDashboardGetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiDashboardGetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiDashboardGetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiDashboardGetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiDashboardGetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiDashboardGetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiDashboardGetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiDashboardGetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiDashboardGetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiDashboardGetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiDashboardGetObjectPropertyGistAsCsvRequest) Order(order string) ApiDashboardGetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiDashboardGetObjectPropertyGistAsCsvRequest) Page(page int32) ApiDashboardGetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiDashboardGetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiDashboardGetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiDashboardGetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiDashboardGetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiDashboardGetObjectPropertyGistAsCsvRequest) References(references bool) ApiDashboardGetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiDashboardGetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiDashboardGetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiDashboardGetObjectPropertyGistAsCsvRequest) Total(total bool) ApiDashboardGetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiDashboardGetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiDashboardGetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiDashboardGetObjectPropertyGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.DashboardGetObjectPropertyGistAsCsvExecute(r)
}

/*
DashboardGetObjectPropertyGistAsCsv Method for DashboardGetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiDashboardGetObjectPropertyGistAsCsvRequest
*/
func (a *UiAPIService) DashboardGetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiDashboardGetObjectPropertyGistAsCsvRequest {
	return ApiDashboardGetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *UiAPIService) DashboardGetObjectPropertyGistAsCsvExecute(r ApiDashboardGetObjectPropertyGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardGetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{uid}/{property}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Order(order string) ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Page(page int32) ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) References(references bool) ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Total(total bool) ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Execute() (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.DashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r)
}

/*
DashboardGetObjectPropertyGistgetObjectPropertyGistAsCsv Method for DashboardGetObjectPropertyGistgetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest
*/
func (a *UiAPIService) DashboardGetObjectPropertyGistgetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	return ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
func (a *UiAPIService) DashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r ApiDashboardGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardGetObjectPropertyGistgetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{uid}/{property}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardItemAddCollectionItemRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiDashboardItemAddCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardItemAddCollectionItemExecute(r)
}

/*
DashboardItemAddCollectionItem Method for DashboardItemAddCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiDashboardItemAddCollectionItemRequest
*/
func (a *UiAPIService) DashboardItemAddCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiDashboardItemAddCollectionItemRequest {
	return ApiDashboardItemAddCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardItemAddCollectionItemExecute(r ApiDashboardItemAddCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemAddCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardItemAddCollectionItemsJsonaddCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *UiAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiDashboardItemAddCollectionItemsJsonaddCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiDashboardItemAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiDashboardItemAddCollectionItemsJsonaddCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardItemAddCollectionItemsJsonaddCollectionItemsXmlExecute(r)
}

/*
DashboardItemAddCollectionItemsJsonaddCollectionItemsXml Method for DashboardItemAddCollectionItemsJsonaddCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiDashboardItemAddCollectionItemsJsonaddCollectionItemsXmlRequest
*/
func (a *UiAPIService) DashboardItemAddCollectionItemsJsonaddCollectionItemsXml(ctx context.Context, property string, uid string) ApiDashboardItemAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	return ApiDashboardItemAddCollectionItemsJsonaddCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardItemAddCollectionItemsJsonaddCollectionItemsXmlExecute(r ApiDashboardItemAddCollectionItemsJsonaddCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemAddCollectionItemsJsonaddCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardItemBulkSharingRequest struct {
	ctx                context.Context
	ApiService         *UiAPIService
	atomic             *bool
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	bulkJsonPatch      *BulkJsonPatch
}

// [no description yet]
func (r ApiDashboardItemBulkSharingRequest) Atomic(atomic bool) ApiDashboardItemBulkSharingRequest {
	r.atomic = &atomic
	return r
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiDashboardItemBulkSharingRequest) AtomicMode(atomicMode string) ApiDashboardItemBulkSharingRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiDashboardItemBulkSharingRequest) FlushMode(flushMode string) ApiDashboardItemBulkSharingRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiDashboardItemBulkSharingRequest) Identifier(identifier string) ApiDashboardItemBulkSharingRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiDashboardItemBulkSharingRequest) ImportMode(importMode string) ApiDashboardItemBulkSharingRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiDashboardItemBulkSharingRequest) ImportReportMode(importReportMode string) ApiDashboardItemBulkSharingRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiDashboardItemBulkSharingRequest) ImportStrategy(importStrategy string) ApiDashboardItemBulkSharingRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiDashboardItemBulkSharingRequest) MergeMode(mergeMode string) ApiDashboardItemBulkSharingRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiDashboardItemBulkSharingRequest) MetadataSyncImport(metadataSyncImport bool) ApiDashboardItemBulkSharingRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiDashboardItemBulkSharingRequest) Page(page int32) ApiDashboardItemBulkSharingRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiDashboardItemBulkSharingRequest) PageSize(pageSize int32) ApiDashboardItemBulkSharingRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiDashboardItemBulkSharingRequest) Paging(paging bool) ApiDashboardItemBulkSharingRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiDashboardItemBulkSharingRequest) PreheatMode(preheatMode string) ApiDashboardItemBulkSharingRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiDashboardItemBulkSharingRequest) RootJunction(rootJunction string) ApiDashboardItemBulkSharingRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiDashboardItemBulkSharingRequest) SkipSharing(skipSharing bool) ApiDashboardItemBulkSharingRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiDashboardItemBulkSharingRequest) SkipTranslation(skipTranslation bool) ApiDashboardItemBulkSharingRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiDashboardItemBulkSharingRequest) SkipValidation(skipValidation bool) ApiDashboardItemBulkSharingRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiDashboardItemBulkSharingRequest) UserOverrideMode(userOverrideMode string) ApiDashboardItemBulkSharingRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiDashboardItemBulkSharingRequest) BulkJsonPatch(bulkJsonPatch BulkJsonPatch) ApiDashboardItemBulkSharingRequest {
	r.bulkJsonPatch = &bulkJsonPatch
	return r
}

func (r ApiDashboardItemBulkSharingRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardItemBulkSharingExecute(r)
}

/*
DashboardItemBulkSharing Method for DashboardItemBulkSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDashboardItemBulkSharingRequest
*/
func (a *UiAPIService) DashboardItemBulkSharing(ctx context.Context) ApiDashboardItemBulkSharingRequest {
	return ApiDashboardItemBulkSharingRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardItemBulkSharingExecute(r ApiDashboardItemBulkSharingRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemBulkSharing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/sharing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomic", r.atomic, "")
	} else {
		var defaultValue bool = false
		r.atomic = &defaultValue
	}
	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkJsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardItemDeleteCollectionItemRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiDashboardItemDeleteCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardItemDeleteCollectionItemExecute(r)
}

/*
DashboardItemDeleteCollectionItem Method for DashboardItemDeleteCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiDashboardItemDeleteCollectionItemRequest
*/
func (a *UiAPIService) DashboardItemDeleteCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiDashboardItemDeleteCollectionItemRequest {
	return ApiDashboardItemDeleteCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardItemDeleteCollectionItemExecute(r ApiDashboardItemDeleteCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemDeleteCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardItemDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *UiAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiDashboardItemDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiDashboardItemDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiDashboardItemDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardItemDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r)
}

/*
DashboardItemDeleteCollectionItemsJsondeleteCollectionItemsXml Method for DashboardItemDeleteCollectionItemsJsondeleteCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiDashboardItemDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest
*/
func (a *UiAPIService) DashboardItemDeleteCollectionItemsJsondeleteCollectionItemsXml(ctx context.Context, property string, uid string) ApiDashboardItemDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	return ApiDashboardItemDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardItemDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r ApiDashboardItemDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemDeleteCollectionItemsJsondeleteCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardItemDeleteObjectRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
}

func (r ApiDashboardItemDeleteObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardItemDeleteObjectExecute(r)
}

/*
DashboardItemDeleteObject Method for DashboardItemDeleteObject

Deletes the DashboardItem provided by ID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardItemDeleteObjectRequest
*/
func (a *UiAPIService) DashboardItemDeleteObject(ctx context.Context, uid string) ApiDashboardItemDeleteObjectRequest {
	return ApiDashboardItemDeleteObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardItemDeleteObjectExecute(r ApiDashboardItemDeleteObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemDeleteObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardItemGetObjectRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	uid          string
	fields       *[]string
	filter       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiDashboardItemGetObjectRequest) Fields(fields []string) ApiDashboardItemGetObjectRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiDashboardItemGetObjectRequest) Filter(filter []string) ApiDashboardItemGetObjectRequest {
	r.filter = &filter
	return r
}

// Defines which page number to return.
func (r ApiDashboardItemGetObjectRequest) Page(page int32) ApiDashboardItemGetObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiDashboardItemGetObjectRequest) PageSize(pageSize int32) ApiDashboardItemGetObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiDashboardItemGetObjectRequest) Paging(paging bool) ApiDashboardItemGetObjectRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiDashboardItemGetObjectRequest) RootJunction(rootJunction string) ApiDashboardItemGetObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiDashboardItemGetObjectRequest) Execute() (*DashboardItem, *http.Response, error) {
	return r.ApiService.DashboardItemGetObjectExecute(r)
}

/*
DashboardItemGetObject Method for DashboardItemGetObject

View a DashboardItem

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardItemGetObjectRequest
*/
func (a *UiAPIService) DashboardItemGetObject(ctx context.Context, uid string) ApiDashboardItemGetObjectRequest {
	return ApiDashboardItemGetObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return DashboardItem
func (a *UiAPIService) DashboardItemGetObjectExecute(r ApiDashboardItemGetObjectRequest) (*DashboardItem, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DashboardItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemGetObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardItemGetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiDashboardItemGetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiDashboardItemGetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiDashboardItemGetObjectGistAsCsvRequest) Auto(auto string) ApiDashboardItemGetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiDashboardItemGetObjectGistAsCsvRequest) Describe(describe bool) ApiDashboardItemGetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiDashboardItemGetObjectGistAsCsvRequest) Fields(fields string) ApiDashboardItemGetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiDashboardItemGetObjectGistAsCsvRequest) Filter(filter string) ApiDashboardItemGetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiDashboardItemGetObjectGistAsCsvRequest) Headless(headless bool) ApiDashboardItemGetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiDashboardItemGetObjectGistAsCsvRequest) Inverse(inverse bool) ApiDashboardItemGetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiDashboardItemGetObjectGistAsCsvRequest) Locale(locale string) ApiDashboardItemGetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiDashboardItemGetObjectGistAsCsvRequest) Order(order string) ApiDashboardItemGetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiDashboardItemGetObjectGistAsCsvRequest) Page(page int32) ApiDashboardItemGetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiDashboardItemGetObjectGistAsCsvRequest) PageListName(pageListName string) ApiDashboardItemGetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiDashboardItemGetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiDashboardItemGetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiDashboardItemGetObjectGistAsCsvRequest) References(references bool) ApiDashboardItemGetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiDashboardItemGetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiDashboardItemGetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiDashboardItemGetObjectGistAsCsvRequest) Total(total bool) ApiDashboardItemGetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiDashboardItemGetObjectGistAsCsvRequest) Translate(translate bool) ApiDashboardItemGetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiDashboardItemGetObjectGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.DashboardItemGetObjectGistAsCsvExecute(r)
}

/*
DashboardItemGetObjectGistAsCsv Method for DashboardItemGetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardItemGetObjectGistAsCsvRequest
*/
func (a *UiAPIService) DashboardItemGetObjectGistAsCsv(ctx context.Context, uid string) ApiDashboardItemGetObjectGistAsCsvRequest {
	return ApiDashboardItemGetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *UiAPIService) DashboardItemGetObjectGistAsCsvExecute(r ApiDashboardItemGetObjectGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemGetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/{uid}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest) Auto(auto string) ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest) Describe(describe bool) ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest) Fields(fields string) ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest) Filter(filter string) ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest) Headless(headless bool) ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest) Inverse(inverse bool) ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest) Locale(locale string) ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest) Order(order string) ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest) Page(page int32) ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest) PageListName(pageListName string) ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest) References(references bool) ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest) Total(total bool) ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest) Translate(translate bool) ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DashboardItemGetObjectGistgetObjectGistAsCsvExecute(r)
}

/*
DashboardItemGetObjectGistgetObjectGistAsCsv Method for DashboardItemGetObjectGistgetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest
*/
func (a *UiAPIService) DashboardItemGetObjectGistgetObjectGistAsCsv(ctx context.Context, uid string) ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest {
	return ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *UiAPIService) DashboardItemGetObjectGistgetObjectGistAsCsvExecute(r ApiDashboardItemGetObjectGistgetObjectGistAsCsvRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemGetObjectGistgetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/{uid}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardItemGetObjectListRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	fields       *[]string
	filter       *[]string
	orders       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// &#x60;&lt;field-name&gt;[,&lt;field-name&gt;...]&#x60;
func (r ApiDashboardItemGetObjectListRequest) Fields(fields []string) ApiDashboardItemGetObjectListRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiDashboardItemGetObjectListRequest) Filter(filter []string) ApiDashboardItemGetObjectListRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiDashboardItemGetObjectListRequest) Orders(orders []string) ApiDashboardItemGetObjectListRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiDashboardItemGetObjectListRequest) Page(page int32) ApiDashboardItemGetObjectListRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiDashboardItemGetObjectListRequest) PageSize(pageSize int32) ApiDashboardItemGetObjectListRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiDashboardItemGetObjectListRequest) Paging(paging bool) ApiDashboardItemGetObjectListRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiDashboardItemGetObjectListRequest) RootJunction(rootJunction string) ApiDashboardItemGetObjectListRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiDashboardItemGetObjectListRequest) Execute() (*DashboardItemGetObjectList200Response, *http.Response, error) {
	return r.ApiService.DashboardItemGetObjectListExecute(r)
}

/*
DashboardItemGetObjectList Method for DashboardItemGetObjectList

List all DashboardItems

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDashboardItemGetObjectListRequest
*/
func (a *UiAPIService) DashboardItemGetObjectList(ctx context.Context) ApiDashboardItemGetObjectListRequest {
	return ApiDashboardItemGetObjectListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DashboardItemGetObjectList200Response
func (a *UiAPIService) DashboardItemGetObjectListExecute(r ApiDashboardItemGetObjectListRequest) (*DashboardItemGetObjectList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DashboardItemGetObjectList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemGetObjectList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardItemGetObjectListCsvRequest struct {
	ctx            context.Context
	ApiService     *UiAPIService
	arraySeparator *string
	fields         *[]string
	filter         *[]string
	orders         *[]string
	page           *int32
	pageSize       *int32
	paging         *bool
	rootJunction   *string
	separator      *string
	skipHeader     *bool
}

// [no description yet]
func (r ApiDashboardItemGetObjectListCsvRequest) ArraySeparator(arraySeparator string) ApiDashboardItemGetObjectListCsvRequest {
	r.arraySeparator = &arraySeparator
	return r
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiDashboardItemGetObjectListCsvRequest) Fields(fields []string) ApiDashboardItemGetObjectListCsvRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiDashboardItemGetObjectListCsvRequest) Filter(filter []string) ApiDashboardItemGetObjectListCsvRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiDashboardItemGetObjectListCsvRequest) Orders(orders []string) ApiDashboardItemGetObjectListCsvRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiDashboardItemGetObjectListCsvRequest) Page(page int32) ApiDashboardItemGetObjectListCsvRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiDashboardItemGetObjectListCsvRequest) PageSize(pageSize int32) ApiDashboardItemGetObjectListCsvRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiDashboardItemGetObjectListCsvRequest) Paging(paging bool) ApiDashboardItemGetObjectListCsvRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiDashboardItemGetObjectListCsvRequest) RootJunction(rootJunction string) ApiDashboardItemGetObjectListCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiDashboardItemGetObjectListCsvRequest) Separator(separator string) ApiDashboardItemGetObjectListCsvRequest {
	r.separator = &separator
	return r
}

// [no description yet]
func (r ApiDashboardItemGetObjectListCsvRequest) SkipHeader(skipHeader bool) ApiDashboardItemGetObjectListCsvRequest {
	r.skipHeader = &skipHeader
	return r
}

func (r ApiDashboardItemGetObjectListCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.DashboardItemGetObjectListCsvExecute(r)
}

/*
DashboardItemGetObjectListCsv Method for DashboardItemGetObjectListCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDashboardItemGetObjectListCsvRequest
*/
func (a *UiAPIService) DashboardItemGetObjectListCsv(ctx context.Context) ApiDashboardItemGetObjectListCsvRequest {
	return ApiDashboardItemGetObjectListCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *UiAPIService) DashboardItemGetObjectListCsvExecute(r ApiDashboardItemGetObjectListCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemGetObjectListCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/#getObjectListCsv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.arraySeparator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arraySeparator", r.arraySeparator, "")
	} else {
		var defaultValue string = ";"
		r.arraySeparator = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.separator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "separator", r.separator, "")
	} else {
		var defaultValue string = ","
		r.separator = &defaultValue
	}
	if r.skipHeader != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipHeader", r.skipHeader, "")
	} else {
		var defaultValue bool = false
		r.skipHeader = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/text", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardItemGetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiDashboardItemGetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiDashboardItemGetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiDashboardItemGetObjectListGistAsCsvRequest) Auto(auto string) ApiDashboardItemGetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiDashboardItemGetObjectListGistAsCsvRequest) Describe(describe bool) ApiDashboardItemGetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiDashboardItemGetObjectListGistAsCsvRequest) Fields(fields string) ApiDashboardItemGetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiDashboardItemGetObjectListGistAsCsvRequest) Filter(filter string) ApiDashboardItemGetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiDashboardItemGetObjectListGistAsCsvRequest) Headless(headless bool) ApiDashboardItemGetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiDashboardItemGetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiDashboardItemGetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiDashboardItemGetObjectListGistAsCsvRequest) Locale(locale string) ApiDashboardItemGetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiDashboardItemGetObjectListGistAsCsvRequest) Order(order string) ApiDashboardItemGetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiDashboardItemGetObjectListGistAsCsvRequest) Page(page int32) ApiDashboardItemGetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiDashboardItemGetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiDashboardItemGetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiDashboardItemGetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiDashboardItemGetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiDashboardItemGetObjectListGistAsCsvRequest) References(references bool) ApiDashboardItemGetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiDashboardItemGetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiDashboardItemGetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiDashboardItemGetObjectListGistAsCsvRequest) Total(total bool) ApiDashboardItemGetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiDashboardItemGetObjectListGistAsCsvRequest) Translate(translate bool) ApiDashboardItemGetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiDashboardItemGetObjectListGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.DashboardItemGetObjectListGistAsCsvExecute(r)
}

/*
DashboardItemGetObjectListGistAsCsv Method for DashboardItemGetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDashboardItemGetObjectListGistAsCsvRequest
*/
func (a *UiAPIService) DashboardItemGetObjectListGistAsCsv(ctx context.Context) ApiDashboardItemGetObjectListGistAsCsvRequest {
	return ApiDashboardItemGetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *UiAPIService) DashboardItemGetObjectListGistAsCsvExecute(r ApiDashboardItemGetObjectListGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemGetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/gist.csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest) Auto(auto string) ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest) Describe(describe bool) ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest) Fields(fields string) ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest) Filter(filter string) ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest) Headless(headless bool) ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest) Locale(locale string) ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest) Order(order string) ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest) Page(page int32) ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest) References(references bool) ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest) Total(total bool) ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest) Translate(translate bool) ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest) Execute() (*DashboardItemGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.DashboardItemGetObjectListGistgetObjectListGistAsCsvExecute(r)
}

/*
DashboardItemGetObjectListGistgetObjectListGistAsCsv Method for DashboardItemGetObjectListGistgetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest
*/
func (a *UiAPIService) DashboardItemGetObjectListGistgetObjectListGistAsCsv(ctx context.Context) ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest {
	return ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DashboardItemGetObjectListGistGetObjectListGistAsCsv200Response
func (a *UiAPIService) DashboardItemGetObjectListGistgetObjectListGistAsCsvExecute(r ApiDashboardItemGetObjectListGistgetObjectListGistAsCsvRequest) (*DashboardItemGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DashboardItemGetObjectListGistGetObjectListGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemGetObjectListGistgetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/gist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardItemGetObjectPropertyRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	property     string
	uid          string
	fields       *[]string
	locale       *string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
	translate    *bool
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiDashboardItemGetObjectPropertyRequest) Fields(fields []string) ApiDashboardItemGetObjectPropertyRequest {
	r.fields = &fields
	return r
}

// [no description yet]
func (r ApiDashboardItemGetObjectPropertyRequest) Locale(locale string) ApiDashboardItemGetObjectPropertyRequest {
	r.locale = &locale
	return r
}

// Defines which page number to return.
func (r ApiDashboardItemGetObjectPropertyRequest) Page(page int32) ApiDashboardItemGetObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiDashboardItemGetObjectPropertyRequest) PageSize(pageSize int32) ApiDashboardItemGetObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiDashboardItemGetObjectPropertyRequest) Paging(paging bool) ApiDashboardItemGetObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiDashboardItemGetObjectPropertyRequest) RootJunction(rootJunction string) ApiDashboardItemGetObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiDashboardItemGetObjectPropertyRequest) Translate(translate bool) ApiDashboardItemGetObjectPropertyRequest {
	r.translate = &translate
	return r
}

func (r ApiDashboardItemGetObjectPropertyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DashboardItemGetObjectPropertyExecute(r)
}

/*
DashboardItemGetObjectProperty Method for DashboardItemGetObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiDashboardItemGetObjectPropertyRequest
*/
func (a *UiAPIService) DashboardItemGetObjectProperty(ctx context.Context, property string, uid string) ApiDashboardItemGetObjectPropertyRequest {
	return ApiDashboardItemGetObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *UiAPIService) DashboardItemGetObjectPropertyExecute(r ApiDashboardItemGetObjectPropertyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemGetObjectProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardItemGetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiDashboardItemGetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiDashboardItemGetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiDashboardItemGetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiDashboardItemGetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiDashboardItemGetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiDashboardItemGetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiDashboardItemGetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiDashboardItemGetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiDashboardItemGetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiDashboardItemGetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiDashboardItemGetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiDashboardItemGetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiDashboardItemGetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiDashboardItemGetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiDashboardItemGetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiDashboardItemGetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiDashboardItemGetObjectPropertyGistAsCsvRequest) Order(order string) ApiDashboardItemGetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiDashboardItemGetObjectPropertyGistAsCsvRequest) Page(page int32) ApiDashboardItemGetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiDashboardItemGetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiDashboardItemGetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiDashboardItemGetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiDashboardItemGetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiDashboardItemGetObjectPropertyGistAsCsvRequest) References(references bool) ApiDashboardItemGetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiDashboardItemGetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiDashboardItemGetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiDashboardItemGetObjectPropertyGistAsCsvRequest) Total(total bool) ApiDashboardItemGetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiDashboardItemGetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiDashboardItemGetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiDashboardItemGetObjectPropertyGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.DashboardItemGetObjectPropertyGistAsCsvExecute(r)
}

/*
DashboardItemGetObjectPropertyGistAsCsv Method for DashboardItemGetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiDashboardItemGetObjectPropertyGistAsCsvRequest
*/
func (a *UiAPIService) DashboardItemGetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiDashboardItemGetObjectPropertyGistAsCsvRequest {
	return ApiDashboardItemGetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *UiAPIService) DashboardItemGetObjectPropertyGistAsCsvExecute(r ApiDashboardItemGetObjectPropertyGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemGetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/{uid}/{property}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Order(order string) ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Page(page int32) ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) References(references bool) ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Total(total bool) ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Execute() (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.DashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r)
}

/*
DashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsv Method for DashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest
*/
func (a *UiAPIService) DashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	return ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
func (a *UiAPIService) DashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r ApiDashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemGetObjectPropertyGistgetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/{uid}/{property}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardItemPatchObjectRequest struct {
	ctx                context.Context
	ApiService         *UiAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	jsonPatch          *JsonPatch
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiDashboardItemPatchObjectRequest) AtomicMode(atomicMode string) ApiDashboardItemPatchObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiDashboardItemPatchObjectRequest) FlushMode(flushMode string) ApiDashboardItemPatchObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiDashboardItemPatchObjectRequest) Identifier(identifier string) ApiDashboardItemPatchObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiDashboardItemPatchObjectRequest) ImportMode(importMode string) ApiDashboardItemPatchObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiDashboardItemPatchObjectRequest) ImportReportMode(importReportMode string) ApiDashboardItemPatchObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiDashboardItemPatchObjectRequest) ImportStrategy(importStrategy string) ApiDashboardItemPatchObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiDashboardItemPatchObjectRequest) MergeMode(mergeMode string) ApiDashboardItemPatchObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiDashboardItemPatchObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiDashboardItemPatchObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiDashboardItemPatchObjectRequest) Page(page int32) ApiDashboardItemPatchObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiDashboardItemPatchObjectRequest) PageSize(pageSize int32) ApiDashboardItemPatchObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiDashboardItemPatchObjectRequest) Paging(paging bool) ApiDashboardItemPatchObjectRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiDashboardItemPatchObjectRequest) PreheatMode(preheatMode string) ApiDashboardItemPatchObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiDashboardItemPatchObjectRequest) RootJunction(rootJunction string) ApiDashboardItemPatchObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiDashboardItemPatchObjectRequest) SkipSharing(skipSharing bool) ApiDashboardItemPatchObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiDashboardItemPatchObjectRequest) SkipTranslation(skipTranslation bool) ApiDashboardItemPatchObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiDashboardItemPatchObjectRequest) SkipValidation(skipValidation bool) ApiDashboardItemPatchObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiDashboardItemPatchObjectRequest) UserOverrideMode(userOverrideMode string) ApiDashboardItemPatchObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiDashboardItemPatchObjectRequest) JsonPatch(jsonPatch JsonPatch) ApiDashboardItemPatchObjectRequest {
	r.jsonPatch = &jsonPatch
	return r
}

func (r ApiDashboardItemPatchObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardItemPatchObjectExecute(r)
}

/*
DashboardItemPatchObject Method for DashboardItemPatchObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardItemPatchObjectRequest
*/
func (a *UiAPIService) DashboardItemPatchObject(ctx context.Context, uid string) ApiDashboardItemPatchObjectRequest {
	return ApiDashboardItemPatchObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardItemPatchObjectExecute(r ApiDashboardItemPatchObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemPatchObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardItemPostJsonObjectpostXmlObjectRequest struct {
	ctx                context.Context
	ApiService         *UiAPIService
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	preheatMode        *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	dashboardItem      *DashboardItem
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiDashboardItemPostJsonObjectpostXmlObjectRequest) AtomicMode(atomicMode string) ApiDashboardItemPostJsonObjectpostXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiDashboardItemPostJsonObjectpostXmlObjectRequest) FlushMode(flushMode string) ApiDashboardItemPostJsonObjectpostXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiDashboardItemPostJsonObjectpostXmlObjectRequest) Identifier(identifier string) ApiDashboardItemPostJsonObjectpostXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiDashboardItemPostJsonObjectpostXmlObjectRequest) ImportMode(importMode string) ApiDashboardItemPostJsonObjectpostXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiDashboardItemPostJsonObjectpostXmlObjectRequest) ImportReportMode(importReportMode string) ApiDashboardItemPostJsonObjectpostXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiDashboardItemPostJsonObjectpostXmlObjectRequest) ImportStrategy(importStrategy string) ApiDashboardItemPostJsonObjectpostXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiDashboardItemPostJsonObjectpostXmlObjectRequest) MergeMode(mergeMode string) ApiDashboardItemPostJsonObjectpostXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiDashboardItemPostJsonObjectpostXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiDashboardItemPostJsonObjectpostXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiDashboardItemPostJsonObjectpostXmlObjectRequest) PreheatMode(preheatMode string) ApiDashboardItemPostJsonObjectpostXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiDashboardItemPostJsonObjectpostXmlObjectRequest) SkipSharing(skipSharing bool) ApiDashboardItemPostJsonObjectpostXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiDashboardItemPostJsonObjectpostXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiDashboardItemPostJsonObjectpostXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiDashboardItemPostJsonObjectpostXmlObjectRequest) SkipValidation(skipValidation bool) ApiDashboardItemPostJsonObjectpostXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiDashboardItemPostJsonObjectpostXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiDashboardItemPostJsonObjectpostXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiDashboardItemPostJsonObjectpostXmlObjectRequest) DashboardItem(dashboardItem DashboardItem) ApiDashboardItemPostJsonObjectpostXmlObjectRequest {
	r.dashboardItem = &dashboardItem
	return r
}

func (r ApiDashboardItemPostJsonObjectpostXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardItemPostJsonObjectpostXmlObjectExecute(r)
}

/*
DashboardItemPostJsonObjectpostXmlObject Method for DashboardItemPostJsonObjectpostXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDashboardItemPostJsonObjectpostXmlObjectRequest
*/
func (a *UiAPIService) DashboardItemPostJsonObjectpostXmlObject(ctx context.Context) ApiDashboardItemPostJsonObjectpostXmlObjectRequest {
	return ApiDashboardItemPostJsonObjectpostXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardItemPostJsonObjectpostXmlObjectExecute(r ApiDashboardItemPostJsonObjectpostXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemPostJsonObjectpostXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dashboardItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardItemPutDashboardItemShapeRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	shape      string
	uid        string
}

func (r ApiDashboardItemPutDashboardItemShapeRequest) Execute() (*http.Response, error) {
	return r.ApiService.DashboardItemPutDashboardItemShapeExecute(r)
}

/*
DashboardItemPutDashboardItemShape Method for DashboardItemPutDashboardItemShape

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shape [no description yet]
	@param uid [no description yet]
	@return ApiDashboardItemPutDashboardItemShapeRequest
*/
func (a *UiAPIService) DashboardItemPutDashboardItemShape(ctx context.Context, shape string, uid string) ApiDashboardItemPutDashboardItemShapeRequest {
	return ApiDashboardItemPutDashboardItemShapeRequest{
		ApiService: a,
		ctx:        ctx,
		shape:      shape,
		uid:        uid,
	}
}

// Execute executes the request
func (a *UiAPIService) DashboardItemPutDashboardItemShapeExecute(r ApiDashboardItemPutDashboardItemShapeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemPutDashboardItemShape")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/{uid}/shape/{shape}"
	localVarPath = strings.Replace(localVarPath, "{"+"shape"+"}", url.PathEscape(parameterValueToString(r.shape, "shape")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDashboardItemPutJsonObjectputXmlObjectRequest struct {
	ctx                context.Context
	ApiService         *UiAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	preheatMode        *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	dashboardItem      *DashboardItem
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiDashboardItemPutJsonObjectputXmlObjectRequest) AtomicMode(atomicMode string) ApiDashboardItemPutJsonObjectputXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiDashboardItemPutJsonObjectputXmlObjectRequest) FlushMode(flushMode string) ApiDashboardItemPutJsonObjectputXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiDashboardItemPutJsonObjectputXmlObjectRequest) Identifier(identifier string) ApiDashboardItemPutJsonObjectputXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiDashboardItemPutJsonObjectputXmlObjectRequest) ImportMode(importMode string) ApiDashboardItemPutJsonObjectputXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiDashboardItemPutJsonObjectputXmlObjectRequest) ImportReportMode(importReportMode string) ApiDashboardItemPutJsonObjectputXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiDashboardItemPutJsonObjectputXmlObjectRequest) ImportStrategy(importStrategy string) ApiDashboardItemPutJsonObjectputXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiDashboardItemPutJsonObjectputXmlObjectRequest) MergeMode(mergeMode string) ApiDashboardItemPutJsonObjectputXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiDashboardItemPutJsonObjectputXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiDashboardItemPutJsonObjectputXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiDashboardItemPutJsonObjectputXmlObjectRequest) PreheatMode(preheatMode string) ApiDashboardItemPutJsonObjectputXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiDashboardItemPutJsonObjectputXmlObjectRequest) SkipSharing(skipSharing bool) ApiDashboardItemPutJsonObjectputXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiDashboardItemPutJsonObjectputXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiDashboardItemPutJsonObjectputXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiDashboardItemPutJsonObjectputXmlObjectRequest) SkipValidation(skipValidation bool) ApiDashboardItemPutJsonObjectputXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiDashboardItemPutJsonObjectputXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiDashboardItemPutJsonObjectputXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiDashboardItemPutJsonObjectputXmlObjectRequest) DashboardItem(dashboardItem DashboardItem) ApiDashboardItemPutJsonObjectputXmlObjectRequest {
	r.dashboardItem = &dashboardItem
	return r
}

func (r ApiDashboardItemPutJsonObjectputXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardItemPutJsonObjectputXmlObjectExecute(r)
}

/*
DashboardItemPutJsonObjectputXmlObject Method for DashboardItemPutJsonObjectputXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardItemPutJsonObjectputXmlObjectRequest
*/
func (a *UiAPIService) DashboardItemPutJsonObjectputXmlObject(ctx context.Context, uid string) ApiDashboardItemPutJsonObjectputXmlObjectRequest {
	return ApiDashboardItemPutJsonObjectputXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardItemPutJsonObjectputXmlObjectExecute(r ApiDashboardItemPutJsonObjectputXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemPutJsonObjectputXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dashboardItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardItemRemoveAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
}

func (r ApiDashboardItemRemoveAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardItemRemoveAsFavoriteExecute(r)
}

/*
DashboardItemRemoveAsFavorite Method for DashboardItemRemoveAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardItemRemoveAsFavoriteRequest
*/
func (a *UiAPIService) DashboardItemRemoveAsFavorite(ctx context.Context, uid string) ApiDashboardItemRemoveAsFavoriteRequest {
	return ApiDashboardItemRemoveAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardItemRemoveAsFavoriteExecute(r ApiDashboardItemRemoveAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemRemoveAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardItemReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *UiAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiDashboardItemReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiDashboardItemReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiDashboardItemReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardItemReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r)
}

/*
DashboardItemReplaceCollectionItemsJsonreplaceCollectionItemsXml Method for DashboardItemReplaceCollectionItemsJsonreplaceCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiDashboardItemReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest
*/
func (a *UiAPIService) DashboardItemReplaceCollectionItemsJsonreplaceCollectionItemsXml(ctx context.Context, property string, uid string) ApiDashboardItemReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	return ApiDashboardItemReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardItemReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r ApiDashboardItemReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemReplaceCollectionItemsJsonreplaceCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardItemReplaceTranslationsRequest struct {
	ctx                                             context.Context
	ApiService                                      *UiAPIService
	uid                                             string
	aggregateDataExchangeReplaceTranslationsRequest *AggregateDataExchangeReplaceTranslationsRequest
}

// [no description yet]
func (r ApiDashboardItemReplaceTranslationsRequest) AggregateDataExchangeReplaceTranslationsRequest(aggregateDataExchangeReplaceTranslationsRequest AggregateDataExchangeReplaceTranslationsRequest) ApiDashboardItemReplaceTranslationsRequest {
	r.aggregateDataExchangeReplaceTranslationsRequest = &aggregateDataExchangeReplaceTranslationsRequest
	return r
}

func (r ApiDashboardItemReplaceTranslationsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DashboardItemReplaceTranslationsExecute(r)
}

/*
DashboardItemReplaceTranslations Method for DashboardItemReplaceTranslations

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardItemReplaceTranslationsRequest
*/
func (a *UiAPIService) DashboardItemReplaceTranslations(ctx context.Context, uid string) ApiDashboardItemReplaceTranslationsRequest {
	return ApiDashboardItemReplaceTranslationsRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *UiAPIService) DashboardItemReplaceTranslationsExecute(r ApiDashboardItemReplaceTranslationsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemReplaceTranslations")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/{uid}/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateDataExchangeReplaceTranslationsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDashboardItemSetAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
}

func (r ApiDashboardItemSetAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardItemSetAsFavoriteExecute(r)
}

/*
DashboardItemSetAsFavorite Method for DashboardItemSetAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardItemSetAsFavoriteRequest
*/
func (a *UiAPIService) DashboardItemSetAsFavorite(ctx context.Context, uid string) ApiDashboardItemSetAsFavoriteRequest {
	return ApiDashboardItemSetAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardItemSetAsFavoriteExecute(r ApiDashboardItemSetAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemSetAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardItemSetSharingRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
	sharing    *Sharing
}

// [no description yet]
func (r ApiDashboardItemSetSharingRequest) Sharing(sharing Sharing) ApiDashboardItemSetSharingRequest {
	r.sharing = &sharing
	return r
}

func (r ApiDashboardItemSetSharingRequest) Execute() (*http.Response, error) {
	return r.ApiService.DashboardItemSetSharingExecute(r)
}

/*
DashboardItemSetSharing Method for DashboardItemSetSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardItemSetSharingRequest
*/
func (a *UiAPIService) DashboardItemSetSharing(ctx context.Context, uid string) ApiDashboardItemSetSharingRequest {
	return ApiDashboardItemSetSharingRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *UiAPIService) DashboardItemSetSharingExecute(r ApiDashboardItemSetSharingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemSetSharing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/{uid}/sharing"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharing
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDashboardItemSubscribeRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
}

func (r ApiDashboardItemSubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardItemSubscribeExecute(r)
}

/*
DashboardItemSubscribe Method for DashboardItemSubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardItemSubscribeRequest
*/
func (a *UiAPIService) DashboardItemSubscribe(ctx context.Context, uid string) ApiDashboardItemSubscribeRequest {
	return ApiDashboardItemSubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardItemSubscribeExecute(r ApiDashboardItemSubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemSubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardItemUnsubscribeRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
}

func (r ApiDashboardItemUnsubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardItemUnsubscribeExecute(r)
}

/*
DashboardItemUnsubscribe Method for DashboardItemUnsubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardItemUnsubscribeRequest
*/
func (a *UiAPIService) DashboardItemUnsubscribe(ctx context.Context, uid string) ApiDashboardItemUnsubscribeRequest {
	return ApiDashboardItemUnsubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardItemUnsubscribeExecute(r ApiDashboardItemUnsubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemUnsubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardItemUpdateObjectPropertyRequest struct {
	ctx                context.Context
	ApiService         *UiAPIService
	property           string
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	dashboardItem      *DashboardItem
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiDashboardItemUpdateObjectPropertyRequest) AtomicMode(atomicMode string) ApiDashboardItemUpdateObjectPropertyRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiDashboardItemUpdateObjectPropertyRequest) FlushMode(flushMode string) ApiDashboardItemUpdateObjectPropertyRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiDashboardItemUpdateObjectPropertyRequest) Identifier(identifier string) ApiDashboardItemUpdateObjectPropertyRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiDashboardItemUpdateObjectPropertyRequest) ImportMode(importMode string) ApiDashboardItemUpdateObjectPropertyRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiDashboardItemUpdateObjectPropertyRequest) ImportReportMode(importReportMode string) ApiDashboardItemUpdateObjectPropertyRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiDashboardItemUpdateObjectPropertyRequest) ImportStrategy(importStrategy string) ApiDashboardItemUpdateObjectPropertyRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiDashboardItemUpdateObjectPropertyRequest) MergeMode(mergeMode string) ApiDashboardItemUpdateObjectPropertyRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiDashboardItemUpdateObjectPropertyRequest) MetadataSyncImport(metadataSyncImport bool) ApiDashboardItemUpdateObjectPropertyRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiDashboardItemUpdateObjectPropertyRequest) Page(page int32) ApiDashboardItemUpdateObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiDashboardItemUpdateObjectPropertyRequest) PageSize(pageSize int32) ApiDashboardItemUpdateObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiDashboardItemUpdateObjectPropertyRequest) Paging(paging bool) ApiDashboardItemUpdateObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiDashboardItemUpdateObjectPropertyRequest) PreheatMode(preheatMode string) ApiDashboardItemUpdateObjectPropertyRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiDashboardItemUpdateObjectPropertyRequest) RootJunction(rootJunction string) ApiDashboardItemUpdateObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiDashboardItemUpdateObjectPropertyRequest) SkipSharing(skipSharing bool) ApiDashboardItemUpdateObjectPropertyRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiDashboardItemUpdateObjectPropertyRequest) SkipTranslation(skipTranslation bool) ApiDashboardItemUpdateObjectPropertyRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiDashboardItemUpdateObjectPropertyRequest) SkipValidation(skipValidation bool) ApiDashboardItemUpdateObjectPropertyRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiDashboardItemUpdateObjectPropertyRequest) UserOverrideMode(userOverrideMode string) ApiDashboardItemUpdateObjectPropertyRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiDashboardItemUpdateObjectPropertyRequest) DashboardItem(dashboardItem DashboardItem) ApiDashboardItemUpdateObjectPropertyRequest {
	r.dashboardItem = &dashboardItem
	return r
}

func (r ApiDashboardItemUpdateObjectPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DashboardItemUpdateObjectPropertyExecute(r)
}

/*
DashboardItemUpdateObjectProperty Method for DashboardItemUpdateObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiDashboardItemUpdateObjectPropertyRequest
*/
func (a *UiAPIService) DashboardItemUpdateObjectProperty(ctx context.Context, property string, uid string) ApiDashboardItemUpdateObjectPropertyRequest {
	return ApiDashboardItemUpdateObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
func (a *UiAPIService) DashboardItemUpdateObjectPropertyExecute(r ApiDashboardItemUpdateObjectPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardItemUpdateObjectProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboardItems/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dashboardItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDashboardPatchObjectRequest struct {
	ctx                context.Context
	ApiService         *UiAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	jsonPatch          *JsonPatch
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiDashboardPatchObjectRequest) AtomicMode(atomicMode string) ApiDashboardPatchObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiDashboardPatchObjectRequest) FlushMode(flushMode string) ApiDashboardPatchObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiDashboardPatchObjectRequest) Identifier(identifier string) ApiDashboardPatchObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiDashboardPatchObjectRequest) ImportMode(importMode string) ApiDashboardPatchObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiDashboardPatchObjectRequest) ImportReportMode(importReportMode string) ApiDashboardPatchObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiDashboardPatchObjectRequest) ImportStrategy(importStrategy string) ApiDashboardPatchObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiDashboardPatchObjectRequest) MergeMode(mergeMode string) ApiDashboardPatchObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiDashboardPatchObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiDashboardPatchObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiDashboardPatchObjectRequest) Page(page int32) ApiDashboardPatchObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiDashboardPatchObjectRequest) PageSize(pageSize int32) ApiDashboardPatchObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiDashboardPatchObjectRequest) Paging(paging bool) ApiDashboardPatchObjectRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiDashboardPatchObjectRequest) PreheatMode(preheatMode string) ApiDashboardPatchObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiDashboardPatchObjectRequest) RootJunction(rootJunction string) ApiDashboardPatchObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiDashboardPatchObjectRequest) SkipSharing(skipSharing bool) ApiDashboardPatchObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiDashboardPatchObjectRequest) SkipTranslation(skipTranslation bool) ApiDashboardPatchObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiDashboardPatchObjectRequest) SkipValidation(skipValidation bool) ApiDashboardPatchObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiDashboardPatchObjectRequest) UserOverrideMode(userOverrideMode string) ApiDashboardPatchObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiDashboardPatchObjectRequest) JsonPatch(jsonPatch JsonPatch) ApiDashboardPatchObjectRequest {
	r.jsonPatch = &jsonPatch
	return r
}

func (r ApiDashboardPatchObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardPatchObjectExecute(r)
}

/*
DashboardPatchObject Method for DashboardPatchObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardPatchObjectRequest
*/
func (a *UiAPIService) DashboardPatchObject(ctx context.Context, uid string) ApiDashboardPatchObjectRequest {
	return ApiDashboardPatchObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardPatchObjectExecute(r ApiDashboardPatchObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardPatchObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardPostJsonObjectpostXmlObjectRequest struct {
	ctx                context.Context
	ApiService         *UiAPIService
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	preheatMode        *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	dashboard          *Dashboard
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiDashboardPostJsonObjectpostXmlObjectRequest) AtomicMode(atomicMode string) ApiDashboardPostJsonObjectpostXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiDashboardPostJsonObjectpostXmlObjectRequest) FlushMode(flushMode string) ApiDashboardPostJsonObjectpostXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiDashboardPostJsonObjectpostXmlObjectRequest) Identifier(identifier string) ApiDashboardPostJsonObjectpostXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiDashboardPostJsonObjectpostXmlObjectRequest) ImportMode(importMode string) ApiDashboardPostJsonObjectpostXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiDashboardPostJsonObjectpostXmlObjectRequest) ImportReportMode(importReportMode string) ApiDashboardPostJsonObjectpostXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiDashboardPostJsonObjectpostXmlObjectRequest) ImportStrategy(importStrategy string) ApiDashboardPostJsonObjectpostXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiDashboardPostJsonObjectpostXmlObjectRequest) MergeMode(mergeMode string) ApiDashboardPostJsonObjectpostXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiDashboardPostJsonObjectpostXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiDashboardPostJsonObjectpostXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiDashboardPostJsonObjectpostXmlObjectRequest) PreheatMode(preheatMode string) ApiDashboardPostJsonObjectpostXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiDashboardPostJsonObjectpostXmlObjectRequest) SkipSharing(skipSharing bool) ApiDashboardPostJsonObjectpostXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiDashboardPostJsonObjectpostXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiDashboardPostJsonObjectpostXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiDashboardPostJsonObjectpostXmlObjectRequest) SkipValidation(skipValidation bool) ApiDashboardPostJsonObjectpostXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiDashboardPostJsonObjectpostXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiDashboardPostJsonObjectpostXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiDashboardPostJsonObjectpostXmlObjectRequest) Dashboard(dashboard Dashboard) ApiDashboardPostJsonObjectpostXmlObjectRequest {
	r.dashboard = &dashboard
	return r
}

func (r ApiDashboardPostJsonObjectpostXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardPostJsonObjectpostXmlObjectExecute(r)
}

/*
DashboardPostJsonObjectpostXmlObject Method for DashboardPostJsonObjectpostXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDashboardPostJsonObjectpostXmlObjectRequest
*/
func (a *UiAPIService) DashboardPostJsonObjectpostXmlObject(ctx context.Context) ApiDashboardPostJsonObjectpostXmlObjectRequest {
	return ApiDashboardPostJsonObjectpostXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardPostJsonObjectpostXmlObjectExecute(r ApiDashboardPostJsonObjectpostXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardPostJsonObjectpostXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dashboard
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardPutJsonObjectputXmlObjectRequest struct {
	ctx                context.Context
	ApiService         *UiAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	preheatMode        *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	dashboard          *Dashboard
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiDashboardPutJsonObjectputXmlObjectRequest) AtomicMode(atomicMode string) ApiDashboardPutJsonObjectputXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiDashboardPutJsonObjectputXmlObjectRequest) FlushMode(flushMode string) ApiDashboardPutJsonObjectputXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiDashboardPutJsonObjectputXmlObjectRequest) Identifier(identifier string) ApiDashboardPutJsonObjectputXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiDashboardPutJsonObjectputXmlObjectRequest) ImportMode(importMode string) ApiDashboardPutJsonObjectputXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiDashboardPutJsonObjectputXmlObjectRequest) ImportReportMode(importReportMode string) ApiDashboardPutJsonObjectputXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiDashboardPutJsonObjectputXmlObjectRequest) ImportStrategy(importStrategy string) ApiDashboardPutJsonObjectputXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiDashboardPutJsonObjectputXmlObjectRequest) MergeMode(mergeMode string) ApiDashboardPutJsonObjectputXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiDashboardPutJsonObjectputXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiDashboardPutJsonObjectputXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiDashboardPutJsonObjectputXmlObjectRequest) PreheatMode(preheatMode string) ApiDashboardPutJsonObjectputXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiDashboardPutJsonObjectputXmlObjectRequest) SkipSharing(skipSharing bool) ApiDashboardPutJsonObjectputXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiDashboardPutJsonObjectputXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiDashboardPutJsonObjectputXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiDashboardPutJsonObjectputXmlObjectRequest) SkipValidation(skipValidation bool) ApiDashboardPutJsonObjectputXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiDashboardPutJsonObjectputXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiDashboardPutJsonObjectputXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiDashboardPutJsonObjectputXmlObjectRequest) Dashboard(dashboard Dashboard) ApiDashboardPutJsonObjectputXmlObjectRequest {
	r.dashboard = &dashboard
	return r
}

func (r ApiDashboardPutJsonObjectputXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardPutJsonObjectputXmlObjectExecute(r)
}

/*
DashboardPutJsonObjectputXmlObject Method for DashboardPutJsonObjectputXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardPutJsonObjectputXmlObjectRequest
*/
func (a *UiAPIService) DashboardPutJsonObjectputXmlObject(ctx context.Context, uid string) ApiDashboardPutJsonObjectputXmlObjectRequest {
	return ApiDashboardPutJsonObjectputXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardPutJsonObjectputXmlObjectExecute(r ApiDashboardPutJsonObjectputXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardPutJsonObjectputXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dashboard
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardRemoveAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
}

func (r ApiDashboardRemoveAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardRemoveAsFavoriteExecute(r)
}

/*
DashboardRemoveAsFavorite Method for DashboardRemoveAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardRemoveAsFavoriteRequest
*/
func (a *UiAPIService) DashboardRemoveAsFavorite(ctx context.Context, uid string) ApiDashboardRemoveAsFavoriteRequest {
	return ApiDashboardRemoveAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardRemoveAsFavoriteExecute(r ApiDashboardRemoveAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardRemoveAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *UiAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiDashboardReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiDashboardReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiDashboardReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r)
}

/*
DashboardReplaceCollectionItemsJsonreplaceCollectionItemsXml Method for DashboardReplaceCollectionItemsJsonreplaceCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiDashboardReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest
*/
func (a *UiAPIService) DashboardReplaceCollectionItemsJsonreplaceCollectionItemsXml(ctx context.Context, property string, uid string) ApiDashboardReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	return ApiDashboardReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r ApiDashboardReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardReplaceCollectionItemsJsonreplaceCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardReplaceTranslationsRequest struct {
	ctx                                             context.Context
	ApiService                                      *UiAPIService
	uid                                             string
	aggregateDataExchangeReplaceTranslationsRequest *AggregateDataExchangeReplaceTranslationsRequest
}

// [no description yet]
func (r ApiDashboardReplaceTranslationsRequest) AggregateDataExchangeReplaceTranslationsRequest(aggregateDataExchangeReplaceTranslationsRequest AggregateDataExchangeReplaceTranslationsRequest) ApiDashboardReplaceTranslationsRequest {
	r.aggregateDataExchangeReplaceTranslationsRequest = &aggregateDataExchangeReplaceTranslationsRequest
	return r
}

func (r ApiDashboardReplaceTranslationsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DashboardReplaceTranslationsExecute(r)
}

/*
DashboardReplaceTranslations Method for DashboardReplaceTranslations

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardReplaceTranslationsRequest
*/
func (a *UiAPIService) DashboardReplaceTranslations(ctx context.Context, uid string) ApiDashboardReplaceTranslationsRequest {
	return ApiDashboardReplaceTranslationsRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *UiAPIService) DashboardReplaceTranslationsExecute(r ApiDashboardReplaceTranslationsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardReplaceTranslations")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{uid}/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateDataExchangeReplaceTranslationsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDashboardSearchRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	query      string
	count      *int32
	max        *[]string
	maxCount   *int32
}

// [no description yet]
func (r ApiDashboardSearchRequest) Count(count int32) ApiDashboardSearchRequest {
	r.count = &count
	return r
}

// [no description yet]
func (r ApiDashboardSearchRequest) Max(max []string) ApiDashboardSearchRequest {
	r.max = &max
	return r
}

// [no description yet]
func (r ApiDashboardSearchRequest) MaxCount(maxCount int32) ApiDashboardSearchRequest {
	r.maxCount = &maxCount
	return r
}

func (r ApiDashboardSearchRequest) Execute() (*DashboardSearchResult, *http.Response, error) {
	return r.ApiService.DashboardSearchExecute(r)
}

/*
DashboardSearch Method for DashboardSearch

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param query [no description yet]
	@return ApiDashboardSearchRequest
*/
func (a *UiAPIService) DashboardSearch(ctx context.Context, query string) ApiDashboardSearchRequest {
	return ApiDashboardSearchRequest{
		ApiService: a,
		ctx:        ctx,
		query:      query,
	}
}

// Execute executes the request
//
//	@return DashboardSearchResult
func (a *UiAPIService) DashboardSearchExecute(r ApiDashboardSearchRequest) (*DashboardSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DashboardSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/q/{query}"
	localVarPath = strings.Replace(localVarPath, "{"+"query"+"}", url.PathEscape(parameterValueToString(r.query, "query")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.max != nil {
		t := *r.max
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "max", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "max", t, "multi")
		}
	}
	if r.maxCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxCount", r.maxCount, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardSearchAsParamRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	q          *string
	count      *int32
	max        *[]string
	maxCount   *int32
}

// [no description yet]
func (r ApiDashboardSearchAsParamRequest) Q(q string) ApiDashboardSearchAsParamRequest {
	r.q = &q
	return r
}

// [no description yet]
func (r ApiDashboardSearchAsParamRequest) Count(count int32) ApiDashboardSearchAsParamRequest {
	r.count = &count
	return r
}

// [no description yet]
func (r ApiDashboardSearchAsParamRequest) Max(max []string) ApiDashboardSearchAsParamRequest {
	r.max = &max
	return r
}

// [no description yet]
func (r ApiDashboardSearchAsParamRequest) MaxCount(maxCount int32) ApiDashboardSearchAsParamRequest {
	r.maxCount = &maxCount
	return r
}

func (r ApiDashboardSearchAsParamRequest) Execute() (*DashboardSearchResult, *http.Response, error) {
	return r.ApiService.DashboardSearchAsParamExecute(r)
}

/*
DashboardSearchAsParam Method for DashboardSearchAsParam

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDashboardSearchAsParamRequest
*/
func (a *UiAPIService) DashboardSearchAsParam(ctx context.Context) ApiDashboardSearchAsParamRequest {
	return ApiDashboardSearchAsParamRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DashboardSearchResult
func (a *UiAPIService) DashboardSearchAsParamExecute(r ApiDashboardSearchAsParamRequest) (*DashboardSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DashboardSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardSearchAsParam")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.q == nil {
		return localVarReturnValue, nil, reportError("q is required and must be specified")
	}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.max != nil {
		t := *r.max
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "max", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "max", t, "multi")
		}
	}
	if r.maxCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxCount", r.maxCount, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardSearchNoFilterRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	count      *int32
	max        *[]string
	maxCount   *int32
}

// [no description yet]
func (r ApiDashboardSearchNoFilterRequest) Count(count int32) ApiDashboardSearchNoFilterRequest {
	r.count = &count
	return r
}

// [no description yet]
func (r ApiDashboardSearchNoFilterRequest) Max(max []string) ApiDashboardSearchNoFilterRequest {
	r.max = &max
	return r
}

// [no description yet]
func (r ApiDashboardSearchNoFilterRequest) MaxCount(maxCount int32) ApiDashboardSearchNoFilterRequest {
	r.maxCount = &maxCount
	return r
}

func (r ApiDashboardSearchNoFilterRequest) Execute() (*DashboardSearchResult, *http.Response, error) {
	return r.ApiService.DashboardSearchNoFilterExecute(r)
}

/*
DashboardSearchNoFilter Method for DashboardSearchNoFilter

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDashboardSearchNoFilterRequest
*/
func (a *UiAPIService) DashboardSearchNoFilter(ctx context.Context) ApiDashboardSearchNoFilterRequest {
	return ApiDashboardSearchNoFilterRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DashboardSearchResult
func (a *UiAPIService) DashboardSearchNoFilterExecute(r ApiDashboardSearchNoFilterRequest) (*DashboardSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DashboardSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardSearchNoFilter")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/q"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.max != nil {
		t := *r.max
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "max", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "max", t, "multi")
		}
	}
	if r.maxCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxCount", r.maxCount, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardSetAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
}

func (r ApiDashboardSetAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardSetAsFavoriteExecute(r)
}

/*
DashboardSetAsFavorite Method for DashboardSetAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardSetAsFavoriteRequest
*/
func (a *UiAPIService) DashboardSetAsFavorite(ctx context.Context, uid string) ApiDashboardSetAsFavoriteRequest {
	return ApiDashboardSetAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardSetAsFavoriteExecute(r ApiDashboardSetAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardSetAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardSetSharingRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
	sharing    *Sharing
}

// [no description yet]
func (r ApiDashboardSetSharingRequest) Sharing(sharing Sharing) ApiDashboardSetSharingRequest {
	r.sharing = &sharing
	return r
}

func (r ApiDashboardSetSharingRequest) Execute() (*http.Response, error) {
	return r.ApiService.DashboardSetSharingExecute(r)
}

/*
DashboardSetSharing Method for DashboardSetSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardSetSharingRequest
*/
func (a *UiAPIService) DashboardSetSharing(ctx context.Context, uid string) ApiDashboardSetSharingRequest {
	return ApiDashboardSetSharingRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *UiAPIService) DashboardSetSharingExecute(r ApiDashboardSetSharingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardSetSharing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{uid}/sharing"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharing
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDashboardSubscribeRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
}

func (r ApiDashboardSubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardSubscribeExecute(r)
}

/*
DashboardSubscribe Method for DashboardSubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardSubscribeRequest
*/
func (a *UiAPIService) DashboardSubscribe(ctx context.Context, uid string) ApiDashboardSubscribeRequest {
	return ApiDashboardSubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardSubscribeExecute(r ApiDashboardSubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardSubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardUnsubscribeRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
}

func (r ApiDashboardUnsubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.DashboardUnsubscribeExecute(r)
}

/*
DashboardUnsubscribe Method for DashboardUnsubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiDashboardUnsubscribeRequest
*/
func (a *UiAPIService) DashboardUnsubscribe(ctx context.Context, uid string) ApiDashboardUnsubscribeRequest {
	return ApiDashboardUnsubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) DashboardUnsubscribeExecute(r ApiDashboardUnsubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardUnsubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDashboardUpdateObjectPropertyRequest struct {
	ctx                context.Context
	ApiService         *UiAPIService
	property           string
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	dashboard          *Dashboard
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiDashboardUpdateObjectPropertyRequest) AtomicMode(atomicMode string) ApiDashboardUpdateObjectPropertyRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiDashboardUpdateObjectPropertyRequest) FlushMode(flushMode string) ApiDashboardUpdateObjectPropertyRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiDashboardUpdateObjectPropertyRequest) Identifier(identifier string) ApiDashboardUpdateObjectPropertyRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiDashboardUpdateObjectPropertyRequest) ImportMode(importMode string) ApiDashboardUpdateObjectPropertyRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiDashboardUpdateObjectPropertyRequest) ImportReportMode(importReportMode string) ApiDashboardUpdateObjectPropertyRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiDashboardUpdateObjectPropertyRequest) ImportStrategy(importStrategy string) ApiDashboardUpdateObjectPropertyRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiDashboardUpdateObjectPropertyRequest) MergeMode(mergeMode string) ApiDashboardUpdateObjectPropertyRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiDashboardUpdateObjectPropertyRequest) MetadataSyncImport(metadataSyncImport bool) ApiDashboardUpdateObjectPropertyRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiDashboardUpdateObjectPropertyRequest) Page(page int32) ApiDashboardUpdateObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiDashboardUpdateObjectPropertyRequest) PageSize(pageSize int32) ApiDashboardUpdateObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiDashboardUpdateObjectPropertyRequest) Paging(paging bool) ApiDashboardUpdateObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiDashboardUpdateObjectPropertyRequest) PreheatMode(preheatMode string) ApiDashboardUpdateObjectPropertyRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiDashboardUpdateObjectPropertyRequest) RootJunction(rootJunction string) ApiDashboardUpdateObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiDashboardUpdateObjectPropertyRequest) SkipSharing(skipSharing bool) ApiDashboardUpdateObjectPropertyRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiDashboardUpdateObjectPropertyRequest) SkipTranslation(skipTranslation bool) ApiDashboardUpdateObjectPropertyRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiDashboardUpdateObjectPropertyRequest) SkipValidation(skipValidation bool) ApiDashboardUpdateObjectPropertyRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiDashboardUpdateObjectPropertyRequest) UserOverrideMode(userOverrideMode string) ApiDashboardUpdateObjectPropertyRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiDashboardUpdateObjectPropertyRequest) Dashboard(dashboard Dashboard) ApiDashboardUpdateObjectPropertyRequest {
	r.dashboard = &dashboard
	return r
}

func (r ApiDashboardUpdateObjectPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DashboardUpdateObjectPropertyExecute(r)
}

/*
DashboardUpdateObjectProperty Method for DashboardUpdateObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiDashboardUpdateObjectPropertyRequest
*/
func (a *UiAPIService) DashboardUpdateObjectProperty(ctx context.Context, property string, uid string) ApiDashboardUpdateObjectPropertyRequest {
	return ApiDashboardUpdateObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
func (a *UiAPIService) DashboardUpdateObjectPropertyExecute(r ApiDashboardUpdateObjectPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.DashboardUpdateObjectProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dashboard
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiI18nPostI18nRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	package_   *string
}

// [no description yet]
func (r ApiI18nPostI18nRequest) Package_(package_ string) ApiI18nPostI18nRequest {
	r.package_ = &package_
	return r
}

func (r ApiI18nPostI18nRequest) Execute() (*I18nOutput, *http.Response, error) {
	return r.ApiService.I18nPostI18nExecute(r)
}

/*
I18nPostI18n Method for I18nPostI18n

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiI18nPostI18nRequest
*/
func (a *UiAPIService) I18nPostI18n(ctx context.Context) ApiI18nPostI18nRequest {
	return ApiI18nPostI18nRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return I18nOutput
func (a *UiAPIService) I18nPostI18nExecute(r ApiI18nPostI18nRequest) (*I18nOutput, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *I18nOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.I18nPostI18n")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/i18n/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.package_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "package", r.package_, "")
	} else {
		var defaultValue string = "org.hisp.dhis"
		r.package_ = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIconGetIconRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	iconKey    string
}

func (r ApiIconGetIconRequest) Execute() (*IconData, *http.Response, error) {
	return r.ApiService.IconGetIconExecute(r)
}

/*
IconGetIcon Method for IconGetIcon

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param iconKey [no description yet]
	@return ApiIconGetIconRequest
*/
func (a *UiAPIService) IconGetIcon(ctx context.Context, iconKey string) ApiIconGetIconRequest {
	return ApiIconGetIconRequest{
		ApiService: a,
		ctx:        ctx,
		iconKey:    iconKey,
	}
}

// Execute executes the request
//
//	@return IconData
func (a *UiAPIService) IconGetIconExecute(r ApiIconGetIconRequest) (*IconData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IconData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.IconGetIcon")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/icons/{iconKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"iconKey"+"}", url.PathEscape(parameterValueToString(r.iconKey, "iconKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIconGetIconDataRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	iconKey    string
}

func (r ApiIconGetIconDataRequest) Execute() (*http.Response, error) {
	return r.ApiService.IconGetIconDataExecute(r)
}

/*
IconGetIconData Method for IconGetIconData

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param iconKey [no description yet]
	@return ApiIconGetIconDataRequest
*/
func (a *UiAPIService) IconGetIconData(ctx context.Context, iconKey string) ApiIconGetIconDataRequest {
	return ApiIconGetIconDataRequest{
		ApiService: a,
		ctx:        ctx,
		iconKey:    iconKey,
	}
}

// Execute executes the request
func (a *UiAPIService) IconGetIconDataExecute(r ApiIconGetIconDataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.IconGetIconData")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/icons/{iconKey}/icon.svg"
	localVarPath = strings.Replace(localVarPath, "{"+"iconKey"+"}", url.PathEscape(parameterValueToString(r.iconKey, "iconKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIconGetIconsRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	keywords   *[]string
}

// [no description yet]
func (r ApiIconGetIconsRequest) Keywords(keywords []string) ApiIconGetIconsRequest {
	r.keywords = &keywords
	return r
}

func (r ApiIconGetIconsRequest) Execute() ([]IconData, *http.Response, error) {
	return r.ApiService.IconGetIconsExecute(r)
}

/*
IconGetIcons Method for IconGetIcons

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIconGetIconsRequest
*/
func (a *UiAPIService) IconGetIcons(ctx context.Context) ApiIconGetIconsRequest {
	return ApiIconGetIconsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []IconData
func (a *UiAPIService) IconGetIconsExecute(r ApiIconGetIconsRequest) ([]IconData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []IconData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.IconGetIcons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/icons/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.keywords != nil {
		t := *r.keywords
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "keywords", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "keywords", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIconGetKeywordsRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
}

func (r ApiIconGetKeywordsRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.IconGetKeywordsExecute(r)
}

/*
IconGetKeywords Method for IconGetKeywords

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIconGetKeywordsRequest
*/
func (a *UiAPIService) IconGetKeywords(ctx context.Context) ApiIconGetKeywordsRequest {
	return ApiIconGetKeywordsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []string
func (a *UiAPIService) IconGetKeywordsExecute(r ApiIconGetKeywordsRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.IconGetKeywords")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/icons/keywords"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationAddCollectionItemRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiInterpretationAddCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.InterpretationAddCollectionItemExecute(r)
}

/*
InterpretationAddCollectionItem Method for InterpretationAddCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiInterpretationAddCollectionItemRequest
*/
func (a *UiAPIService) InterpretationAddCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiInterpretationAddCollectionItemRequest {
	return ApiInterpretationAddCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) InterpretationAddCollectionItemExecute(r ApiInterpretationAddCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationAddCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationAddCollectionItemsJsonaddCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *UiAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiInterpretationAddCollectionItemsJsonaddCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiInterpretationAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiInterpretationAddCollectionItemsJsonaddCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.InterpretationAddCollectionItemsJsonaddCollectionItemsXmlExecute(r)
}

/*
InterpretationAddCollectionItemsJsonaddCollectionItemsXml Method for InterpretationAddCollectionItemsJsonaddCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiInterpretationAddCollectionItemsJsonaddCollectionItemsXmlRequest
*/
func (a *UiAPIService) InterpretationAddCollectionItemsJsonaddCollectionItemsXml(ctx context.Context, property string, uid string) ApiInterpretationAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	return ApiInterpretationAddCollectionItemsJsonaddCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) InterpretationAddCollectionItemsJsonaddCollectionItemsXmlExecute(r ApiInterpretationAddCollectionItemsJsonaddCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationAddCollectionItemsJsonaddCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationBulkSharingRequest struct {
	ctx                context.Context
	ApiService         *UiAPIService
	atomic             *bool
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	bulkJsonPatch      *BulkJsonPatch
}

// [no description yet]
func (r ApiInterpretationBulkSharingRequest) Atomic(atomic bool) ApiInterpretationBulkSharingRequest {
	r.atomic = &atomic
	return r
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiInterpretationBulkSharingRequest) AtomicMode(atomicMode string) ApiInterpretationBulkSharingRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiInterpretationBulkSharingRequest) FlushMode(flushMode string) ApiInterpretationBulkSharingRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiInterpretationBulkSharingRequest) Identifier(identifier string) ApiInterpretationBulkSharingRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiInterpretationBulkSharingRequest) ImportMode(importMode string) ApiInterpretationBulkSharingRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiInterpretationBulkSharingRequest) ImportReportMode(importReportMode string) ApiInterpretationBulkSharingRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiInterpretationBulkSharingRequest) ImportStrategy(importStrategy string) ApiInterpretationBulkSharingRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiInterpretationBulkSharingRequest) MergeMode(mergeMode string) ApiInterpretationBulkSharingRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiInterpretationBulkSharingRequest) MetadataSyncImport(metadataSyncImport bool) ApiInterpretationBulkSharingRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiInterpretationBulkSharingRequest) Page(page int32) ApiInterpretationBulkSharingRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiInterpretationBulkSharingRequest) PageSize(pageSize int32) ApiInterpretationBulkSharingRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiInterpretationBulkSharingRequest) Paging(paging bool) ApiInterpretationBulkSharingRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiInterpretationBulkSharingRequest) PreheatMode(preheatMode string) ApiInterpretationBulkSharingRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiInterpretationBulkSharingRequest) RootJunction(rootJunction string) ApiInterpretationBulkSharingRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiInterpretationBulkSharingRequest) SkipSharing(skipSharing bool) ApiInterpretationBulkSharingRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiInterpretationBulkSharingRequest) SkipTranslation(skipTranslation bool) ApiInterpretationBulkSharingRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiInterpretationBulkSharingRequest) SkipValidation(skipValidation bool) ApiInterpretationBulkSharingRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiInterpretationBulkSharingRequest) UserOverrideMode(userOverrideMode string) ApiInterpretationBulkSharingRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiInterpretationBulkSharingRequest) BulkJsonPatch(bulkJsonPatch BulkJsonPatch) ApiInterpretationBulkSharingRequest {
	r.bulkJsonPatch = &bulkJsonPatch
	return r
}

func (r ApiInterpretationBulkSharingRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.InterpretationBulkSharingExecute(r)
}

/*
InterpretationBulkSharing Method for InterpretationBulkSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInterpretationBulkSharingRequest
*/
func (a *UiAPIService) InterpretationBulkSharing(ctx context.Context) ApiInterpretationBulkSharingRequest {
	return ApiInterpretationBulkSharingRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) InterpretationBulkSharingExecute(r ApiInterpretationBulkSharingRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationBulkSharing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/sharing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomic", r.atomic, "")
	} else {
		var defaultValue bool = false
		r.atomic = &defaultValue
	}
	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkJsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationDeleteCollectionItemRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiInterpretationDeleteCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.InterpretationDeleteCollectionItemExecute(r)
}

/*
InterpretationDeleteCollectionItem Method for InterpretationDeleteCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiInterpretationDeleteCollectionItemRequest
*/
func (a *UiAPIService) InterpretationDeleteCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiInterpretationDeleteCollectionItemRequest {
	return ApiInterpretationDeleteCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) InterpretationDeleteCollectionItemExecute(r ApiInterpretationDeleteCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationDeleteCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *UiAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiInterpretationDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiInterpretationDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiInterpretationDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.InterpretationDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r)
}

/*
InterpretationDeleteCollectionItemsJsondeleteCollectionItemsXml Method for InterpretationDeleteCollectionItemsJsondeleteCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiInterpretationDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest
*/
func (a *UiAPIService) InterpretationDeleteCollectionItemsJsondeleteCollectionItemsXml(ctx context.Context, property string, uid string) ApiInterpretationDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	return ApiInterpretationDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) InterpretationDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r ApiInterpretationDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationDeleteCollectionItemsJsondeleteCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationDeleteCommentRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	cuid       string
	uid        string
}

func (r ApiInterpretationDeleteCommentRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterpretationDeleteCommentExecute(r)
}

/*
InterpretationDeleteComment Method for InterpretationDeleteComment

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cuid [no description yet]
	@param uid [no description yet]
	@return ApiInterpretationDeleteCommentRequest
*/
func (a *UiAPIService) InterpretationDeleteComment(ctx context.Context, cuid string, uid string) ApiInterpretationDeleteCommentRequest {
	return ApiInterpretationDeleteCommentRequest{
		ApiService: a,
		ctx:        ctx,
		cuid:       cuid,
		uid:        uid,
	}
}

// Execute executes the request
func (a *UiAPIService) InterpretationDeleteCommentExecute(r ApiInterpretationDeleteCommentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationDeleteComment")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}/comments/{cuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"cuid"+"}", url.PathEscape(parameterValueToString(r.cuid, "cuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterpretationDeleteObjectRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
}

func (r ApiInterpretationDeleteObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.InterpretationDeleteObjectExecute(r)
}

/*
InterpretationDeleteObject Method for InterpretationDeleteObject

Deletes the Interpretation provided by ID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiInterpretationDeleteObjectRequest
*/
func (a *UiAPIService) InterpretationDeleteObject(ctx context.Context, uid string) ApiInterpretationDeleteObjectRequest {
	return ApiInterpretationDeleteObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) InterpretationDeleteObjectExecute(r ApiInterpretationDeleteObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationDeleteObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationGetObjectRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	uid          string
	fields       *[]string
	filter       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiInterpretationGetObjectRequest) Fields(fields []string) ApiInterpretationGetObjectRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiInterpretationGetObjectRequest) Filter(filter []string) ApiInterpretationGetObjectRequest {
	r.filter = &filter
	return r
}

// Defines which page number to return.
func (r ApiInterpretationGetObjectRequest) Page(page int32) ApiInterpretationGetObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiInterpretationGetObjectRequest) PageSize(pageSize int32) ApiInterpretationGetObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiInterpretationGetObjectRequest) Paging(paging bool) ApiInterpretationGetObjectRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiInterpretationGetObjectRequest) RootJunction(rootJunction string) ApiInterpretationGetObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiInterpretationGetObjectRequest) Execute() (*Interpretation, *http.Response, error) {
	return r.ApiService.InterpretationGetObjectExecute(r)
}

/*
InterpretationGetObject Method for InterpretationGetObject

View a Interpretation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiInterpretationGetObjectRequest
*/
func (a *UiAPIService) InterpretationGetObject(ctx context.Context, uid string) ApiInterpretationGetObjectRequest {
	return ApiInterpretationGetObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return Interpretation
func (a *UiAPIService) InterpretationGetObjectExecute(r ApiInterpretationGetObjectRequest) (*Interpretation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Interpretation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationGetObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationGetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiInterpretationGetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiInterpretationGetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiInterpretationGetObjectGistAsCsvRequest) Auto(auto string) ApiInterpretationGetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiInterpretationGetObjectGistAsCsvRequest) Describe(describe bool) ApiInterpretationGetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiInterpretationGetObjectGistAsCsvRequest) Fields(fields string) ApiInterpretationGetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiInterpretationGetObjectGistAsCsvRequest) Filter(filter string) ApiInterpretationGetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiInterpretationGetObjectGistAsCsvRequest) Headless(headless bool) ApiInterpretationGetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiInterpretationGetObjectGistAsCsvRequest) Inverse(inverse bool) ApiInterpretationGetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiInterpretationGetObjectGistAsCsvRequest) Locale(locale string) ApiInterpretationGetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiInterpretationGetObjectGistAsCsvRequest) Order(order string) ApiInterpretationGetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiInterpretationGetObjectGistAsCsvRequest) Page(page int32) ApiInterpretationGetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiInterpretationGetObjectGistAsCsvRequest) PageListName(pageListName string) ApiInterpretationGetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiInterpretationGetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiInterpretationGetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiInterpretationGetObjectGistAsCsvRequest) References(references bool) ApiInterpretationGetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiInterpretationGetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiInterpretationGetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiInterpretationGetObjectGistAsCsvRequest) Total(total bool) ApiInterpretationGetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiInterpretationGetObjectGistAsCsvRequest) Translate(translate bool) ApiInterpretationGetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiInterpretationGetObjectGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.InterpretationGetObjectGistAsCsvExecute(r)
}

/*
InterpretationGetObjectGistAsCsv Method for InterpretationGetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiInterpretationGetObjectGistAsCsvRequest
*/
func (a *UiAPIService) InterpretationGetObjectGistAsCsv(ctx context.Context, uid string) ApiInterpretationGetObjectGistAsCsvRequest {
	return ApiInterpretationGetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *UiAPIService) InterpretationGetObjectGistAsCsvExecute(r ApiInterpretationGetObjectGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationGetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest) Auto(auto string) ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest) Describe(describe bool) ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest) Fields(fields string) ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest) Filter(filter string) ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest) Headless(headless bool) ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest) Inverse(inverse bool) ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest) Locale(locale string) ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest) Order(order string) ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest) Page(page int32) ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest) PageListName(pageListName string) ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest) References(references bool) ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest) Total(total bool) ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest) Translate(translate bool) ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.InterpretationGetObjectGistgetObjectGistAsCsvExecute(r)
}

/*
InterpretationGetObjectGistgetObjectGistAsCsv Method for InterpretationGetObjectGistgetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest
*/
func (a *UiAPIService) InterpretationGetObjectGistgetObjectGistAsCsv(ctx context.Context, uid string) ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest {
	return ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *UiAPIService) InterpretationGetObjectGistgetObjectGistAsCsvExecute(r ApiInterpretationGetObjectGistgetObjectGistAsCsvRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationGetObjectGistgetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationGetObjectListRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	fields       *[]string
	filter       *[]string
	orders       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// &#x60;&lt;field-name&gt;[,&lt;field-name&gt;...]&#x60;
func (r ApiInterpretationGetObjectListRequest) Fields(fields []string) ApiInterpretationGetObjectListRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiInterpretationGetObjectListRequest) Filter(filter []string) ApiInterpretationGetObjectListRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiInterpretationGetObjectListRequest) Orders(orders []string) ApiInterpretationGetObjectListRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiInterpretationGetObjectListRequest) Page(page int32) ApiInterpretationGetObjectListRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiInterpretationGetObjectListRequest) PageSize(pageSize int32) ApiInterpretationGetObjectListRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiInterpretationGetObjectListRequest) Paging(paging bool) ApiInterpretationGetObjectListRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiInterpretationGetObjectListRequest) RootJunction(rootJunction string) ApiInterpretationGetObjectListRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiInterpretationGetObjectListRequest) Execute() (*InterpretationGetObjectList200Response, *http.Response, error) {
	return r.ApiService.InterpretationGetObjectListExecute(r)
}

/*
InterpretationGetObjectList Method for InterpretationGetObjectList

List all Interpretations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInterpretationGetObjectListRequest
*/
func (a *UiAPIService) InterpretationGetObjectList(ctx context.Context) ApiInterpretationGetObjectListRequest {
	return ApiInterpretationGetObjectListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return InterpretationGetObjectList200Response
func (a *UiAPIService) InterpretationGetObjectListExecute(r ApiInterpretationGetObjectListRequest) (*InterpretationGetObjectList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InterpretationGetObjectList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationGetObjectList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationGetObjectListCsvRequest struct {
	ctx            context.Context
	ApiService     *UiAPIService
	arraySeparator *string
	fields         *[]string
	filter         *[]string
	orders         *[]string
	page           *int32
	pageSize       *int32
	paging         *bool
	rootJunction   *string
	separator      *string
	skipHeader     *bool
}

// [no description yet]
func (r ApiInterpretationGetObjectListCsvRequest) ArraySeparator(arraySeparator string) ApiInterpretationGetObjectListCsvRequest {
	r.arraySeparator = &arraySeparator
	return r
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiInterpretationGetObjectListCsvRequest) Fields(fields []string) ApiInterpretationGetObjectListCsvRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiInterpretationGetObjectListCsvRequest) Filter(filter []string) ApiInterpretationGetObjectListCsvRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiInterpretationGetObjectListCsvRequest) Orders(orders []string) ApiInterpretationGetObjectListCsvRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiInterpretationGetObjectListCsvRequest) Page(page int32) ApiInterpretationGetObjectListCsvRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiInterpretationGetObjectListCsvRequest) PageSize(pageSize int32) ApiInterpretationGetObjectListCsvRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiInterpretationGetObjectListCsvRequest) Paging(paging bool) ApiInterpretationGetObjectListCsvRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiInterpretationGetObjectListCsvRequest) RootJunction(rootJunction string) ApiInterpretationGetObjectListCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiInterpretationGetObjectListCsvRequest) Separator(separator string) ApiInterpretationGetObjectListCsvRequest {
	r.separator = &separator
	return r
}

// [no description yet]
func (r ApiInterpretationGetObjectListCsvRequest) SkipHeader(skipHeader bool) ApiInterpretationGetObjectListCsvRequest {
	r.skipHeader = &skipHeader
	return r
}

func (r ApiInterpretationGetObjectListCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.InterpretationGetObjectListCsvExecute(r)
}

/*
InterpretationGetObjectListCsv Method for InterpretationGetObjectListCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInterpretationGetObjectListCsvRequest
*/
func (a *UiAPIService) InterpretationGetObjectListCsv(ctx context.Context) ApiInterpretationGetObjectListCsvRequest {
	return ApiInterpretationGetObjectListCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *UiAPIService) InterpretationGetObjectListCsvExecute(r ApiInterpretationGetObjectListCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationGetObjectListCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/#getObjectListCsv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.arraySeparator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arraySeparator", r.arraySeparator, "")
	} else {
		var defaultValue string = ";"
		r.arraySeparator = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.separator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "separator", r.separator, "")
	} else {
		var defaultValue string = ","
		r.separator = &defaultValue
	}
	if r.skipHeader != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipHeader", r.skipHeader, "")
	} else {
		var defaultValue bool = false
		r.skipHeader = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/text", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationGetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiInterpretationGetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiInterpretationGetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiInterpretationGetObjectListGistAsCsvRequest) Auto(auto string) ApiInterpretationGetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiInterpretationGetObjectListGistAsCsvRequest) Describe(describe bool) ApiInterpretationGetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiInterpretationGetObjectListGistAsCsvRequest) Fields(fields string) ApiInterpretationGetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiInterpretationGetObjectListGistAsCsvRequest) Filter(filter string) ApiInterpretationGetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiInterpretationGetObjectListGistAsCsvRequest) Headless(headless bool) ApiInterpretationGetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiInterpretationGetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiInterpretationGetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiInterpretationGetObjectListGistAsCsvRequest) Locale(locale string) ApiInterpretationGetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiInterpretationGetObjectListGistAsCsvRequest) Order(order string) ApiInterpretationGetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiInterpretationGetObjectListGistAsCsvRequest) Page(page int32) ApiInterpretationGetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiInterpretationGetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiInterpretationGetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiInterpretationGetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiInterpretationGetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiInterpretationGetObjectListGistAsCsvRequest) References(references bool) ApiInterpretationGetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiInterpretationGetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiInterpretationGetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiInterpretationGetObjectListGistAsCsvRequest) Total(total bool) ApiInterpretationGetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiInterpretationGetObjectListGistAsCsvRequest) Translate(translate bool) ApiInterpretationGetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiInterpretationGetObjectListGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.InterpretationGetObjectListGistAsCsvExecute(r)
}

/*
InterpretationGetObjectListGistAsCsv Method for InterpretationGetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInterpretationGetObjectListGistAsCsvRequest
*/
func (a *UiAPIService) InterpretationGetObjectListGistAsCsv(ctx context.Context) ApiInterpretationGetObjectListGistAsCsvRequest {
	return ApiInterpretationGetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *UiAPIService) InterpretationGetObjectListGistAsCsvExecute(r ApiInterpretationGetObjectListGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationGetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/gist.csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest) Auto(auto string) ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest) Describe(describe bool) ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest) Fields(fields string) ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest) Filter(filter string) ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest) Headless(headless bool) ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest) Locale(locale string) ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest) Order(order string) ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest) Page(page int32) ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest) References(references bool) ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest) Total(total bool) ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest) Translate(translate bool) ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest) Execute() (*InterpretationGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.InterpretationGetObjectListGistgetObjectListGistAsCsvExecute(r)
}

/*
InterpretationGetObjectListGistgetObjectListGistAsCsv Method for InterpretationGetObjectListGistgetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest
*/
func (a *UiAPIService) InterpretationGetObjectListGistgetObjectListGistAsCsv(ctx context.Context) ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest {
	return ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return InterpretationGetObjectListGistGetObjectListGistAsCsv200Response
func (a *UiAPIService) InterpretationGetObjectListGistgetObjectListGistAsCsvExecute(r ApiInterpretationGetObjectListGistgetObjectListGistAsCsvRequest) (*InterpretationGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InterpretationGetObjectListGistGetObjectListGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationGetObjectListGistgetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/gist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationGetObjectPropertyRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	property     string
	uid          string
	fields       *[]string
	locale       *string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
	translate    *bool
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiInterpretationGetObjectPropertyRequest) Fields(fields []string) ApiInterpretationGetObjectPropertyRequest {
	r.fields = &fields
	return r
}

// [no description yet]
func (r ApiInterpretationGetObjectPropertyRequest) Locale(locale string) ApiInterpretationGetObjectPropertyRequest {
	r.locale = &locale
	return r
}

// Defines which page number to return.
func (r ApiInterpretationGetObjectPropertyRequest) Page(page int32) ApiInterpretationGetObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiInterpretationGetObjectPropertyRequest) PageSize(pageSize int32) ApiInterpretationGetObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiInterpretationGetObjectPropertyRequest) Paging(paging bool) ApiInterpretationGetObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiInterpretationGetObjectPropertyRequest) RootJunction(rootJunction string) ApiInterpretationGetObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiInterpretationGetObjectPropertyRequest) Translate(translate bool) ApiInterpretationGetObjectPropertyRequest {
	r.translate = &translate
	return r
}

func (r ApiInterpretationGetObjectPropertyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.InterpretationGetObjectPropertyExecute(r)
}

/*
InterpretationGetObjectProperty Method for InterpretationGetObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiInterpretationGetObjectPropertyRequest
*/
func (a *UiAPIService) InterpretationGetObjectProperty(ctx context.Context, property string, uid string) ApiInterpretationGetObjectPropertyRequest {
	return ApiInterpretationGetObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *UiAPIService) InterpretationGetObjectPropertyExecute(r ApiInterpretationGetObjectPropertyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationGetObjectProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationGetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiInterpretationGetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiInterpretationGetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiInterpretationGetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiInterpretationGetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiInterpretationGetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiInterpretationGetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiInterpretationGetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiInterpretationGetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiInterpretationGetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiInterpretationGetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiInterpretationGetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiInterpretationGetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiInterpretationGetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiInterpretationGetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiInterpretationGetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiInterpretationGetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiInterpretationGetObjectPropertyGistAsCsvRequest) Order(order string) ApiInterpretationGetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiInterpretationGetObjectPropertyGistAsCsvRequest) Page(page int32) ApiInterpretationGetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiInterpretationGetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiInterpretationGetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiInterpretationGetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiInterpretationGetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiInterpretationGetObjectPropertyGistAsCsvRequest) References(references bool) ApiInterpretationGetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiInterpretationGetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiInterpretationGetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiInterpretationGetObjectPropertyGistAsCsvRequest) Total(total bool) ApiInterpretationGetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiInterpretationGetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiInterpretationGetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiInterpretationGetObjectPropertyGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.InterpretationGetObjectPropertyGistAsCsvExecute(r)
}

/*
InterpretationGetObjectPropertyGistAsCsv Method for InterpretationGetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiInterpretationGetObjectPropertyGistAsCsvRequest
*/
func (a *UiAPIService) InterpretationGetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiInterpretationGetObjectPropertyGistAsCsvRequest {
	return ApiInterpretationGetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *UiAPIService) InterpretationGetObjectPropertyGistAsCsvExecute(r ApiInterpretationGetObjectPropertyGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationGetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}/{property}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Order(order string) ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Page(page int32) ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) References(references bool) ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Total(total bool) ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Execute() (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.InterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r)
}

/*
InterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsv Method for InterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest
*/
func (a *UiAPIService) InterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	return ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
func (a *UiAPIService) InterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r ApiInterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationGetObjectPropertyGistgetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}/{property}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationLikeRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
}

func (r ApiInterpretationLikeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.InterpretationLikeExecute(r)
}

/*
InterpretationLike Method for InterpretationLike

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiInterpretationLikeRequest
*/
func (a *UiAPIService) InterpretationLike(ctx context.Context, uid string) ApiInterpretationLikeRequest {
	return ApiInterpretationLikeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) InterpretationLikeExecute(r ApiInterpretationLikeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationLike")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}/like"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationPatchObjectRequest struct {
	ctx                context.Context
	ApiService         *UiAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	jsonPatch          *JsonPatch
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiInterpretationPatchObjectRequest) AtomicMode(atomicMode string) ApiInterpretationPatchObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiInterpretationPatchObjectRequest) FlushMode(flushMode string) ApiInterpretationPatchObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiInterpretationPatchObjectRequest) Identifier(identifier string) ApiInterpretationPatchObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiInterpretationPatchObjectRequest) ImportMode(importMode string) ApiInterpretationPatchObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiInterpretationPatchObjectRequest) ImportReportMode(importReportMode string) ApiInterpretationPatchObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiInterpretationPatchObjectRequest) ImportStrategy(importStrategy string) ApiInterpretationPatchObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiInterpretationPatchObjectRequest) MergeMode(mergeMode string) ApiInterpretationPatchObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiInterpretationPatchObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiInterpretationPatchObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiInterpretationPatchObjectRequest) Page(page int32) ApiInterpretationPatchObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiInterpretationPatchObjectRequest) PageSize(pageSize int32) ApiInterpretationPatchObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiInterpretationPatchObjectRequest) Paging(paging bool) ApiInterpretationPatchObjectRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiInterpretationPatchObjectRequest) PreheatMode(preheatMode string) ApiInterpretationPatchObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiInterpretationPatchObjectRequest) RootJunction(rootJunction string) ApiInterpretationPatchObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiInterpretationPatchObjectRequest) SkipSharing(skipSharing bool) ApiInterpretationPatchObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiInterpretationPatchObjectRequest) SkipTranslation(skipTranslation bool) ApiInterpretationPatchObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiInterpretationPatchObjectRequest) SkipValidation(skipValidation bool) ApiInterpretationPatchObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiInterpretationPatchObjectRequest) UserOverrideMode(userOverrideMode string) ApiInterpretationPatchObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiInterpretationPatchObjectRequest) JsonPatch(jsonPatch JsonPatch) ApiInterpretationPatchObjectRequest {
	r.jsonPatch = &jsonPatch
	return r
}

func (r ApiInterpretationPatchObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.InterpretationPatchObjectExecute(r)
}

/*
InterpretationPatchObject Method for InterpretationPatchObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiInterpretationPatchObjectRequest
*/
func (a *UiAPIService) InterpretationPatchObject(ctx context.Context, uid string) ApiInterpretationPatchObjectRequest {
	return ApiInterpretationPatchObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) InterpretationPatchObjectExecute(r ApiInterpretationPatchObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationPatchObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationPostCommentRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
	body       *string
}

// [no description yet]
func (r ApiInterpretationPostCommentRequest) Body(body string) ApiInterpretationPostCommentRequest {
	r.body = &body
	return r
}

func (r ApiInterpretationPostCommentRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.InterpretationPostCommentExecute(r)
}

/*
InterpretationPostComment Method for InterpretationPostComment

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiInterpretationPostCommentRequest
*/
func (a *UiAPIService) InterpretationPostComment(ctx context.Context, uid string) ApiInterpretationPostCommentRequest {
	return ApiInterpretationPostCommentRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) InterpretationPostCommentExecute(r ApiInterpretationPostCommentRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationPostComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/html", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationPostJsonObjectpostXmlObjectRequest struct {
	ctx                context.Context
	ApiService         *UiAPIService
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	preheatMode        *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	interpretation     *Interpretation
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiInterpretationPostJsonObjectpostXmlObjectRequest) AtomicMode(atomicMode string) ApiInterpretationPostJsonObjectpostXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiInterpretationPostJsonObjectpostXmlObjectRequest) FlushMode(flushMode string) ApiInterpretationPostJsonObjectpostXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiInterpretationPostJsonObjectpostXmlObjectRequest) Identifier(identifier string) ApiInterpretationPostJsonObjectpostXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiInterpretationPostJsonObjectpostXmlObjectRequest) ImportMode(importMode string) ApiInterpretationPostJsonObjectpostXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiInterpretationPostJsonObjectpostXmlObjectRequest) ImportReportMode(importReportMode string) ApiInterpretationPostJsonObjectpostXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiInterpretationPostJsonObjectpostXmlObjectRequest) ImportStrategy(importStrategy string) ApiInterpretationPostJsonObjectpostXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiInterpretationPostJsonObjectpostXmlObjectRequest) MergeMode(mergeMode string) ApiInterpretationPostJsonObjectpostXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiInterpretationPostJsonObjectpostXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiInterpretationPostJsonObjectpostXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiInterpretationPostJsonObjectpostXmlObjectRequest) PreheatMode(preheatMode string) ApiInterpretationPostJsonObjectpostXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiInterpretationPostJsonObjectpostXmlObjectRequest) SkipSharing(skipSharing bool) ApiInterpretationPostJsonObjectpostXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiInterpretationPostJsonObjectpostXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiInterpretationPostJsonObjectpostXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiInterpretationPostJsonObjectpostXmlObjectRequest) SkipValidation(skipValidation bool) ApiInterpretationPostJsonObjectpostXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiInterpretationPostJsonObjectpostXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiInterpretationPostJsonObjectpostXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiInterpretationPostJsonObjectpostXmlObjectRequest) Interpretation(interpretation Interpretation) ApiInterpretationPostJsonObjectpostXmlObjectRequest {
	r.interpretation = &interpretation
	return r
}

func (r ApiInterpretationPostJsonObjectpostXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.InterpretationPostJsonObjectpostXmlObjectExecute(r)
}

/*
InterpretationPostJsonObjectpostXmlObject Method for InterpretationPostJsonObjectpostXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInterpretationPostJsonObjectpostXmlObjectRequest
*/
func (a *UiAPIService) InterpretationPostJsonObjectpostXmlObject(ctx context.Context) ApiInterpretationPostJsonObjectpostXmlObjectRequest {
	return ApiInterpretationPostJsonObjectpostXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) InterpretationPostJsonObjectpostXmlObjectExecute(r ApiInterpretationPostJsonObjectpostXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationPostJsonObjectpostXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.interpretation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationPutJsonObjectRequest struct {
	ctx                context.Context
	ApiService         *UiAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	preheatMode        *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	interpretation     *Interpretation
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiInterpretationPutJsonObjectRequest) AtomicMode(atomicMode string) ApiInterpretationPutJsonObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiInterpretationPutJsonObjectRequest) FlushMode(flushMode string) ApiInterpretationPutJsonObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiInterpretationPutJsonObjectRequest) Identifier(identifier string) ApiInterpretationPutJsonObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiInterpretationPutJsonObjectRequest) ImportMode(importMode string) ApiInterpretationPutJsonObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiInterpretationPutJsonObjectRequest) ImportReportMode(importReportMode string) ApiInterpretationPutJsonObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiInterpretationPutJsonObjectRequest) ImportStrategy(importStrategy string) ApiInterpretationPutJsonObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiInterpretationPutJsonObjectRequest) MergeMode(mergeMode string) ApiInterpretationPutJsonObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiInterpretationPutJsonObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiInterpretationPutJsonObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiInterpretationPutJsonObjectRequest) PreheatMode(preheatMode string) ApiInterpretationPutJsonObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiInterpretationPutJsonObjectRequest) SkipSharing(skipSharing bool) ApiInterpretationPutJsonObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiInterpretationPutJsonObjectRequest) SkipTranslation(skipTranslation bool) ApiInterpretationPutJsonObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiInterpretationPutJsonObjectRequest) SkipValidation(skipValidation bool) ApiInterpretationPutJsonObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiInterpretationPutJsonObjectRequest) UserOverrideMode(userOverrideMode string) ApiInterpretationPutJsonObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiInterpretationPutJsonObjectRequest) Interpretation(interpretation Interpretation) ApiInterpretationPutJsonObjectRequest {
	r.interpretation = &interpretation
	return r
}

func (r ApiInterpretationPutJsonObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.InterpretationPutJsonObjectExecute(r)
}

/*
InterpretationPutJsonObject Method for InterpretationPutJsonObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiInterpretationPutJsonObjectRequest
*/
func (a *UiAPIService) InterpretationPutJsonObject(ctx context.Context, uid string) ApiInterpretationPutJsonObjectRequest {
	return ApiInterpretationPutJsonObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) InterpretationPutJsonObjectExecute(r ApiInterpretationPutJsonObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationPutJsonObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}#putJsonObject"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.interpretation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationPutXmlObjectRequest struct {
	ctx                context.Context
	ApiService         *UiAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	preheatMode        *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	interpretation     *Interpretation
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiInterpretationPutXmlObjectRequest) AtomicMode(atomicMode string) ApiInterpretationPutXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiInterpretationPutXmlObjectRequest) FlushMode(flushMode string) ApiInterpretationPutXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiInterpretationPutXmlObjectRequest) Identifier(identifier string) ApiInterpretationPutXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiInterpretationPutXmlObjectRequest) ImportMode(importMode string) ApiInterpretationPutXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiInterpretationPutXmlObjectRequest) ImportReportMode(importReportMode string) ApiInterpretationPutXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiInterpretationPutXmlObjectRequest) ImportStrategy(importStrategy string) ApiInterpretationPutXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiInterpretationPutXmlObjectRequest) MergeMode(mergeMode string) ApiInterpretationPutXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiInterpretationPutXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiInterpretationPutXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiInterpretationPutXmlObjectRequest) PreheatMode(preheatMode string) ApiInterpretationPutXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiInterpretationPutXmlObjectRequest) SkipSharing(skipSharing bool) ApiInterpretationPutXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiInterpretationPutXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiInterpretationPutXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiInterpretationPutXmlObjectRequest) SkipValidation(skipValidation bool) ApiInterpretationPutXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiInterpretationPutXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiInterpretationPutXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiInterpretationPutXmlObjectRequest) Interpretation(interpretation Interpretation) ApiInterpretationPutXmlObjectRequest {
	r.interpretation = &interpretation
	return r
}

func (r ApiInterpretationPutXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.InterpretationPutXmlObjectExecute(r)
}

/*
InterpretationPutXmlObject Method for InterpretationPutXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiInterpretationPutXmlObjectRequest
*/
func (a *UiAPIService) InterpretationPutXmlObject(ctx context.Context, uid string) ApiInterpretationPutXmlObjectRequest {
	return ApiInterpretationPutXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) InterpretationPutXmlObjectExecute(r ApiInterpretationPutXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationPutXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}#putXmlObject"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.interpretation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationRemoveAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
}

func (r ApiInterpretationRemoveAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.InterpretationRemoveAsFavoriteExecute(r)
}

/*
InterpretationRemoveAsFavorite Method for InterpretationRemoveAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiInterpretationRemoveAsFavoriteRequest
*/
func (a *UiAPIService) InterpretationRemoveAsFavorite(ctx context.Context, uid string) ApiInterpretationRemoveAsFavoriteRequest {
	return ApiInterpretationRemoveAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) InterpretationRemoveAsFavoriteExecute(r ApiInterpretationRemoveAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationRemoveAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *UiAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiInterpretationReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiInterpretationReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiInterpretationReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.InterpretationReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r)
}

/*
InterpretationReplaceCollectionItemsJsonreplaceCollectionItemsXml Method for InterpretationReplaceCollectionItemsJsonreplaceCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiInterpretationReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest
*/
func (a *UiAPIService) InterpretationReplaceCollectionItemsJsonreplaceCollectionItemsXml(ctx context.Context, property string, uid string) ApiInterpretationReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	return ApiInterpretationReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) InterpretationReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r ApiInterpretationReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationReplaceCollectionItemsJsonreplaceCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationReplaceTranslationsRequest struct {
	ctx                                             context.Context
	ApiService                                      *UiAPIService
	uid                                             string
	aggregateDataExchangeReplaceTranslationsRequest *AggregateDataExchangeReplaceTranslationsRequest
}

// [no description yet]
func (r ApiInterpretationReplaceTranslationsRequest) AggregateDataExchangeReplaceTranslationsRequest(aggregateDataExchangeReplaceTranslationsRequest AggregateDataExchangeReplaceTranslationsRequest) ApiInterpretationReplaceTranslationsRequest {
	r.aggregateDataExchangeReplaceTranslationsRequest = &aggregateDataExchangeReplaceTranslationsRequest
	return r
}

func (r ApiInterpretationReplaceTranslationsRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterpretationReplaceTranslationsExecute(r)
}

/*
InterpretationReplaceTranslations Method for InterpretationReplaceTranslations

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiInterpretationReplaceTranslationsRequest
*/
func (a *UiAPIService) InterpretationReplaceTranslations(ctx context.Context, uid string) ApiInterpretationReplaceTranslationsRequest {
	return ApiInterpretationReplaceTranslationsRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *UiAPIService) InterpretationReplaceTranslationsExecute(r ApiInterpretationReplaceTranslationsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationReplaceTranslations")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateDataExchangeReplaceTranslationsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterpretationSetAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
}

func (r ApiInterpretationSetAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.InterpretationSetAsFavoriteExecute(r)
}

/*
InterpretationSetAsFavorite Method for InterpretationSetAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiInterpretationSetAsFavoriteRequest
*/
func (a *UiAPIService) InterpretationSetAsFavorite(ctx context.Context, uid string) ApiInterpretationSetAsFavoriteRequest {
	return ApiInterpretationSetAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) InterpretationSetAsFavoriteExecute(r ApiInterpretationSetAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationSetAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationSetSharingRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
	sharing    *Sharing
}

// [no description yet]
func (r ApiInterpretationSetSharingRequest) Sharing(sharing Sharing) ApiInterpretationSetSharingRequest {
	r.sharing = &sharing
	return r
}

func (r ApiInterpretationSetSharingRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterpretationSetSharingExecute(r)
}

/*
InterpretationSetSharing Method for InterpretationSetSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiInterpretationSetSharingRequest
*/
func (a *UiAPIService) InterpretationSetSharing(ctx context.Context, uid string) ApiInterpretationSetSharingRequest {
	return ApiInterpretationSetSharingRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *UiAPIService) InterpretationSetSharingExecute(r ApiInterpretationSetSharingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationSetSharing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}/sharing"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharing
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterpretationSubscribeRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
}

func (r ApiInterpretationSubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.InterpretationSubscribeExecute(r)
}

/*
InterpretationSubscribe Method for InterpretationSubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiInterpretationSubscribeRequest
*/
func (a *UiAPIService) InterpretationSubscribe(ctx context.Context, uid string) ApiInterpretationSubscribeRequest {
	return ApiInterpretationSubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) InterpretationSubscribeExecute(r ApiInterpretationSubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationSubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationUnlikeRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
}

func (r ApiInterpretationUnlikeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.InterpretationUnlikeExecute(r)
}

/*
InterpretationUnlike Method for InterpretationUnlike

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiInterpretationUnlikeRequest
*/
func (a *UiAPIService) InterpretationUnlike(ctx context.Context, uid string) ApiInterpretationUnlikeRequest {
	return ApiInterpretationUnlikeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) InterpretationUnlikeExecute(r ApiInterpretationUnlikeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationUnlike")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}/like"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationUnsubscribeRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
}

func (r ApiInterpretationUnsubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.InterpretationUnsubscribeExecute(r)
}

/*
InterpretationUnsubscribe Method for InterpretationUnsubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiInterpretationUnsubscribeRequest
*/
func (a *UiAPIService) InterpretationUnsubscribe(ctx context.Context, uid string) ApiInterpretationUnsubscribeRequest {
	return ApiInterpretationUnsubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) InterpretationUnsubscribeExecute(r ApiInterpretationUnsubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationUnsubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationUpdateCommentRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	cuid       string
	uid        string
	body       *string
}

// [no description yet]
func (r ApiInterpretationUpdateCommentRequest) Body(body string) ApiInterpretationUpdateCommentRequest {
	r.body = &body
	return r
}

func (r ApiInterpretationUpdateCommentRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterpretationUpdateCommentExecute(r)
}

/*
InterpretationUpdateComment Method for InterpretationUpdateComment

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cuid [no description yet]
	@param uid [no description yet]
	@return ApiInterpretationUpdateCommentRequest
*/
func (a *UiAPIService) InterpretationUpdateComment(ctx context.Context, cuid string, uid string) ApiInterpretationUpdateCommentRequest {
	return ApiInterpretationUpdateCommentRequest{
		ApiService: a,
		ctx:        ctx,
		cuid:       cuid,
		uid:        uid,
	}
}

// Execute executes the request
func (a *UiAPIService) InterpretationUpdateCommentExecute(r ApiInterpretationUpdateCommentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationUpdateComment")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}/comments/{cuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"cuid"+"}", url.PathEscape(parameterValueToString(r.cuid, "cuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterpretationUpdateInterpretationRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
	body       *string
}

// [no description yet]
func (r ApiInterpretationUpdateInterpretationRequest) Body(body string) ApiInterpretationUpdateInterpretationRequest {
	r.body = &body
	return r
}

func (r ApiInterpretationUpdateInterpretationRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterpretationUpdateInterpretationExecute(r)
}

/*
InterpretationUpdateInterpretation Method for InterpretationUpdateInterpretation

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiInterpretationUpdateInterpretationRequest
*/
func (a *UiAPIService) InterpretationUpdateInterpretation(ctx context.Context, uid string) ApiInterpretationUpdateInterpretationRequest {
	return ApiInterpretationUpdateInterpretationRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *UiAPIService) InterpretationUpdateInterpretationExecute(r ApiInterpretationUpdateInterpretationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationUpdateInterpretation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterpretationUpdateObjectPropertyRequest struct {
	ctx                context.Context
	ApiService         *UiAPIService
	property           string
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	interpretation     *Interpretation
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiInterpretationUpdateObjectPropertyRequest) AtomicMode(atomicMode string) ApiInterpretationUpdateObjectPropertyRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiInterpretationUpdateObjectPropertyRequest) FlushMode(flushMode string) ApiInterpretationUpdateObjectPropertyRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiInterpretationUpdateObjectPropertyRequest) Identifier(identifier string) ApiInterpretationUpdateObjectPropertyRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiInterpretationUpdateObjectPropertyRequest) ImportMode(importMode string) ApiInterpretationUpdateObjectPropertyRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiInterpretationUpdateObjectPropertyRequest) ImportReportMode(importReportMode string) ApiInterpretationUpdateObjectPropertyRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiInterpretationUpdateObjectPropertyRequest) ImportStrategy(importStrategy string) ApiInterpretationUpdateObjectPropertyRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiInterpretationUpdateObjectPropertyRequest) MergeMode(mergeMode string) ApiInterpretationUpdateObjectPropertyRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiInterpretationUpdateObjectPropertyRequest) MetadataSyncImport(metadataSyncImport bool) ApiInterpretationUpdateObjectPropertyRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiInterpretationUpdateObjectPropertyRequest) Page(page int32) ApiInterpretationUpdateObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiInterpretationUpdateObjectPropertyRequest) PageSize(pageSize int32) ApiInterpretationUpdateObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiInterpretationUpdateObjectPropertyRequest) Paging(paging bool) ApiInterpretationUpdateObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiInterpretationUpdateObjectPropertyRequest) PreheatMode(preheatMode string) ApiInterpretationUpdateObjectPropertyRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiInterpretationUpdateObjectPropertyRequest) RootJunction(rootJunction string) ApiInterpretationUpdateObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiInterpretationUpdateObjectPropertyRequest) SkipSharing(skipSharing bool) ApiInterpretationUpdateObjectPropertyRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiInterpretationUpdateObjectPropertyRequest) SkipTranslation(skipTranslation bool) ApiInterpretationUpdateObjectPropertyRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiInterpretationUpdateObjectPropertyRequest) SkipValidation(skipValidation bool) ApiInterpretationUpdateObjectPropertyRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiInterpretationUpdateObjectPropertyRequest) UserOverrideMode(userOverrideMode string) ApiInterpretationUpdateObjectPropertyRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiInterpretationUpdateObjectPropertyRequest) Interpretation(interpretation Interpretation) ApiInterpretationUpdateObjectPropertyRequest {
	r.interpretation = &interpretation
	return r
}

func (r ApiInterpretationUpdateObjectPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterpretationUpdateObjectPropertyExecute(r)
}

/*
InterpretationUpdateObjectProperty Method for InterpretationUpdateObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiInterpretationUpdateObjectPropertyRequest
*/
func (a *UiAPIService) InterpretationUpdateObjectProperty(ctx context.Context, property string, uid string) ApiInterpretationUpdateObjectPropertyRequest {
	return ApiInterpretationUpdateObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
func (a *UiAPIService) InterpretationUpdateObjectPropertyExecute(r ApiInterpretationUpdateObjectPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationUpdateObjectProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.interpretation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterpretationWriteDataSetReportInterpretationRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	ou         *string
	pe         *string
	uid        string
	body       *string
}

// [no description yet]
func (r ApiInterpretationWriteDataSetReportInterpretationRequest) Ou(ou string) ApiInterpretationWriteDataSetReportInterpretationRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiInterpretationWriteDataSetReportInterpretationRequest) Pe(pe string) ApiInterpretationWriteDataSetReportInterpretationRequest {
	r.pe = &pe
	return r
}

// [no description yet]
func (r ApiInterpretationWriteDataSetReportInterpretationRequest) Body(body string) ApiInterpretationWriteDataSetReportInterpretationRequest {
	r.body = &body
	return r
}

func (r ApiInterpretationWriteDataSetReportInterpretationRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.InterpretationWriteDataSetReportInterpretationExecute(r)
}

/*
InterpretationWriteDataSetReportInterpretation Method for InterpretationWriteDataSetReportInterpretation

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiInterpretationWriteDataSetReportInterpretationRequest
*/
func (a *UiAPIService) InterpretationWriteDataSetReportInterpretation(ctx context.Context, uid string) ApiInterpretationWriteDataSetReportInterpretationRequest {
	return ApiInterpretationWriteDataSetReportInterpretationRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) InterpretationWriteDataSetReportInterpretationExecute(r ApiInterpretationWriteDataSetReportInterpretationRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationWriteDataSetReportInterpretation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/dataSetReport/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ou == nil {
		return localVarReturnValue, nil, reportError("ou is required and must be specified")
	}
	if r.pe == nil {
		return localVarReturnValue, nil, reportError("pe is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pe", r.pe, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/html", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationWriteEventChartInterpretationRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
	body       *string
	ou         *string
}

// [no description yet]
func (r ApiInterpretationWriteEventChartInterpretationRequest) Body(body string) ApiInterpretationWriteEventChartInterpretationRequest {
	r.body = &body
	return r
}

// [no description yet]
func (r ApiInterpretationWriteEventChartInterpretationRequest) Ou(ou string) ApiInterpretationWriteEventChartInterpretationRequest {
	r.ou = &ou
	return r
}

func (r ApiInterpretationWriteEventChartInterpretationRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.InterpretationWriteEventChartInterpretationExecute(r)
}

/*
InterpretationWriteEventChartInterpretation Method for InterpretationWriteEventChartInterpretation

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiInterpretationWriteEventChartInterpretationRequest

Deprecated
*/
func (a *UiAPIService) InterpretationWriteEventChartInterpretation(ctx context.Context, uid string) ApiInterpretationWriteEventChartInterpretationRequest {
	return ApiInterpretationWriteEventChartInterpretationRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
//
// Deprecated
func (a *UiAPIService) InterpretationWriteEventChartInterpretationExecute(r ApiInterpretationWriteEventChartInterpretationRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationWriteEventChartInterpretation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/eventChart/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.ou != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/html", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationWriteEventReportInterpretationRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
	body       *string
	ou         *string
}

// [no description yet]
func (r ApiInterpretationWriteEventReportInterpretationRequest) Body(body string) ApiInterpretationWriteEventReportInterpretationRequest {
	r.body = &body
	return r
}

// [no description yet]
func (r ApiInterpretationWriteEventReportInterpretationRequest) Ou(ou string) ApiInterpretationWriteEventReportInterpretationRequest {
	r.ou = &ou
	return r
}

func (r ApiInterpretationWriteEventReportInterpretationRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.InterpretationWriteEventReportInterpretationExecute(r)
}

/*
InterpretationWriteEventReportInterpretation Method for InterpretationWriteEventReportInterpretation

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiInterpretationWriteEventReportInterpretationRequest

Deprecated
*/
func (a *UiAPIService) InterpretationWriteEventReportInterpretation(ctx context.Context, uid string) ApiInterpretationWriteEventReportInterpretationRequest {
	return ApiInterpretationWriteEventReportInterpretationRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
//
// Deprecated
func (a *UiAPIService) InterpretationWriteEventReportInterpretationExecute(r ApiInterpretationWriteEventReportInterpretationRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationWriteEventReportInterpretation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/eventReport/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.ou != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/html", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationWriteEventVisualizationInterpretationRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
	body       *string
	ou         *string
}

// [no description yet]
func (r ApiInterpretationWriteEventVisualizationInterpretationRequest) Body(body string) ApiInterpretationWriteEventVisualizationInterpretationRequest {
	r.body = &body
	return r
}

// [no description yet]
func (r ApiInterpretationWriteEventVisualizationInterpretationRequest) Ou(ou string) ApiInterpretationWriteEventVisualizationInterpretationRequest {
	r.ou = &ou
	return r
}

func (r ApiInterpretationWriteEventVisualizationInterpretationRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.InterpretationWriteEventVisualizationInterpretationExecute(r)
}

/*
InterpretationWriteEventVisualizationInterpretation Method for InterpretationWriteEventVisualizationInterpretation

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiInterpretationWriteEventVisualizationInterpretationRequest
*/
func (a *UiAPIService) InterpretationWriteEventVisualizationInterpretation(ctx context.Context, uid string) ApiInterpretationWriteEventVisualizationInterpretationRequest {
	return ApiInterpretationWriteEventVisualizationInterpretationRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) InterpretationWriteEventVisualizationInterpretationExecute(r ApiInterpretationWriteEventVisualizationInterpretationRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationWriteEventVisualizationInterpretation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/eventVisualization/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.ou != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/html", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationWriteMapInterpretationRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
	body       *string
}

// [no description yet]
func (r ApiInterpretationWriteMapInterpretationRequest) Body(body string) ApiInterpretationWriteMapInterpretationRequest {
	r.body = &body
	return r
}

func (r ApiInterpretationWriteMapInterpretationRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.InterpretationWriteMapInterpretationExecute(r)
}

/*
InterpretationWriteMapInterpretation Method for InterpretationWriteMapInterpretation

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiInterpretationWriteMapInterpretationRequest
*/
func (a *UiAPIService) InterpretationWriteMapInterpretation(ctx context.Context, uid string) ApiInterpretationWriteMapInterpretationRequest {
	return ApiInterpretationWriteMapInterpretationRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) InterpretationWriteMapInterpretationExecute(r ApiInterpretationWriteMapInterpretationRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationWriteMapInterpretation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/map/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/html", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInterpretationWriteVisualizationInterpretationRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
	body       *string
	ou         *string
}

// [no description yet]
func (r ApiInterpretationWriteVisualizationInterpretationRequest) Body(body string) ApiInterpretationWriteVisualizationInterpretationRequest {
	r.body = &body
	return r
}

// [no description yet]
func (r ApiInterpretationWriteVisualizationInterpretationRequest) Ou(ou string) ApiInterpretationWriteVisualizationInterpretationRequest {
	r.ou = &ou
	return r
}

func (r ApiInterpretationWriteVisualizationInterpretationRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.InterpretationWriteVisualizationInterpretationExecute(r)
}

/*
InterpretationWriteVisualizationInterpretation Method for InterpretationWriteVisualizationInterpretation

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiInterpretationWriteVisualizationInterpretationRequest
*/
func (a *UiAPIService) InterpretationWriteVisualizationInterpretation(ctx context.Context, uid string) ApiInterpretationWriteVisualizationInterpretationRequest {
	return ApiInterpretationWriteVisualizationInterpretationRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) InterpretationWriteVisualizationInterpretationExecute(r ApiInterpretationWriteVisualizationInterpretationRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.InterpretationWriteVisualizationInterpretation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interpretations/visualization/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.ou != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/html", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegendSetAddCollectionItemRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiLegendSetAddCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.LegendSetAddCollectionItemExecute(r)
}

/*
LegendSetAddCollectionItem Method for LegendSetAddCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiLegendSetAddCollectionItemRequest
*/
func (a *UiAPIService) LegendSetAddCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiLegendSetAddCollectionItemRequest {
	return ApiLegendSetAddCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) LegendSetAddCollectionItemExecute(r ApiLegendSetAddCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetAddCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegendSetAddCollectionItemsJsonaddCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *UiAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiLegendSetAddCollectionItemsJsonaddCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiLegendSetAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiLegendSetAddCollectionItemsJsonaddCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.LegendSetAddCollectionItemsJsonaddCollectionItemsXmlExecute(r)
}

/*
LegendSetAddCollectionItemsJsonaddCollectionItemsXml Method for LegendSetAddCollectionItemsJsonaddCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiLegendSetAddCollectionItemsJsonaddCollectionItemsXmlRequest
*/
func (a *UiAPIService) LegendSetAddCollectionItemsJsonaddCollectionItemsXml(ctx context.Context, property string, uid string) ApiLegendSetAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	return ApiLegendSetAddCollectionItemsJsonaddCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) LegendSetAddCollectionItemsJsonaddCollectionItemsXmlExecute(r ApiLegendSetAddCollectionItemsJsonaddCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetAddCollectionItemsJsonaddCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegendSetBulkSharingRequest struct {
	ctx                context.Context
	ApiService         *UiAPIService
	atomic             *bool
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	bulkJsonPatch      *BulkJsonPatch
}

// [no description yet]
func (r ApiLegendSetBulkSharingRequest) Atomic(atomic bool) ApiLegendSetBulkSharingRequest {
	r.atomic = &atomic
	return r
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiLegendSetBulkSharingRequest) AtomicMode(atomicMode string) ApiLegendSetBulkSharingRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiLegendSetBulkSharingRequest) FlushMode(flushMode string) ApiLegendSetBulkSharingRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiLegendSetBulkSharingRequest) Identifier(identifier string) ApiLegendSetBulkSharingRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiLegendSetBulkSharingRequest) ImportMode(importMode string) ApiLegendSetBulkSharingRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiLegendSetBulkSharingRequest) ImportReportMode(importReportMode string) ApiLegendSetBulkSharingRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiLegendSetBulkSharingRequest) ImportStrategy(importStrategy string) ApiLegendSetBulkSharingRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiLegendSetBulkSharingRequest) MergeMode(mergeMode string) ApiLegendSetBulkSharingRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiLegendSetBulkSharingRequest) MetadataSyncImport(metadataSyncImport bool) ApiLegendSetBulkSharingRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiLegendSetBulkSharingRequest) Page(page int32) ApiLegendSetBulkSharingRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiLegendSetBulkSharingRequest) PageSize(pageSize int32) ApiLegendSetBulkSharingRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiLegendSetBulkSharingRequest) Paging(paging bool) ApiLegendSetBulkSharingRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiLegendSetBulkSharingRequest) PreheatMode(preheatMode string) ApiLegendSetBulkSharingRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiLegendSetBulkSharingRequest) RootJunction(rootJunction string) ApiLegendSetBulkSharingRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiLegendSetBulkSharingRequest) SkipSharing(skipSharing bool) ApiLegendSetBulkSharingRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiLegendSetBulkSharingRequest) SkipTranslation(skipTranslation bool) ApiLegendSetBulkSharingRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiLegendSetBulkSharingRequest) SkipValidation(skipValidation bool) ApiLegendSetBulkSharingRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiLegendSetBulkSharingRequest) UserOverrideMode(userOverrideMode string) ApiLegendSetBulkSharingRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiLegendSetBulkSharingRequest) BulkJsonPatch(bulkJsonPatch BulkJsonPatch) ApiLegendSetBulkSharingRequest {
	r.bulkJsonPatch = &bulkJsonPatch
	return r
}

func (r ApiLegendSetBulkSharingRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.LegendSetBulkSharingExecute(r)
}

/*
LegendSetBulkSharing Method for LegendSetBulkSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLegendSetBulkSharingRequest
*/
func (a *UiAPIService) LegendSetBulkSharing(ctx context.Context) ApiLegendSetBulkSharingRequest {
	return ApiLegendSetBulkSharingRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) LegendSetBulkSharingExecute(r ApiLegendSetBulkSharingRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetBulkSharing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/sharing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomic", r.atomic, "")
	} else {
		var defaultValue bool = false
		r.atomic = &defaultValue
	}
	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkJsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegendSetDeleteCollectionItemRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiLegendSetDeleteCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.LegendSetDeleteCollectionItemExecute(r)
}

/*
LegendSetDeleteCollectionItem Method for LegendSetDeleteCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiLegendSetDeleteCollectionItemRequest
*/
func (a *UiAPIService) LegendSetDeleteCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiLegendSetDeleteCollectionItemRequest {
	return ApiLegendSetDeleteCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) LegendSetDeleteCollectionItemExecute(r ApiLegendSetDeleteCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetDeleteCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegendSetDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *UiAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiLegendSetDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiLegendSetDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiLegendSetDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.LegendSetDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r)
}

/*
LegendSetDeleteCollectionItemsJsondeleteCollectionItemsXml Method for LegendSetDeleteCollectionItemsJsondeleteCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiLegendSetDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest
*/
func (a *UiAPIService) LegendSetDeleteCollectionItemsJsondeleteCollectionItemsXml(ctx context.Context, property string, uid string) ApiLegendSetDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	return ApiLegendSetDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) LegendSetDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r ApiLegendSetDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetDeleteCollectionItemsJsondeleteCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegendSetDeleteObjectRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
}

func (r ApiLegendSetDeleteObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.LegendSetDeleteObjectExecute(r)
}

/*
LegendSetDeleteObject Method for LegendSetDeleteObject

Deletes the LegendSet provided by ID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiLegendSetDeleteObjectRequest
*/
func (a *UiAPIService) LegendSetDeleteObject(ctx context.Context, uid string) ApiLegendSetDeleteObjectRequest {
	return ApiLegendSetDeleteObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) LegendSetDeleteObjectExecute(r ApiLegendSetDeleteObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetDeleteObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegendSetGetObjectRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	uid          string
	fields       *[]string
	filter       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiLegendSetGetObjectRequest) Fields(fields []string) ApiLegendSetGetObjectRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiLegendSetGetObjectRequest) Filter(filter []string) ApiLegendSetGetObjectRequest {
	r.filter = &filter
	return r
}

// Defines which page number to return.
func (r ApiLegendSetGetObjectRequest) Page(page int32) ApiLegendSetGetObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiLegendSetGetObjectRequest) PageSize(pageSize int32) ApiLegendSetGetObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiLegendSetGetObjectRequest) Paging(paging bool) ApiLegendSetGetObjectRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiLegendSetGetObjectRequest) RootJunction(rootJunction string) ApiLegendSetGetObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiLegendSetGetObjectRequest) Execute() (*LegendSet, *http.Response, error) {
	return r.ApiService.LegendSetGetObjectExecute(r)
}

/*
LegendSetGetObject Method for LegendSetGetObject

View a LegendSet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiLegendSetGetObjectRequest
*/
func (a *UiAPIService) LegendSetGetObject(ctx context.Context, uid string) ApiLegendSetGetObjectRequest {
	return ApiLegendSetGetObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return LegendSet
func (a *UiAPIService) LegendSetGetObjectExecute(r ApiLegendSetGetObjectRequest) (*LegendSet, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LegendSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetGetObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegendSetGetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiLegendSetGetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiLegendSetGetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiLegendSetGetObjectGistAsCsvRequest) Auto(auto string) ApiLegendSetGetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiLegendSetGetObjectGistAsCsvRequest) Describe(describe bool) ApiLegendSetGetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiLegendSetGetObjectGistAsCsvRequest) Fields(fields string) ApiLegendSetGetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiLegendSetGetObjectGistAsCsvRequest) Filter(filter string) ApiLegendSetGetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiLegendSetGetObjectGistAsCsvRequest) Headless(headless bool) ApiLegendSetGetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiLegendSetGetObjectGistAsCsvRequest) Inverse(inverse bool) ApiLegendSetGetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiLegendSetGetObjectGistAsCsvRequest) Locale(locale string) ApiLegendSetGetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiLegendSetGetObjectGistAsCsvRequest) Order(order string) ApiLegendSetGetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiLegendSetGetObjectGistAsCsvRequest) Page(page int32) ApiLegendSetGetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiLegendSetGetObjectGistAsCsvRequest) PageListName(pageListName string) ApiLegendSetGetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiLegendSetGetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiLegendSetGetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiLegendSetGetObjectGistAsCsvRequest) References(references bool) ApiLegendSetGetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiLegendSetGetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiLegendSetGetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiLegendSetGetObjectGistAsCsvRequest) Total(total bool) ApiLegendSetGetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiLegendSetGetObjectGistAsCsvRequest) Translate(translate bool) ApiLegendSetGetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiLegendSetGetObjectGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.LegendSetGetObjectGistAsCsvExecute(r)
}

/*
LegendSetGetObjectGistAsCsv Method for LegendSetGetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiLegendSetGetObjectGistAsCsvRequest
*/
func (a *UiAPIService) LegendSetGetObjectGistAsCsv(ctx context.Context, uid string) ApiLegendSetGetObjectGistAsCsvRequest {
	return ApiLegendSetGetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *UiAPIService) LegendSetGetObjectGistAsCsvExecute(r ApiLegendSetGetObjectGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetGetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/{uid}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest) Auto(auto string) ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest) Describe(describe bool) ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest) Fields(fields string) ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest) Filter(filter string) ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest) Headless(headless bool) ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest) Inverse(inverse bool) ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest) Locale(locale string) ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest) Order(order string) ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest) Page(page int32) ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest) PageListName(pageListName string) ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest) References(references bool) ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest) Total(total bool) ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest) Translate(translate bool) ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.LegendSetGetObjectGistgetObjectGistAsCsvExecute(r)
}

/*
LegendSetGetObjectGistgetObjectGistAsCsv Method for LegendSetGetObjectGistgetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest
*/
func (a *UiAPIService) LegendSetGetObjectGistgetObjectGistAsCsv(ctx context.Context, uid string) ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest {
	return ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *UiAPIService) LegendSetGetObjectGistgetObjectGistAsCsvExecute(r ApiLegendSetGetObjectGistgetObjectGistAsCsvRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetGetObjectGistgetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/{uid}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegendSetGetObjectListRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	fields       *[]string
	filter       *[]string
	orders       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// &#x60;&lt;field-name&gt;[,&lt;field-name&gt;...]&#x60;
func (r ApiLegendSetGetObjectListRequest) Fields(fields []string) ApiLegendSetGetObjectListRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiLegendSetGetObjectListRequest) Filter(filter []string) ApiLegendSetGetObjectListRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiLegendSetGetObjectListRequest) Orders(orders []string) ApiLegendSetGetObjectListRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiLegendSetGetObjectListRequest) Page(page int32) ApiLegendSetGetObjectListRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiLegendSetGetObjectListRequest) PageSize(pageSize int32) ApiLegendSetGetObjectListRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiLegendSetGetObjectListRequest) Paging(paging bool) ApiLegendSetGetObjectListRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiLegendSetGetObjectListRequest) RootJunction(rootJunction string) ApiLegendSetGetObjectListRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiLegendSetGetObjectListRequest) Execute() (*LegendSetGetObjectList200Response, *http.Response, error) {
	return r.ApiService.LegendSetGetObjectListExecute(r)
}

/*
LegendSetGetObjectList Method for LegendSetGetObjectList

List all LegendSets

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLegendSetGetObjectListRequest
*/
func (a *UiAPIService) LegendSetGetObjectList(ctx context.Context) ApiLegendSetGetObjectListRequest {
	return ApiLegendSetGetObjectListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return LegendSetGetObjectList200Response
func (a *UiAPIService) LegendSetGetObjectListExecute(r ApiLegendSetGetObjectListRequest) (*LegendSetGetObjectList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LegendSetGetObjectList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetGetObjectList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegendSetGetObjectListCsvRequest struct {
	ctx            context.Context
	ApiService     *UiAPIService
	arraySeparator *string
	fields         *[]string
	filter         *[]string
	orders         *[]string
	page           *int32
	pageSize       *int32
	paging         *bool
	rootJunction   *string
	separator      *string
	skipHeader     *bool
}

// [no description yet]
func (r ApiLegendSetGetObjectListCsvRequest) ArraySeparator(arraySeparator string) ApiLegendSetGetObjectListCsvRequest {
	r.arraySeparator = &arraySeparator
	return r
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiLegendSetGetObjectListCsvRequest) Fields(fields []string) ApiLegendSetGetObjectListCsvRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiLegendSetGetObjectListCsvRequest) Filter(filter []string) ApiLegendSetGetObjectListCsvRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiLegendSetGetObjectListCsvRequest) Orders(orders []string) ApiLegendSetGetObjectListCsvRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiLegendSetGetObjectListCsvRequest) Page(page int32) ApiLegendSetGetObjectListCsvRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiLegendSetGetObjectListCsvRequest) PageSize(pageSize int32) ApiLegendSetGetObjectListCsvRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiLegendSetGetObjectListCsvRequest) Paging(paging bool) ApiLegendSetGetObjectListCsvRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiLegendSetGetObjectListCsvRequest) RootJunction(rootJunction string) ApiLegendSetGetObjectListCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiLegendSetGetObjectListCsvRequest) Separator(separator string) ApiLegendSetGetObjectListCsvRequest {
	r.separator = &separator
	return r
}

// [no description yet]
func (r ApiLegendSetGetObjectListCsvRequest) SkipHeader(skipHeader bool) ApiLegendSetGetObjectListCsvRequest {
	r.skipHeader = &skipHeader
	return r
}

func (r ApiLegendSetGetObjectListCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.LegendSetGetObjectListCsvExecute(r)
}

/*
LegendSetGetObjectListCsv Method for LegendSetGetObjectListCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLegendSetGetObjectListCsvRequest
*/
func (a *UiAPIService) LegendSetGetObjectListCsv(ctx context.Context) ApiLegendSetGetObjectListCsvRequest {
	return ApiLegendSetGetObjectListCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *UiAPIService) LegendSetGetObjectListCsvExecute(r ApiLegendSetGetObjectListCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetGetObjectListCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/#getObjectListCsv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.arraySeparator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arraySeparator", r.arraySeparator, "")
	} else {
		var defaultValue string = ";"
		r.arraySeparator = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.separator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "separator", r.separator, "")
	} else {
		var defaultValue string = ","
		r.separator = &defaultValue
	}
	if r.skipHeader != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipHeader", r.skipHeader, "")
	} else {
		var defaultValue bool = false
		r.skipHeader = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/text", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegendSetGetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiLegendSetGetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiLegendSetGetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiLegendSetGetObjectListGistAsCsvRequest) Auto(auto string) ApiLegendSetGetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiLegendSetGetObjectListGistAsCsvRequest) Describe(describe bool) ApiLegendSetGetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiLegendSetGetObjectListGistAsCsvRequest) Fields(fields string) ApiLegendSetGetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiLegendSetGetObjectListGistAsCsvRequest) Filter(filter string) ApiLegendSetGetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiLegendSetGetObjectListGistAsCsvRequest) Headless(headless bool) ApiLegendSetGetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiLegendSetGetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiLegendSetGetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiLegendSetGetObjectListGistAsCsvRequest) Locale(locale string) ApiLegendSetGetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiLegendSetGetObjectListGistAsCsvRequest) Order(order string) ApiLegendSetGetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiLegendSetGetObjectListGistAsCsvRequest) Page(page int32) ApiLegendSetGetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiLegendSetGetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiLegendSetGetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiLegendSetGetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiLegendSetGetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiLegendSetGetObjectListGistAsCsvRequest) References(references bool) ApiLegendSetGetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiLegendSetGetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiLegendSetGetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiLegendSetGetObjectListGistAsCsvRequest) Total(total bool) ApiLegendSetGetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiLegendSetGetObjectListGistAsCsvRequest) Translate(translate bool) ApiLegendSetGetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiLegendSetGetObjectListGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.LegendSetGetObjectListGistAsCsvExecute(r)
}

/*
LegendSetGetObjectListGistAsCsv Method for LegendSetGetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLegendSetGetObjectListGistAsCsvRequest
*/
func (a *UiAPIService) LegendSetGetObjectListGistAsCsv(ctx context.Context) ApiLegendSetGetObjectListGistAsCsvRequest {
	return ApiLegendSetGetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *UiAPIService) LegendSetGetObjectListGistAsCsvExecute(r ApiLegendSetGetObjectListGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetGetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/gist.csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest) Auto(auto string) ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest) Describe(describe bool) ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest) Fields(fields string) ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest) Filter(filter string) ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest) Headless(headless bool) ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest) Locale(locale string) ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest) Order(order string) ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest) Page(page int32) ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest) References(references bool) ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest) Total(total bool) ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest) Translate(translate bool) ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest) Execute() (*LegendSetGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.LegendSetGetObjectListGistgetObjectListGistAsCsvExecute(r)
}

/*
LegendSetGetObjectListGistgetObjectListGistAsCsv Method for LegendSetGetObjectListGistgetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest
*/
func (a *UiAPIService) LegendSetGetObjectListGistgetObjectListGistAsCsv(ctx context.Context) ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest {
	return ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return LegendSetGetObjectListGistGetObjectListGistAsCsv200Response
func (a *UiAPIService) LegendSetGetObjectListGistgetObjectListGistAsCsvExecute(r ApiLegendSetGetObjectListGistgetObjectListGistAsCsvRequest) (*LegendSetGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LegendSetGetObjectListGistGetObjectListGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetGetObjectListGistgetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/gist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegendSetGetObjectPropertyRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	property     string
	uid          string
	fields       *[]string
	locale       *string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
	translate    *bool
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiLegendSetGetObjectPropertyRequest) Fields(fields []string) ApiLegendSetGetObjectPropertyRequest {
	r.fields = &fields
	return r
}

// [no description yet]
func (r ApiLegendSetGetObjectPropertyRequest) Locale(locale string) ApiLegendSetGetObjectPropertyRequest {
	r.locale = &locale
	return r
}

// Defines which page number to return.
func (r ApiLegendSetGetObjectPropertyRequest) Page(page int32) ApiLegendSetGetObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiLegendSetGetObjectPropertyRequest) PageSize(pageSize int32) ApiLegendSetGetObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiLegendSetGetObjectPropertyRequest) Paging(paging bool) ApiLegendSetGetObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiLegendSetGetObjectPropertyRequest) RootJunction(rootJunction string) ApiLegendSetGetObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiLegendSetGetObjectPropertyRequest) Translate(translate bool) ApiLegendSetGetObjectPropertyRequest {
	r.translate = &translate
	return r
}

func (r ApiLegendSetGetObjectPropertyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.LegendSetGetObjectPropertyExecute(r)
}

/*
LegendSetGetObjectProperty Method for LegendSetGetObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiLegendSetGetObjectPropertyRequest
*/
func (a *UiAPIService) LegendSetGetObjectProperty(ctx context.Context, property string, uid string) ApiLegendSetGetObjectPropertyRequest {
	return ApiLegendSetGetObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *UiAPIService) LegendSetGetObjectPropertyExecute(r ApiLegendSetGetObjectPropertyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetGetObjectProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegendSetGetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiLegendSetGetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiLegendSetGetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiLegendSetGetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiLegendSetGetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiLegendSetGetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiLegendSetGetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiLegendSetGetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiLegendSetGetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiLegendSetGetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiLegendSetGetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiLegendSetGetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiLegendSetGetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiLegendSetGetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiLegendSetGetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiLegendSetGetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiLegendSetGetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiLegendSetGetObjectPropertyGistAsCsvRequest) Order(order string) ApiLegendSetGetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiLegendSetGetObjectPropertyGistAsCsvRequest) Page(page int32) ApiLegendSetGetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiLegendSetGetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiLegendSetGetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiLegendSetGetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiLegendSetGetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiLegendSetGetObjectPropertyGistAsCsvRequest) References(references bool) ApiLegendSetGetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiLegendSetGetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiLegendSetGetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiLegendSetGetObjectPropertyGistAsCsvRequest) Total(total bool) ApiLegendSetGetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiLegendSetGetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiLegendSetGetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiLegendSetGetObjectPropertyGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.LegendSetGetObjectPropertyGistAsCsvExecute(r)
}

/*
LegendSetGetObjectPropertyGistAsCsv Method for LegendSetGetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiLegendSetGetObjectPropertyGistAsCsvRequest
*/
func (a *UiAPIService) LegendSetGetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiLegendSetGetObjectPropertyGistAsCsvRequest {
	return ApiLegendSetGetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *UiAPIService) LegendSetGetObjectPropertyGistAsCsvExecute(r ApiLegendSetGetObjectPropertyGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetGetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/{uid}/{property}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *UiAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Order(order string) ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Page(page int32) ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) References(references bool) ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Total(total bool) ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Execute() (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.LegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r)
}

/*
LegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsv Method for LegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest
*/
func (a *UiAPIService) LegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	return ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
func (a *UiAPIService) LegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r ApiLegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetGetObjectPropertyGistgetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/{uid}/{property}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegendSetPatchObjectRequest struct {
	ctx                context.Context
	ApiService         *UiAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	jsonPatch          *JsonPatch
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiLegendSetPatchObjectRequest) AtomicMode(atomicMode string) ApiLegendSetPatchObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiLegendSetPatchObjectRequest) FlushMode(flushMode string) ApiLegendSetPatchObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiLegendSetPatchObjectRequest) Identifier(identifier string) ApiLegendSetPatchObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiLegendSetPatchObjectRequest) ImportMode(importMode string) ApiLegendSetPatchObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiLegendSetPatchObjectRequest) ImportReportMode(importReportMode string) ApiLegendSetPatchObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiLegendSetPatchObjectRequest) ImportStrategy(importStrategy string) ApiLegendSetPatchObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiLegendSetPatchObjectRequest) MergeMode(mergeMode string) ApiLegendSetPatchObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiLegendSetPatchObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiLegendSetPatchObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiLegendSetPatchObjectRequest) Page(page int32) ApiLegendSetPatchObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiLegendSetPatchObjectRequest) PageSize(pageSize int32) ApiLegendSetPatchObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiLegendSetPatchObjectRequest) Paging(paging bool) ApiLegendSetPatchObjectRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiLegendSetPatchObjectRequest) PreheatMode(preheatMode string) ApiLegendSetPatchObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiLegendSetPatchObjectRequest) RootJunction(rootJunction string) ApiLegendSetPatchObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiLegendSetPatchObjectRequest) SkipSharing(skipSharing bool) ApiLegendSetPatchObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiLegendSetPatchObjectRequest) SkipTranslation(skipTranslation bool) ApiLegendSetPatchObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiLegendSetPatchObjectRequest) SkipValidation(skipValidation bool) ApiLegendSetPatchObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiLegendSetPatchObjectRequest) UserOverrideMode(userOverrideMode string) ApiLegendSetPatchObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiLegendSetPatchObjectRequest) JsonPatch(jsonPatch JsonPatch) ApiLegendSetPatchObjectRequest {
	r.jsonPatch = &jsonPatch
	return r
}

func (r ApiLegendSetPatchObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.LegendSetPatchObjectExecute(r)
}

/*
LegendSetPatchObject Method for LegendSetPatchObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiLegendSetPatchObjectRequest
*/
func (a *UiAPIService) LegendSetPatchObject(ctx context.Context, uid string) ApiLegendSetPatchObjectRequest {
	return ApiLegendSetPatchObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) LegendSetPatchObjectExecute(r ApiLegendSetPatchObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetPatchObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegendSetPostJsonObjectpostXmlObjectRequest struct {
	ctx                context.Context
	ApiService         *UiAPIService
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	preheatMode        *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	legendSet          *LegendSet
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiLegendSetPostJsonObjectpostXmlObjectRequest) AtomicMode(atomicMode string) ApiLegendSetPostJsonObjectpostXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiLegendSetPostJsonObjectpostXmlObjectRequest) FlushMode(flushMode string) ApiLegendSetPostJsonObjectpostXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiLegendSetPostJsonObjectpostXmlObjectRequest) Identifier(identifier string) ApiLegendSetPostJsonObjectpostXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiLegendSetPostJsonObjectpostXmlObjectRequest) ImportMode(importMode string) ApiLegendSetPostJsonObjectpostXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiLegendSetPostJsonObjectpostXmlObjectRequest) ImportReportMode(importReportMode string) ApiLegendSetPostJsonObjectpostXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiLegendSetPostJsonObjectpostXmlObjectRequest) ImportStrategy(importStrategy string) ApiLegendSetPostJsonObjectpostXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiLegendSetPostJsonObjectpostXmlObjectRequest) MergeMode(mergeMode string) ApiLegendSetPostJsonObjectpostXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiLegendSetPostJsonObjectpostXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiLegendSetPostJsonObjectpostXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiLegendSetPostJsonObjectpostXmlObjectRequest) PreheatMode(preheatMode string) ApiLegendSetPostJsonObjectpostXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiLegendSetPostJsonObjectpostXmlObjectRequest) SkipSharing(skipSharing bool) ApiLegendSetPostJsonObjectpostXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiLegendSetPostJsonObjectpostXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiLegendSetPostJsonObjectpostXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiLegendSetPostJsonObjectpostXmlObjectRequest) SkipValidation(skipValidation bool) ApiLegendSetPostJsonObjectpostXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiLegendSetPostJsonObjectpostXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiLegendSetPostJsonObjectpostXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiLegendSetPostJsonObjectpostXmlObjectRequest) LegendSet(legendSet LegendSet) ApiLegendSetPostJsonObjectpostXmlObjectRequest {
	r.legendSet = &legendSet
	return r
}

func (r ApiLegendSetPostJsonObjectpostXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.LegendSetPostJsonObjectpostXmlObjectExecute(r)
}

/*
LegendSetPostJsonObjectpostXmlObject Method for LegendSetPostJsonObjectpostXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLegendSetPostJsonObjectpostXmlObjectRequest
*/
func (a *UiAPIService) LegendSetPostJsonObjectpostXmlObject(ctx context.Context) ApiLegendSetPostJsonObjectpostXmlObjectRequest {
	return ApiLegendSetPostJsonObjectpostXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) LegendSetPostJsonObjectpostXmlObjectExecute(r ApiLegendSetPostJsonObjectpostXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetPostJsonObjectpostXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.legendSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegendSetPutJsonObjectputXmlObjectRequest struct {
	ctx                context.Context
	ApiService         *UiAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	preheatMode        *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	legendSet          *LegendSet
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiLegendSetPutJsonObjectputXmlObjectRequest) AtomicMode(atomicMode string) ApiLegendSetPutJsonObjectputXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiLegendSetPutJsonObjectputXmlObjectRequest) FlushMode(flushMode string) ApiLegendSetPutJsonObjectputXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiLegendSetPutJsonObjectputXmlObjectRequest) Identifier(identifier string) ApiLegendSetPutJsonObjectputXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiLegendSetPutJsonObjectputXmlObjectRequest) ImportMode(importMode string) ApiLegendSetPutJsonObjectputXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiLegendSetPutJsonObjectputXmlObjectRequest) ImportReportMode(importReportMode string) ApiLegendSetPutJsonObjectputXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiLegendSetPutJsonObjectputXmlObjectRequest) ImportStrategy(importStrategy string) ApiLegendSetPutJsonObjectputXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiLegendSetPutJsonObjectputXmlObjectRequest) MergeMode(mergeMode string) ApiLegendSetPutJsonObjectputXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiLegendSetPutJsonObjectputXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiLegendSetPutJsonObjectputXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiLegendSetPutJsonObjectputXmlObjectRequest) PreheatMode(preheatMode string) ApiLegendSetPutJsonObjectputXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiLegendSetPutJsonObjectputXmlObjectRequest) SkipSharing(skipSharing bool) ApiLegendSetPutJsonObjectputXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiLegendSetPutJsonObjectputXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiLegendSetPutJsonObjectputXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiLegendSetPutJsonObjectputXmlObjectRequest) SkipValidation(skipValidation bool) ApiLegendSetPutJsonObjectputXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiLegendSetPutJsonObjectputXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiLegendSetPutJsonObjectputXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiLegendSetPutJsonObjectputXmlObjectRequest) LegendSet(legendSet LegendSet) ApiLegendSetPutJsonObjectputXmlObjectRequest {
	r.legendSet = &legendSet
	return r
}

func (r ApiLegendSetPutJsonObjectputXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.LegendSetPutJsonObjectputXmlObjectExecute(r)
}

/*
LegendSetPutJsonObjectputXmlObject Method for LegendSetPutJsonObjectputXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiLegendSetPutJsonObjectputXmlObjectRequest
*/
func (a *UiAPIService) LegendSetPutJsonObjectputXmlObject(ctx context.Context, uid string) ApiLegendSetPutJsonObjectputXmlObjectRequest {
	return ApiLegendSetPutJsonObjectputXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) LegendSetPutJsonObjectputXmlObjectExecute(r ApiLegendSetPutJsonObjectputXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetPutJsonObjectputXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.legendSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegendSetRemoveAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
}

func (r ApiLegendSetRemoveAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.LegendSetRemoveAsFavoriteExecute(r)
}

/*
LegendSetRemoveAsFavorite Method for LegendSetRemoveAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiLegendSetRemoveAsFavoriteRequest
*/
func (a *UiAPIService) LegendSetRemoveAsFavorite(ctx context.Context, uid string) ApiLegendSetRemoveAsFavoriteRequest {
	return ApiLegendSetRemoveAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) LegendSetRemoveAsFavoriteExecute(r ApiLegendSetRemoveAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetRemoveAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegendSetReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *UiAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiLegendSetReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiLegendSetReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiLegendSetReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.LegendSetReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r)
}

/*
LegendSetReplaceCollectionItemsJsonreplaceCollectionItemsXml Method for LegendSetReplaceCollectionItemsJsonreplaceCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiLegendSetReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest
*/
func (a *UiAPIService) LegendSetReplaceCollectionItemsJsonreplaceCollectionItemsXml(ctx context.Context, property string, uid string) ApiLegendSetReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	return ApiLegendSetReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) LegendSetReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r ApiLegendSetReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetReplaceCollectionItemsJsonreplaceCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegendSetReplaceTranslationsRequest struct {
	ctx                                             context.Context
	ApiService                                      *UiAPIService
	uid                                             string
	aggregateDataExchangeReplaceTranslationsRequest *AggregateDataExchangeReplaceTranslationsRequest
}

// [no description yet]
func (r ApiLegendSetReplaceTranslationsRequest) AggregateDataExchangeReplaceTranslationsRequest(aggregateDataExchangeReplaceTranslationsRequest AggregateDataExchangeReplaceTranslationsRequest) ApiLegendSetReplaceTranslationsRequest {
	r.aggregateDataExchangeReplaceTranslationsRequest = &aggregateDataExchangeReplaceTranslationsRequest
	return r
}

func (r ApiLegendSetReplaceTranslationsRequest) Execute() (*http.Response, error) {
	return r.ApiService.LegendSetReplaceTranslationsExecute(r)
}

/*
LegendSetReplaceTranslations Method for LegendSetReplaceTranslations

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiLegendSetReplaceTranslationsRequest
*/
func (a *UiAPIService) LegendSetReplaceTranslations(ctx context.Context, uid string) ApiLegendSetReplaceTranslationsRequest {
	return ApiLegendSetReplaceTranslationsRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *UiAPIService) LegendSetReplaceTranslationsExecute(r ApiLegendSetReplaceTranslationsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetReplaceTranslations")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/{uid}/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateDataExchangeReplaceTranslationsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLegendSetSetAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
}

func (r ApiLegendSetSetAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.LegendSetSetAsFavoriteExecute(r)
}

/*
LegendSetSetAsFavorite Method for LegendSetSetAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiLegendSetSetAsFavoriteRequest
*/
func (a *UiAPIService) LegendSetSetAsFavorite(ctx context.Context, uid string) ApiLegendSetSetAsFavoriteRequest {
	return ApiLegendSetSetAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) LegendSetSetAsFavoriteExecute(r ApiLegendSetSetAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetSetAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegendSetSetSharingRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
	sharing    *Sharing
}

// [no description yet]
func (r ApiLegendSetSetSharingRequest) Sharing(sharing Sharing) ApiLegendSetSetSharingRequest {
	r.sharing = &sharing
	return r
}

func (r ApiLegendSetSetSharingRequest) Execute() (*http.Response, error) {
	return r.ApiService.LegendSetSetSharingExecute(r)
}

/*
LegendSetSetSharing Method for LegendSetSetSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiLegendSetSetSharingRequest
*/
func (a *UiAPIService) LegendSetSetSharing(ctx context.Context, uid string) ApiLegendSetSetSharingRequest {
	return ApiLegendSetSetSharingRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *UiAPIService) LegendSetSetSharingExecute(r ApiLegendSetSetSharingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetSetSharing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/{uid}/sharing"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharing
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLegendSetSubscribeRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
}

func (r ApiLegendSetSubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.LegendSetSubscribeExecute(r)
}

/*
LegendSetSubscribe Method for LegendSetSubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiLegendSetSubscribeRequest
*/
func (a *UiAPIService) LegendSetSubscribe(ctx context.Context, uid string) ApiLegendSetSubscribeRequest {
	return ApiLegendSetSubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) LegendSetSubscribeExecute(r ApiLegendSetSubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetSubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegendSetUnsubscribeRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
}

func (r ApiLegendSetUnsubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.LegendSetUnsubscribeExecute(r)
}

/*
LegendSetUnsubscribe Method for LegendSetUnsubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiLegendSetUnsubscribeRequest
*/
func (a *UiAPIService) LegendSetUnsubscribe(ctx context.Context, uid string) ApiLegendSetUnsubscribeRequest {
	return ApiLegendSetUnsubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) LegendSetUnsubscribeExecute(r ApiLegendSetUnsubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetUnsubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegendSetUpdateObjectPropertyRequest struct {
	ctx                context.Context
	ApiService         *UiAPIService
	property           string
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	legendSet          *LegendSet
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiLegendSetUpdateObjectPropertyRequest) AtomicMode(atomicMode string) ApiLegendSetUpdateObjectPropertyRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiLegendSetUpdateObjectPropertyRequest) FlushMode(flushMode string) ApiLegendSetUpdateObjectPropertyRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiLegendSetUpdateObjectPropertyRequest) Identifier(identifier string) ApiLegendSetUpdateObjectPropertyRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiLegendSetUpdateObjectPropertyRequest) ImportMode(importMode string) ApiLegendSetUpdateObjectPropertyRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiLegendSetUpdateObjectPropertyRequest) ImportReportMode(importReportMode string) ApiLegendSetUpdateObjectPropertyRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiLegendSetUpdateObjectPropertyRequest) ImportStrategy(importStrategy string) ApiLegendSetUpdateObjectPropertyRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiLegendSetUpdateObjectPropertyRequest) MergeMode(mergeMode string) ApiLegendSetUpdateObjectPropertyRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiLegendSetUpdateObjectPropertyRequest) MetadataSyncImport(metadataSyncImport bool) ApiLegendSetUpdateObjectPropertyRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiLegendSetUpdateObjectPropertyRequest) Page(page int32) ApiLegendSetUpdateObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiLegendSetUpdateObjectPropertyRequest) PageSize(pageSize int32) ApiLegendSetUpdateObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiLegendSetUpdateObjectPropertyRequest) Paging(paging bool) ApiLegendSetUpdateObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiLegendSetUpdateObjectPropertyRequest) PreheatMode(preheatMode string) ApiLegendSetUpdateObjectPropertyRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiLegendSetUpdateObjectPropertyRequest) RootJunction(rootJunction string) ApiLegendSetUpdateObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiLegendSetUpdateObjectPropertyRequest) SkipSharing(skipSharing bool) ApiLegendSetUpdateObjectPropertyRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiLegendSetUpdateObjectPropertyRequest) SkipTranslation(skipTranslation bool) ApiLegendSetUpdateObjectPropertyRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiLegendSetUpdateObjectPropertyRequest) SkipValidation(skipValidation bool) ApiLegendSetUpdateObjectPropertyRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiLegendSetUpdateObjectPropertyRequest) UserOverrideMode(userOverrideMode string) ApiLegendSetUpdateObjectPropertyRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiLegendSetUpdateObjectPropertyRequest) LegendSet(legendSet LegendSet) ApiLegendSetUpdateObjectPropertyRequest {
	r.legendSet = &legendSet
	return r
}

func (r ApiLegendSetUpdateObjectPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.LegendSetUpdateObjectPropertyExecute(r)
}

/*
LegendSetUpdateObjectProperty Method for LegendSetUpdateObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiLegendSetUpdateObjectPropertyRequest
*/
func (a *UiAPIService) LegendSetUpdateObjectProperty(ctx context.Context, property string, uid string) ApiLegendSetUpdateObjectPropertyRequest {
	return ApiLegendSetUpdateObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
func (a *UiAPIService) LegendSetUpdateObjectPropertyExecute(r ApiLegendSetUpdateObjectPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LegendSetUpdateObjectProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/legendSets/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.legendSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLocaleAddLocaleRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	country    *string
	language   *string
}

// [no description yet]
func (r ApiLocaleAddLocaleRequest) Country(country string) ApiLocaleAddLocaleRequest {
	r.country = &country
	return r
}

// [no description yet]
func (r ApiLocaleAddLocaleRequest) Language(language string) ApiLocaleAddLocaleRequest {
	r.language = &language
	return r
}

func (r ApiLocaleAddLocaleRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.LocaleAddLocaleExecute(r)
}

/*
LocaleAddLocale Method for LocaleAddLocale

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLocaleAddLocaleRequest
*/
func (a *UiAPIService) LocaleAddLocale(ctx context.Context) ApiLocaleAddLocaleRequest {
	return ApiLocaleAddLocaleRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) LocaleAddLocaleExecute(r ApiLocaleAddLocaleRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LocaleAddLocale")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/locales/dbLocales"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.country == nil {
		return localVarReturnValue, nil, reportError("country is required and must be specified")
	}
	if r.language == nil {
		return localVarReturnValue, nil, reportError("language is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLocaleDeleteRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
}

func (r ApiLocaleDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.LocaleDeleteExecute(r)
}

/*
LocaleDelete Method for LocaleDelete

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiLocaleDeleteRequest
*/
func (a *UiAPIService) LocaleDelete(ctx context.Context, uid string) ApiLocaleDeleteRequest {
	return ApiLocaleDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *UiAPIService) LocaleDeleteExecute(r ApiLocaleDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LocaleDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/locales/dbLocales/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLocaleGetAvailableCountriesRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
}

func (r ApiLocaleGetAvailableCountriesRequest) Execute() (map[string]string, *http.Response, error) {
	return r.ApiService.LocaleGetAvailableCountriesExecute(r)
}

/*
LocaleGetAvailableCountries Method for LocaleGetAvailableCountries

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLocaleGetAvailableCountriesRequest
*/
func (a *UiAPIService) LocaleGetAvailableCountries(ctx context.Context) ApiLocaleGetAvailableCountriesRequest {
	return ApiLocaleGetAvailableCountriesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]string
func (a *UiAPIService) LocaleGetAvailableCountriesExecute(r ApiLocaleGetAvailableCountriesRequest) (map[string]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LocaleGetAvailableCountries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/locales/countries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLocaleGetAvailableLanguagesRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
}

func (r ApiLocaleGetAvailableLanguagesRequest) Execute() (map[string]string, *http.Response, error) {
	return r.ApiService.LocaleGetAvailableLanguagesExecute(r)
}

/*
LocaleGetAvailableLanguages Method for LocaleGetAvailableLanguages

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLocaleGetAvailableLanguagesRequest
*/
func (a *UiAPIService) LocaleGetAvailableLanguages(ctx context.Context) ApiLocaleGetAvailableLanguagesRequest {
	return ApiLocaleGetAvailableLanguagesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]string
func (a *UiAPIService) LocaleGetAvailableLanguagesExecute(r ApiLocaleGetAvailableLanguagesRequest) (map[string]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LocaleGetAvailableLanguages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/locales/languages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLocaleGetDbLocalesRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
}

func (r ApiLocaleGetDbLocalesRequest) Execute() ([]WebLocale, *http.Response, error) {
	return r.ApiService.LocaleGetDbLocalesExecute(r)
}

/*
LocaleGetDbLocales Method for LocaleGetDbLocales

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLocaleGetDbLocalesRequest
*/
func (a *UiAPIService) LocaleGetDbLocales(ctx context.Context) ApiLocaleGetDbLocalesRequest {
	return ApiLocaleGetDbLocalesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []WebLocale
func (a *UiAPIService) LocaleGetDbLocalesExecute(r ApiLocaleGetDbLocalesRequest) ([]WebLocale, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []WebLocale
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LocaleGetDbLocales")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/locales/db"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLocaleGetDbLocalesWithIdRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
}

func (r ApiLocaleGetDbLocalesWithIdRequest) Execute() ([]I18nLocale, *http.Response, error) {
	return r.ApiService.LocaleGetDbLocalesWithIdExecute(r)
}

/*
LocaleGetDbLocalesWithId Method for LocaleGetDbLocalesWithId

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLocaleGetDbLocalesWithIdRequest
*/
func (a *UiAPIService) LocaleGetDbLocalesWithId(ctx context.Context) ApiLocaleGetDbLocalesWithIdRequest {
	return ApiLocaleGetDbLocalesWithIdRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []I18nLocale
func (a *UiAPIService) LocaleGetDbLocalesWithIdExecute(r ApiLocaleGetDbLocalesWithIdRequest) ([]I18nLocale, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []I18nLocale
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LocaleGetDbLocalesWithId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/locales/dbLocales"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLocaleGetObjectRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
}

func (r ApiLocaleGetObjectRequest) Execute() (*I18nLocale, *http.Response, error) {
	return r.ApiService.LocaleGetObjectExecute(r)
}

/*
LocaleGetObject Method for LocaleGetObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiLocaleGetObjectRequest
*/
func (a *UiAPIService) LocaleGetObject(ctx context.Context, uid string) ApiLocaleGetObjectRequest {
	return ApiLocaleGetObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return I18nLocale
func (a *UiAPIService) LocaleGetObjectExecute(r ApiLocaleGetObjectRequest) (*I18nLocale, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *I18nLocale
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LocaleGetObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/locales/dbLocales/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLocaleGetUiLocalesRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
}

func (r ApiLocaleGetUiLocalesRequest) Execute() ([]WebLocale, *http.Response, error) {
	return r.ApiService.LocaleGetUiLocalesExecute(r)
}

/*
LocaleGetUiLocales Method for LocaleGetUiLocales

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLocaleGetUiLocalesRequest
*/
func (a *UiAPIService) LocaleGetUiLocales(ctx context.Context) ApiLocaleGetUiLocalesRequest {
	return ApiLocaleGetUiLocalesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []WebLocale
func (a *UiAPIService) LocaleGetUiLocalesExecute(r ApiLocaleGetUiLocalesRequest) ([]WebLocale, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []WebLocale
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.LocaleGetUiLocales")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/locales/ui"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMenuSaveMenuOrderRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
}

func (r ApiMenuSaveMenuOrderRequest) Execute() (*http.Response, error) {
	return r.ApiService.MenuSaveMenuOrderExecute(r)
}

/*
MenuSaveMenuOrder Method for MenuSaveMenuOrder

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMenuSaveMenuOrderRequest
*/
func (a *UiAPIService) MenuSaveMenuOrder(ctx context.Context) ApiMenuSaveMenuOrderRequest {
	return ApiMenuSaveMenuOrderRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *UiAPIService) MenuSaveMenuOrderExecute(r ApiMenuSaveMenuOrderRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.MenuSaveMenuOrder")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/menu/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPdfFormGetFormPdfDataSetRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	dataSetUid string
}

func (r ApiPdfFormGetFormPdfDataSetRequest) Execute() (*http.Response, error) {
	return r.ApiService.PdfFormGetFormPdfDataSetExecute(r)
}

/*
PdfFormGetFormPdfDataSet Method for PdfFormGetFormPdfDataSet

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param dataSetUid [no description yet]
	@return ApiPdfFormGetFormPdfDataSetRequest
*/
func (a *UiAPIService) PdfFormGetFormPdfDataSet(ctx context.Context, dataSetUid string) ApiPdfFormGetFormPdfDataSetRequest {
	return ApiPdfFormGetFormPdfDataSetRequest{
		ApiService: a,
		ctx:        ctx,
		dataSetUid: dataSetUid,
	}
}

// Execute executes the request
func (a *UiAPIService) PdfFormGetFormPdfDataSetExecute(r ApiPdfFormGetFormPdfDataSetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.PdfFormGetFormPdfDataSet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pdfForm/dataSet/{dataSetUid}"
	localVarPath = strings.Replace(localVarPath, "{"+"dataSetUid"+"}", url.PathEscape(parameterValueToString(r.dataSetUid, "dataSetUid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPdfFormSendFormPdfDataSetRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
}

func (r ApiPdfFormSendFormPdfDataSetRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.PdfFormSendFormPdfDataSetExecute(r)
}

/*
PdfFormSendFormPdfDataSet Method for PdfFormSendFormPdfDataSet

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPdfFormSendFormPdfDataSetRequest
*/
func (a *UiAPIService) PdfFormSendFormPdfDataSet(ctx context.Context) ApiPdfFormSendFormPdfDataSetRequest {
	return ApiPdfFormSendFormPdfDataSetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *UiAPIService) PdfFormSendFormPdfDataSetExecute(r ApiPdfFormSendFormPdfDataSetRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.PdfFormSendFormPdfDataSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pdfForm/dataSet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVisualizationDataGetVisualizationChartDataRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	in         *string
	ou         *string
	attachment *bool
	height     *int32
	periods    *bool
	skipTitle  *bool
	width      *int32
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartDataRequest) In(in string) ApiVisualizationDataGetVisualizationChartDataRequest {
	r.in = &in
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartDataRequest) Ou(ou string) ApiVisualizationDataGetVisualizationChartDataRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartDataRequest) Attachment(attachment bool) ApiVisualizationDataGetVisualizationChartDataRequest {
	r.attachment = &attachment
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartDataRequest) Height(height int32) ApiVisualizationDataGetVisualizationChartDataRequest {
	r.height = &height
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartDataRequest) Periods(periods bool) ApiVisualizationDataGetVisualizationChartDataRequest {
	r.periods = &periods
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartDataRequest) SkipTitle(skipTitle bool) ApiVisualizationDataGetVisualizationChartDataRequest {
	r.skipTitle = &skipTitle
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartDataRequest) Width(width int32) ApiVisualizationDataGetVisualizationChartDataRequest {
	r.width = &width
	return r
}

func (r ApiVisualizationDataGetVisualizationChartDataRequest) Execute() (*http.Response, error) {
	return r.ApiService.VisualizationDataGetVisualizationChartDataExecute(r)
}

/*
VisualizationDataGetVisualizationChartData Method for VisualizationDataGetVisualizationChartData

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVisualizationDataGetVisualizationChartDataRequest
*/
func (a *UiAPIService) VisualizationDataGetVisualizationChartData(ctx context.Context) ApiVisualizationDataGetVisualizationChartDataRequest {
	return ApiVisualizationDataGetVisualizationChartDataRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *UiAPIService) VisualizationDataGetVisualizationChartDataExecute(r ApiVisualizationDataGetVisualizationChartDataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.VisualizationDataGetVisualizationChartData")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/visualizations/data"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.in == nil {
		return nil, reportError("in is required and must be specified")
	}
	if r.ou == nil {
		return nil, reportError("ou is required and must be specified")
	}

	if r.attachment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachment", r.attachment, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "")
	} else {
		var defaultValue int32 = 500
		r.height = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "in", r.in, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	if r.periods != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "periods", r.periods, "")
	}
	if r.skipTitle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTitle", r.skipTitle, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "")
	} else {
		var defaultValue int32 = 800
		r.width = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVisualizationDataGetVisualizationChartData2Request struct {
	ctx        context.Context
	ApiService *UiAPIService
	in         *string
	ou         *string
	attachment *bool
	height     *int32
	periods    *bool
	skipTitle  *bool
	width      *int32
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartData2Request) In(in string) ApiVisualizationDataGetVisualizationChartData2Request {
	r.in = &in
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartData2Request) Ou(ou string) ApiVisualizationDataGetVisualizationChartData2Request {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartData2Request) Attachment(attachment bool) ApiVisualizationDataGetVisualizationChartData2Request {
	r.attachment = &attachment
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartData2Request) Height(height int32) ApiVisualizationDataGetVisualizationChartData2Request {
	r.height = &height
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartData2Request) Periods(periods bool) ApiVisualizationDataGetVisualizationChartData2Request {
	r.periods = &periods
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartData2Request) SkipTitle(skipTitle bool) ApiVisualizationDataGetVisualizationChartData2Request {
	r.skipTitle = &skipTitle
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartData2Request) Width(width int32) ApiVisualizationDataGetVisualizationChartData2Request {
	r.width = &width
	return r
}

func (r ApiVisualizationDataGetVisualizationChartData2Request) Execute() (*http.Response, error) {
	return r.ApiService.VisualizationDataGetVisualizationChartData2Execute(r)
}

/*
VisualizationDataGetVisualizationChartData2 Method for VisualizationDataGetVisualizationChartData2

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVisualizationDataGetVisualizationChartData2Request
*/
func (a *UiAPIService) VisualizationDataGetVisualizationChartData2(ctx context.Context) ApiVisualizationDataGetVisualizationChartData2Request {
	return ApiVisualizationDataGetVisualizationChartData2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *UiAPIService) VisualizationDataGetVisualizationChartData2Execute(r ApiVisualizationDataGetVisualizationChartData2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.VisualizationDataGetVisualizationChartData2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/visualizations/data.png"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.in == nil {
		return nil, reportError("in is required and must be specified")
	}
	if r.ou == nil {
		return nil, reportError("ou is required and must be specified")
	}

	if r.attachment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachment", r.attachment, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "")
	} else {
		var defaultValue int32 = 500
		r.height = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "in", r.in, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	if r.periods != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "periods", r.periods, "")
	}
	if r.skipTitle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTitle", r.skipTitle, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "")
	} else {
		var defaultValue int32 = 800
		r.width = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVisualizationDataGetVisualizationChartHistoryRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	co         *string
	cp         *string
	de         *string
	ou         *string
	pe         *string
	height     *int32
	width      *int32
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartHistoryRequest) Co(co string) ApiVisualizationDataGetVisualizationChartHistoryRequest {
	r.co = &co
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartHistoryRequest) Cp(cp string) ApiVisualizationDataGetVisualizationChartHistoryRequest {
	r.cp = &cp
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartHistoryRequest) De(de string) ApiVisualizationDataGetVisualizationChartHistoryRequest {
	r.de = &de
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartHistoryRequest) Ou(ou string) ApiVisualizationDataGetVisualizationChartHistoryRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartHistoryRequest) Pe(pe string) ApiVisualizationDataGetVisualizationChartHistoryRequest {
	r.pe = &pe
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartHistoryRequest) Height(height int32) ApiVisualizationDataGetVisualizationChartHistoryRequest {
	r.height = &height
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartHistoryRequest) Width(width int32) ApiVisualizationDataGetVisualizationChartHistoryRequest {
	r.width = &width
	return r
}

func (r ApiVisualizationDataGetVisualizationChartHistoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.VisualizationDataGetVisualizationChartHistoryExecute(r)
}

/*
VisualizationDataGetVisualizationChartHistory Method for VisualizationDataGetVisualizationChartHistory

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVisualizationDataGetVisualizationChartHistoryRequest
*/
func (a *UiAPIService) VisualizationDataGetVisualizationChartHistory(ctx context.Context) ApiVisualizationDataGetVisualizationChartHistoryRequest {
	return ApiVisualizationDataGetVisualizationChartHistoryRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *UiAPIService) VisualizationDataGetVisualizationChartHistoryExecute(r ApiVisualizationDataGetVisualizationChartHistoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.VisualizationDataGetVisualizationChartHistory")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/visualizations/history/data"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.co == nil {
		return nil, reportError("co is required and must be specified")
	}
	if r.cp == nil {
		return nil, reportError("cp is required and must be specified")
	}
	if r.de == nil {
		return nil, reportError("de is required and must be specified")
	}
	if r.ou == nil {
		return nil, reportError("ou is required and must be specified")
	}
	if r.pe == nil {
		return nil, reportError("pe is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "co", r.co, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "cp", r.cp, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "de", r.de, "")
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "")
	} else {
		var defaultValue int32 = 300
		r.height = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pe", r.pe, "")
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "")
	} else {
		var defaultValue int32 = 525
		r.width = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVisualizationDataGetVisualizationChartHistory2Request struct {
	ctx        context.Context
	ApiService *UiAPIService
	co         *string
	cp         *string
	de         *string
	ou         *string
	pe         *string
	height     *int32
	width      *int32
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartHistory2Request) Co(co string) ApiVisualizationDataGetVisualizationChartHistory2Request {
	r.co = &co
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartHistory2Request) Cp(cp string) ApiVisualizationDataGetVisualizationChartHistory2Request {
	r.cp = &cp
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartHistory2Request) De(de string) ApiVisualizationDataGetVisualizationChartHistory2Request {
	r.de = &de
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartHistory2Request) Ou(ou string) ApiVisualizationDataGetVisualizationChartHistory2Request {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartHistory2Request) Pe(pe string) ApiVisualizationDataGetVisualizationChartHistory2Request {
	r.pe = &pe
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartHistory2Request) Height(height int32) ApiVisualizationDataGetVisualizationChartHistory2Request {
	r.height = &height
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationChartHistory2Request) Width(width int32) ApiVisualizationDataGetVisualizationChartHistory2Request {
	r.width = &width
	return r
}

func (r ApiVisualizationDataGetVisualizationChartHistory2Request) Execute() (*http.Response, error) {
	return r.ApiService.VisualizationDataGetVisualizationChartHistory2Execute(r)
}

/*
VisualizationDataGetVisualizationChartHistory2 Method for VisualizationDataGetVisualizationChartHistory2

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVisualizationDataGetVisualizationChartHistory2Request
*/
func (a *UiAPIService) VisualizationDataGetVisualizationChartHistory2(ctx context.Context) ApiVisualizationDataGetVisualizationChartHistory2Request {
	return ApiVisualizationDataGetVisualizationChartHistory2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *UiAPIService) VisualizationDataGetVisualizationChartHistory2Execute(r ApiVisualizationDataGetVisualizationChartHistory2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.VisualizationDataGetVisualizationChartHistory2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/visualizations/history/data.png"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.co == nil {
		return nil, reportError("co is required and must be specified")
	}
	if r.cp == nil {
		return nil, reportError("cp is required and must be specified")
	}
	if r.de == nil {
		return nil, reportError("de is required and must be specified")
	}
	if r.ou == nil {
		return nil, reportError("ou is required and must be specified")
	}
	if r.pe == nil {
		return nil, reportError("pe is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "co", r.co, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "cp", r.cp, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "de", r.de, "")
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "")
	} else {
		var defaultValue int32 = 300
		r.height = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pe", r.pe, "")
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "")
	} else {
		var defaultValue int32 = 525
		r.width = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVisualizationDataGetVisualizationDataRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
	attachment *bool
	date       *time.Time
	height     *int32
	ou         *string
	width      *int32
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationDataRequest) Attachment(attachment bool) ApiVisualizationDataGetVisualizationDataRequest {
	r.attachment = &attachment
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationDataRequest) Date(date time.Time) ApiVisualizationDataGetVisualizationDataRequest {
	r.date = &date
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationDataRequest) Height(height int32) ApiVisualizationDataGetVisualizationDataRequest {
	r.height = &height
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationDataRequest) Ou(ou string) ApiVisualizationDataGetVisualizationDataRequest {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationDataRequest) Width(width int32) ApiVisualizationDataGetVisualizationDataRequest {
	r.width = &width
	return r
}

func (r ApiVisualizationDataGetVisualizationDataRequest) Execute() (*http.Response, error) {
	return r.ApiService.VisualizationDataGetVisualizationDataExecute(r)
}

/*
VisualizationDataGetVisualizationData Method for VisualizationDataGetVisualizationData

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiVisualizationDataGetVisualizationDataRequest
*/
func (a *UiAPIService) VisualizationDataGetVisualizationData(ctx context.Context, uid string) ApiVisualizationDataGetVisualizationDataRequest {
	return ApiVisualizationDataGetVisualizationDataRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *UiAPIService) VisualizationDataGetVisualizationDataExecute(r ApiVisualizationDataGetVisualizationDataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.VisualizationDataGetVisualizationData")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/visualizations/{uid}/data"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.attachment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachment", r.attachment, "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "")
	} else {
		var defaultValue int32 = 500
		r.height = &defaultValue
	}
	if r.ou != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "")
	} else {
		var defaultValue int32 = 800
		r.width = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVisualizationDataGetVisualizationData2Request struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
	attachment *bool
	date       *time.Time
	height     *int32
	ou         *string
	width      *int32
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationData2Request) Attachment(attachment bool) ApiVisualizationDataGetVisualizationData2Request {
	r.attachment = &attachment
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationData2Request) Date(date time.Time) ApiVisualizationDataGetVisualizationData2Request {
	r.date = &date
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationData2Request) Height(height int32) ApiVisualizationDataGetVisualizationData2Request {
	r.height = &height
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationData2Request) Ou(ou string) ApiVisualizationDataGetVisualizationData2Request {
	r.ou = &ou
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationData2Request) Width(width int32) ApiVisualizationDataGetVisualizationData2Request {
	r.width = &width
	return r
}

func (r ApiVisualizationDataGetVisualizationData2Request) Execute() (*http.Response, error) {
	return r.ApiService.VisualizationDataGetVisualizationData2Execute(r)
}

/*
VisualizationDataGetVisualizationData2 Method for VisualizationDataGetVisualizationData2

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiVisualizationDataGetVisualizationData2Request
*/
func (a *UiAPIService) VisualizationDataGetVisualizationData2(ctx context.Context, uid string) ApiVisualizationDataGetVisualizationData2Request {
	return ApiVisualizationDataGetVisualizationData2Request{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *UiAPIService) VisualizationDataGetVisualizationData2Execute(r ApiVisualizationDataGetVisualizationData2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.VisualizationDataGetVisualizationData2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/visualizations/{uid}/data.png"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.attachment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachment", r.attachment, "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "")
	} else {
		var defaultValue int32 = 500
		r.height = &defaultValue
	}
	if r.ou != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "")
	} else {
		var defaultValue int32 = 800
		r.width = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVisualizationDataGetVisualizationDataCsvRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
	date       *time.Time
	ou         *string
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationDataCsvRequest) Date(date time.Time) ApiVisualizationDataGetVisualizationDataCsvRequest {
	r.date = &date
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationDataCsvRequest) Ou(ou string) ApiVisualizationDataGetVisualizationDataCsvRequest {
	r.ou = &ou
	return r
}

func (r ApiVisualizationDataGetVisualizationDataCsvRequest) Execute() (*http.Response, error) {
	return r.ApiService.VisualizationDataGetVisualizationDataCsvExecute(r)
}

/*
VisualizationDataGetVisualizationDataCsv Method for VisualizationDataGetVisualizationDataCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiVisualizationDataGetVisualizationDataCsvRequest
*/
func (a *UiAPIService) VisualizationDataGetVisualizationDataCsv(ctx context.Context, uid string) ApiVisualizationDataGetVisualizationDataCsvRequest {
	return ApiVisualizationDataGetVisualizationDataCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *UiAPIService) VisualizationDataGetVisualizationDataCsvExecute(r ApiVisualizationDataGetVisualizationDataCsvRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.VisualizationDataGetVisualizationDataCsv")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/visualizations/{uid}/data.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.ou != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVisualizationDataGetVisualizationDataHtmlRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
	date       *time.Time
	ou         *string
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationDataHtmlRequest) Date(date time.Time) ApiVisualizationDataGetVisualizationDataHtmlRequest {
	r.date = &date
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationDataHtmlRequest) Ou(ou string) ApiVisualizationDataGetVisualizationDataHtmlRequest {
	r.ou = &ou
	return r
}

func (r ApiVisualizationDataGetVisualizationDataHtmlRequest) Execute() (*Grid, *http.Response, error) {
	return r.ApiService.VisualizationDataGetVisualizationDataHtmlExecute(r)
}

/*
VisualizationDataGetVisualizationDataHtml Method for VisualizationDataGetVisualizationDataHtml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiVisualizationDataGetVisualizationDataHtmlRequest
*/
func (a *UiAPIService) VisualizationDataGetVisualizationDataHtml(ctx context.Context, uid string) ApiVisualizationDataGetVisualizationDataHtmlRequest {
	return ApiVisualizationDataGetVisualizationDataHtmlRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return Grid
func (a *UiAPIService) VisualizationDataGetVisualizationDataHtmlExecute(r ApiVisualizationDataGetVisualizationDataHtmlRequest) (*Grid, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Grid
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.VisualizationDataGetVisualizationDataHtml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/visualizations/{uid}/data.html"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.ou != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVisualizationDataGetVisualizationDataHtmlCssRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
	date       *time.Time
	ou         *string
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationDataHtmlCssRequest) Date(date time.Time) ApiVisualizationDataGetVisualizationDataHtmlCssRequest {
	r.date = &date
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationDataHtmlCssRequest) Ou(ou string) ApiVisualizationDataGetVisualizationDataHtmlCssRequest {
	r.ou = &ou
	return r
}

func (r ApiVisualizationDataGetVisualizationDataHtmlCssRequest) Execute() (*http.Response, error) {
	return r.ApiService.VisualizationDataGetVisualizationDataHtmlCssExecute(r)
}

/*
VisualizationDataGetVisualizationDataHtmlCss Method for VisualizationDataGetVisualizationDataHtmlCss

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiVisualizationDataGetVisualizationDataHtmlCssRequest
*/
func (a *UiAPIService) VisualizationDataGetVisualizationDataHtmlCss(ctx context.Context, uid string) ApiVisualizationDataGetVisualizationDataHtmlCssRequest {
	return ApiVisualizationDataGetVisualizationDataHtmlCssRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *UiAPIService) VisualizationDataGetVisualizationDataHtmlCssExecute(r ApiVisualizationDataGetVisualizationDataHtmlCssRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.VisualizationDataGetVisualizationDataHtmlCss")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/visualizations/{uid}/data.html+css"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.ou != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVisualizationDataGetVisualizationDataPdfRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
	date       *time.Time
	ou         *string
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationDataPdfRequest) Date(date time.Time) ApiVisualizationDataGetVisualizationDataPdfRequest {
	r.date = &date
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationDataPdfRequest) Ou(ou string) ApiVisualizationDataGetVisualizationDataPdfRequest {
	r.ou = &ou
	return r
}

func (r ApiVisualizationDataGetVisualizationDataPdfRequest) Execute() (*http.Response, error) {
	return r.ApiService.VisualizationDataGetVisualizationDataPdfExecute(r)
}

/*
VisualizationDataGetVisualizationDataPdf Method for VisualizationDataGetVisualizationDataPdf

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiVisualizationDataGetVisualizationDataPdfRequest
*/
func (a *UiAPIService) VisualizationDataGetVisualizationDataPdf(ctx context.Context, uid string) ApiVisualizationDataGetVisualizationDataPdfRequest {
	return ApiVisualizationDataGetVisualizationDataPdfRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *UiAPIService) VisualizationDataGetVisualizationDataPdfExecute(r ApiVisualizationDataGetVisualizationDataPdfRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.VisualizationDataGetVisualizationDataPdf")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/visualizations/{uid}/data.pdf"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.ou != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVisualizationDataGetVisualizationDataXlsRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
	date       *time.Time
	ou         *string
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationDataXlsRequest) Date(date time.Time) ApiVisualizationDataGetVisualizationDataXlsRequest {
	r.date = &date
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationDataXlsRequest) Ou(ou string) ApiVisualizationDataGetVisualizationDataXlsRequest {
	r.ou = &ou
	return r
}

func (r ApiVisualizationDataGetVisualizationDataXlsRequest) Execute() (*http.Response, error) {
	return r.ApiService.VisualizationDataGetVisualizationDataXlsExecute(r)
}

/*
VisualizationDataGetVisualizationDataXls Method for VisualizationDataGetVisualizationDataXls

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiVisualizationDataGetVisualizationDataXlsRequest
*/
func (a *UiAPIService) VisualizationDataGetVisualizationDataXls(ctx context.Context, uid string) ApiVisualizationDataGetVisualizationDataXlsRequest {
	return ApiVisualizationDataGetVisualizationDataXlsRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *UiAPIService) VisualizationDataGetVisualizationDataXlsExecute(r ApiVisualizationDataGetVisualizationDataXlsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.VisualizationDataGetVisualizationDataXls")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/visualizations/{uid}/data.xls"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.ou != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVisualizationDataGetVisualizationDataXmlRequest struct {
	ctx        context.Context
	ApiService *UiAPIService
	uid        string
	date       *time.Time
	ou         *string
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationDataXmlRequest) Date(date time.Time) ApiVisualizationDataGetVisualizationDataXmlRequest {
	r.date = &date
	return r
}

// [no description yet]
func (r ApiVisualizationDataGetVisualizationDataXmlRequest) Ou(ou string) ApiVisualizationDataGetVisualizationDataXmlRequest {
	r.ou = &ou
	return r
}

func (r ApiVisualizationDataGetVisualizationDataXmlRequest) Execute() (*http.Response, error) {
	return r.ApiService.VisualizationDataGetVisualizationDataXmlExecute(r)
}

/*
VisualizationDataGetVisualizationDataXml Method for VisualizationDataGetVisualizationDataXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiVisualizationDataGetVisualizationDataXmlRequest
*/
func (a *UiAPIService) VisualizationDataGetVisualizationDataXml(ctx context.Context, uid string) ApiVisualizationDataGetVisualizationDataXmlRequest {
	return ApiVisualizationDataGetVisualizationDataXmlRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *UiAPIService) VisualizationDataGetVisualizationDataXmlExecute(r ApiVisualizationDataGetVisualizationDataXmlRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiAPIService.VisualizationDataGetVisualizationDataXml")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/visualizations/{uid}/data.xml"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.ou != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ou", r.ou, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
