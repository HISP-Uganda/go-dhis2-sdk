/*
DHIS2 API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.40
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package models

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
	"time"
)

// MessagingAPIService MessagingAPI service
type MessagingAPIService service

type ApiEmailSendEmailNotificationRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	message    *string
	recipients *[]string
	subject    *string
}

// [no description yet]
func (r ApiEmailSendEmailNotificationRequest) Message(message string) ApiEmailSendEmailNotificationRequest {
	r.message = &message
	return r
}

// [no description yet]
func (r ApiEmailSendEmailNotificationRequest) Recipients(recipients []string) ApiEmailSendEmailNotificationRequest {
	r.recipients = &recipients
	return r
}

// [no description yet]
func (r ApiEmailSendEmailNotificationRequest) Subject(subject string) ApiEmailSendEmailNotificationRequest {
	r.subject = &subject
	return r
}

func (r ApiEmailSendEmailNotificationRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.EmailSendEmailNotificationExecute(r)
}

/*
EmailSendEmailNotification Method for EmailSendEmailNotification

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEmailSendEmailNotificationRequest
*/
func (a *MessagingAPIService) EmailSendEmailNotification(ctx context.Context) ApiEmailSendEmailNotificationRequest {
	return ApiEmailSendEmailNotificationRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) EmailSendEmailNotificationExecute(r ApiEmailSendEmailNotificationRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.EmailSendEmailNotification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/email/notification#sendEmailNotification"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.message == nil {
		return localVarReturnValue, nil, reportError("message is required and must be specified")
	}
	if r.recipients == nil {
		return localVarReturnValue, nil, reportError("recipients is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "message", r.message, "")
	{
		t := *r.recipients
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "recipients", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "recipients", t, "multi")
		}
	}
	if r.subject != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subject", r.subject, "")
	} else {
		var defaultValue string = "DHIS 2"
		r.subject = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEmailSendSystemNotificationEmailRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	email      *Email
}

// [no description yet]
func (r ApiEmailSendSystemNotificationEmailRequest) Email(email Email) ApiEmailSendSystemNotificationEmailRequest {
	r.email = &email
	return r
}

func (r ApiEmailSendSystemNotificationEmailRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.EmailSendSystemNotificationEmailExecute(r)
}

/*
EmailSendSystemNotificationEmail Method for EmailSendSystemNotificationEmail

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEmailSendSystemNotificationEmailRequest
*/
func (a *MessagingAPIService) EmailSendSystemNotificationEmail(ctx context.Context) ApiEmailSendSystemNotificationEmailRequest {
	return ApiEmailSendSystemNotificationEmailRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) EmailSendSystemNotificationEmailExecute(r ApiEmailSendSystemNotificationEmailRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.EmailSendSystemNotificationEmail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/email/notification"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.email
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEmailSendTestEmailRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
}

func (r ApiEmailSendTestEmailRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.EmailSendTestEmailExecute(r)
}

/*
EmailSendTestEmail Method for EmailSendTestEmail

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEmailSendTestEmailRequest
*/
func (a *MessagingAPIService) EmailSendTestEmail(ctx context.Context) ApiEmailSendTestEmailRequest {
	return ApiEmailSendTestEmailRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) EmailSendTestEmailExecute(r ApiEmailSendTestEmailRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.EmailSendTestEmail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/email/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationAddCollectionItemRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiMessageConversationAddCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.MessageConversationAddCollectionItemExecute(r)
}

/*
MessageConversationAddCollectionItem Method for MessageConversationAddCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiMessageConversationAddCollectionItemRequest
*/
func (a *MessagingAPIService) MessageConversationAddCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiMessageConversationAddCollectionItemRequest {
	return ApiMessageConversationAddCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) MessageConversationAddCollectionItemExecute(r ApiMessageConversationAddCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationAddCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationAddCollectionItemsJsonaddCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *MessagingAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiMessageConversationAddCollectionItemsJsonaddCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiMessageConversationAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiMessageConversationAddCollectionItemsJsonaddCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.MessageConversationAddCollectionItemsJsonaddCollectionItemsXmlExecute(r)
}

/*
MessageConversationAddCollectionItemsJsonaddCollectionItemsXml Method for MessageConversationAddCollectionItemsJsonaddCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiMessageConversationAddCollectionItemsJsonaddCollectionItemsXmlRequest
*/
func (a *MessagingAPIService) MessageConversationAddCollectionItemsJsonaddCollectionItemsXml(ctx context.Context, property string, uid string) ApiMessageConversationAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	return ApiMessageConversationAddCollectionItemsJsonaddCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) MessageConversationAddCollectionItemsJsonaddCollectionItemsXmlExecute(r ApiMessageConversationAddCollectionItemsJsonaddCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationAddCollectionItemsJsonaddCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationAddRecipientsToMessageConversationRequest struct {
	ctx                     context.Context
	ApiService              *MessagingAPIService
	uid                     string
	messageConversationInfo *MessageConversationInfo
}

// [no description yet]
func (r ApiMessageConversationAddRecipientsToMessageConversationRequest) MessageConversationInfo(messageConversationInfo MessageConversationInfo) ApiMessageConversationAddRecipientsToMessageConversationRequest {
	r.messageConversationInfo = &messageConversationInfo
	return r
}

func (r ApiMessageConversationAddRecipientsToMessageConversationRequest) Execute() (*http.Response, error) {
	return r.ApiService.MessageConversationAddRecipientsToMessageConversationExecute(r)
}

/*
MessageConversationAddRecipientsToMessageConversation Method for MessageConversationAddRecipientsToMessageConversation

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiMessageConversationAddRecipientsToMessageConversationRequest
*/
func (a *MessagingAPIService) MessageConversationAddRecipientsToMessageConversation(ctx context.Context, uid string) ApiMessageConversationAddRecipientsToMessageConversationRequest {
	return ApiMessageConversationAddRecipientsToMessageConversationRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *MessagingAPIService) MessageConversationAddRecipientsToMessageConversationExecute(r ApiMessageConversationAddRecipientsToMessageConversationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationAddRecipientsToMessageConversation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}/recipients"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.messageConversationInfo == nil {
		return nil, reportError("messageConversationInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.messageConversationInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMessageConversationBulkSharingRequest struct {
	ctx                context.Context
	ApiService         *MessagingAPIService
	atomic             *bool
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	bulkJsonPatch      *BulkJsonPatch
}

// [no description yet]
func (r ApiMessageConversationBulkSharingRequest) Atomic(atomic bool) ApiMessageConversationBulkSharingRequest {
	r.atomic = &atomic
	return r
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiMessageConversationBulkSharingRequest) AtomicMode(atomicMode string) ApiMessageConversationBulkSharingRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiMessageConversationBulkSharingRequest) FlushMode(flushMode string) ApiMessageConversationBulkSharingRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiMessageConversationBulkSharingRequest) Identifier(identifier string) ApiMessageConversationBulkSharingRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiMessageConversationBulkSharingRequest) ImportMode(importMode string) ApiMessageConversationBulkSharingRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiMessageConversationBulkSharingRequest) ImportReportMode(importReportMode string) ApiMessageConversationBulkSharingRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiMessageConversationBulkSharingRequest) ImportStrategy(importStrategy string) ApiMessageConversationBulkSharingRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiMessageConversationBulkSharingRequest) MergeMode(mergeMode string) ApiMessageConversationBulkSharingRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiMessageConversationBulkSharingRequest) MetadataSyncImport(metadataSyncImport bool) ApiMessageConversationBulkSharingRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiMessageConversationBulkSharingRequest) Page(page int32) ApiMessageConversationBulkSharingRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiMessageConversationBulkSharingRequest) PageSize(pageSize int32) ApiMessageConversationBulkSharingRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiMessageConversationBulkSharingRequest) Paging(paging bool) ApiMessageConversationBulkSharingRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiMessageConversationBulkSharingRequest) PreheatMode(preheatMode string) ApiMessageConversationBulkSharingRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiMessageConversationBulkSharingRequest) RootJunction(rootJunction string) ApiMessageConversationBulkSharingRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiMessageConversationBulkSharingRequest) SkipSharing(skipSharing bool) ApiMessageConversationBulkSharingRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiMessageConversationBulkSharingRequest) SkipTranslation(skipTranslation bool) ApiMessageConversationBulkSharingRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiMessageConversationBulkSharingRequest) SkipValidation(skipValidation bool) ApiMessageConversationBulkSharingRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiMessageConversationBulkSharingRequest) UserOverrideMode(userOverrideMode string) ApiMessageConversationBulkSharingRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiMessageConversationBulkSharingRequest) BulkJsonPatch(bulkJsonPatch BulkJsonPatch) ApiMessageConversationBulkSharingRequest {
	r.bulkJsonPatch = &bulkJsonPatch
	return r
}

func (r ApiMessageConversationBulkSharingRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.MessageConversationBulkSharingExecute(r)
}

/*
MessageConversationBulkSharing Method for MessageConversationBulkSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMessageConversationBulkSharingRequest
*/
func (a *MessagingAPIService) MessageConversationBulkSharing(ctx context.Context) ApiMessageConversationBulkSharingRequest {
	return ApiMessageConversationBulkSharingRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) MessageConversationBulkSharingExecute(r ApiMessageConversationBulkSharingRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationBulkSharing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/sharing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomic", r.atomic, "")
	} else {
		var defaultValue bool = false
		r.atomic = &defaultValue
	}
	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkJsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationDeleteCollectionItemRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiMessageConversationDeleteCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.MessageConversationDeleteCollectionItemExecute(r)
}

/*
MessageConversationDeleteCollectionItem Method for MessageConversationDeleteCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiMessageConversationDeleteCollectionItemRequest
*/
func (a *MessagingAPIService) MessageConversationDeleteCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiMessageConversationDeleteCollectionItemRequest {
	return ApiMessageConversationDeleteCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) MessageConversationDeleteCollectionItemExecute(r ApiMessageConversationDeleteCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationDeleteCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *MessagingAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiMessageConversationDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiMessageConversationDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiMessageConversationDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.MessageConversationDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r)
}

/*
MessageConversationDeleteCollectionItemsJsondeleteCollectionItemsXml Method for MessageConversationDeleteCollectionItemsJsondeleteCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiMessageConversationDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest
*/
func (a *MessagingAPIService) MessageConversationDeleteCollectionItemsJsondeleteCollectionItemsXml(ctx context.Context, property string, uid string) ApiMessageConversationDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	return ApiMessageConversationDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) MessageConversationDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r ApiMessageConversationDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationDeleteCollectionItemsJsondeleteCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationDeleteObjectRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
}

func (r ApiMessageConversationDeleteObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.MessageConversationDeleteObjectExecute(r)
}

/*
MessageConversationDeleteObject Method for MessageConversationDeleteObject

Deletes the MessageConversation provided by ID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiMessageConversationDeleteObjectRequest
*/
func (a *MessagingAPIService) MessageConversationDeleteObject(ctx context.Context, uid string) ApiMessageConversationDeleteObjectRequest {
	return ApiMessageConversationDeleteObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) MessageConversationDeleteObjectExecute(r ApiMessageConversationDeleteObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationDeleteObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationGetAttachmentRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	fileUid    string
	mcUid      string
	msgUid     string
}

func (r ApiMessageConversationGetAttachmentRequest) Execute() (*http.Response, error) {
	return r.ApiService.MessageConversationGetAttachmentExecute(r)
}

/*
MessageConversationGetAttachment Method for MessageConversationGetAttachment

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fileUid [no description yet]
	@param mcUid [no description yet]
	@param msgUid [no description yet]
	@return ApiMessageConversationGetAttachmentRequest
*/
func (a *MessagingAPIService) MessageConversationGetAttachment(ctx context.Context, fileUid string, mcUid string, msgUid string) ApiMessageConversationGetAttachmentRequest {
	return ApiMessageConversationGetAttachmentRequest{
		ApiService: a,
		ctx:        ctx,
		fileUid:    fileUid,
		mcUid:      mcUid,
		msgUid:     msgUid,
	}
}

// Execute executes the request
func (a *MessagingAPIService) MessageConversationGetAttachmentExecute(r ApiMessageConversationGetAttachmentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationGetAttachment")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{mcUid}/{msgUid}/attachments/{fileUid}"
	localVarPath = strings.Replace(localVarPath, "{"+"fileUid"+"}", url.PathEscape(parameterValueToString(r.fileUid, "fileUid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mcUid"+"}", url.PathEscape(parameterValueToString(r.mcUid, "mcUid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"msgUid"+"}", url.PathEscape(parameterValueToString(r.msgUid, "msgUid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMessageConversationGetObjectRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	uid          string
	fields       *[]string
	filter       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiMessageConversationGetObjectRequest) Fields(fields []string) ApiMessageConversationGetObjectRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiMessageConversationGetObjectRequest) Filter(filter []string) ApiMessageConversationGetObjectRequest {
	r.filter = &filter
	return r
}

// Defines which page number to return.
func (r ApiMessageConversationGetObjectRequest) Page(page int32) ApiMessageConversationGetObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiMessageConversationGetObjectRequest) PageSize(pageSize int32) ApiMessageConversationGetObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiMessageConversationGetObjectRequest) Paging(paging bool) ApiMessageConversationGetObjectRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiMessageConversationGetObjectRequest) RootJunction(rootJunction string) ApiMessageConversationGetObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiMessageConversationGetObjectRequest) Execute() (*MessageConversation, *http.Response, error) {
	return r.ApiService.MessageConversationGetObjectExecute(r)
}

/*
MessageConversationGetObject Method for MessageConversationGetObject

View a MessageConversation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiMessageConversationGetObjectRequest
*/
func (a *MessagingAPIService) MessageConversationGetObject(ctx context.Context, uid string) ApiMessageConversationGetObjectRequest {
	return ApiMessageConversationGetObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return MessageConversation
func (a *MessagingAPIService) MessageConversationGetObjectExecute(r ApiMessageConversationGetObjectRequest) (*MessageConversation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MessageConversation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationGetObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationGetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiMessageConversationGetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiMessageConversationGetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiMessageConversationGetObjectGistAsCsvRequest) Auto(auto string) ApiMessageConversationGetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiMessageConversationGetObjectGistAsCsvRequest) Describe(describe bool) ApiMessageConversationGetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiMessageConversationGetObjectGistAsCsvRequest) Fields(fields string) ApiMessageConversationGetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiMessageConversationGetObjectGistAsCsvRequest) Filter(filter string) ApiMessageConversationGetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiMessageConversationGetObjectGistAsCsvRequest) Headless(headless bool) ApiMessageConversationGetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiMessageConversationGetObjectGistAsCsvRequest) Inverse(inverse bool) ApiMessageConversationGetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiMessageConversationGetObjectGistAsCsvRequest) Locale(locale string) ApiMessageConversationGetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiMessageConversationGetObjectGistAsCsvRequest) Order(order string) ApiMessageConversationGetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiMessageConversationGetObjectGistAsCsvRequest) Page(page int32) ApiMessageConversationGetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiMessageConversationGetObjectGistAsCsvRequest) PageListName(pageListName string) ApiMessageConversationGetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiMessageConversationGetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiMessageConversationGetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiMessageConversationGetObjectGistAsCsvRequest) References(references bool) ApiMessageConversationGetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiMessageConversationGetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiMessageConversationGetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiMessageConversationGetObjectGistAsCsvRequest) Total(total bool) ApiMessageConversationGetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiMessageConversationGetObjectGistAsCsvRequest) Translate(translate bool) ApiMessageConversationGetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiMessageConversationGetObjectGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.MessageConversationGetObjectGistAsCsvExecute(r)
}

/*
MessageConversationGetObjectGistAsCsv Method for MessageConversationGetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiMessageConversationGetObjectGistAsCsvRequest
*/
func (a *MessagingAPIService) MessageConversationGetObjectGistAsCsv(ctx context.Context, uid string) ApiMessageConversationGetObjectGistAsCsvRequest {
	return ApiMessageConversationGetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *MessagingAPIService) MessageConversationGetObjectGistAsCsvExecute(r ApiMessageConversationGetObjectGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationGetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest) Auto(auto string) ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest) Describe(describe bool) ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest) Fields(fields string) ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest) Filter(filter string) ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest) Headless(headless bool) ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest) Inverse(inverse bool) ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest) Locale(locale string) ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest) Order(order string) ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest) Page(page int32) ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest) PageListName(pageListName string) ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest) References(references bool) ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest) Total(total bool) ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest) Translate(translate bool) ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MessageConversationGetObjectGistgetObjectGistAsCsvExecute(r)
}

/*
MessageConversationGetObjectGistgetObjectGistAsCsv Method for MessageConversationGetObjectGistgetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest
*/
func (a *MessagingAPIService) MessageConversationGetObjectGistgetObjectGistAsCsv(ctx context.Context, uid string) ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest {
	return ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MessagingAPIService) MessageConversationGetObjectGistgetObjectGistAsCsvExecute(r ApiMessageConversationGetObjectGistgetObjectGistAsCsvRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationGetObjectGistgetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationGetObjectListRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	fields       *[]string
	filter       *[]string
	orders       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// &#x60;&lt;field-name&gt;[,&lt;field-name&gt;...]&#x60;
func (r ApiMessageConversationGetObjectListRequest) Fields(fields []string) ApiMessageConversationGetObjectListRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiMessageConversationGetObjectListRequest) Filter(filter []string) ApiMessageConversationGetObjectListRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiMessageConversationGetObjectListRequest) Orders(orders []string) ApiMessageConversationGetObjectListRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiMessageConversationGetObjectListRequest) Page(page int32) ApiMessageConversationGetObjectListRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiMessageConversationGetObjectListRequest) PageSize(pageSize int32) ApiMessageConversationGetObjectListRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiMessageConversationGetObjectListRequest) Paging(paging bool) ApiMessageConversationGetObjectListRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiMessageConversationGetObjectListRequest) RootJunction(rootJunction string) ApiMessageConversationGetObjectListRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiMessageConversationGetObjectListRequest) Execute() (*MessageConversationGetObjectList200Response, *http.Response, error) {
	return r.ApiService.MessageConversationGetObjectListExecute(r)
}

/*
MessageConversationGetObjectList Method for MessageConversationGetObjectList

List all MessageConversations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMessageConversationGetObjectListRequest
*/
func (a *MessagingAPIService) MessageConversationGetObjectList(ctx context.Context) ApiMessageConversationGetObjectListRequest {
	return ApiMessageConversationGetObjectListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MessageConversationGetObjectList200Response
func (a *MessagingAPIService) MessageConversationGetObjectListExecute(r ApiMessageConversationGetObjectListRequest) (*MessageConversationGetObjectList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MessageConversationGetObjectList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationGetObjectList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationGetObjectListCsvRequest struct {
	ctx            context.Context
	ApiService     *MessagingAPIService
	arraySeparator *string
	fields         *[]string
	filter         *[]string
	orders         *[]string
	page           *int32
	pageSize       *int32
	paging         *bool
	rootJunction   *string
	separator      *string
	skipHeader     *bool
}

// [no description yet]
func (r ApiMessageConversationGetObjectListCsvRequest) ArraySeparator(arraySeparator string) ApiMessageConversationGetObjectListCsvRequest {
	r.arraySeparator = &arraySeparator
	return r
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiMessageConversationGetObjectListCsvRequest) Fields(fields []string) ApiMessageConversationGetObjectListCsvRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiMessageConversationGetObjectListCsvRequest) Filter(filter []string) ApiMessageConversationGetObjectListCsvRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiMessageConversationGetObjectListCsvRequest) Orders(orders []string) ApiMessageConversationGetObjectListCsvRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiMessageConversationGetObjectListCsvRequest) Page(page int32) ApiMessageConversationGetObjectListCsvRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiMessageConversationGetObjectListCsvRequest) PageSize(pageSize int32) ApiMessageConversationGetObjectListCsvRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiMessageConversationGetObjectListCsvRequest) Paging(paging bool) ApiMessageConversationGetObjectListCsvRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiMessageConversationGetObjectListCsvRequest) RootJunction(rootJunction string) ApiMessageConversationGetObjectListCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiMessageConversationGetObjectListCsvRequest) Separator(separator string) ApiMessageConversationGetObjectListCsvRequest {
	r.separator = &separator
	return r
}

// [no description yet]
func (r ApiMessageConversationGetObjectListCsvRequest) SkipHeader(skipHeader bool) ApiMessageConversationGetObjectListCsvRequest {
	r.skipHeader = &skipHeader
	return r
}

func (r ApiMessageConversationGetObjectListCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.MessageConversationGetObjectListCsvExecute(r)
}

/*
MessageConversationGetObjectListCsv Method for MessageConversationGetObjectListCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMessageConversationGetObjectListCsvRequest
*/
func (a *MessagingAPIService) MessageConversationGetObjectListCsv(ctx context.Context) ApiMessageConversationGetObjectListCsvRequest {
	return ApiMessageConversationGetObjectListCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *MessagingAPIService) MessageConversationGetObjectListCsvExecute(r ApiMessageConversationGetObjectListCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationGetObjectListCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/#getObjectListCsv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.arraySeparator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arraySeparator", r.arraySeparator, "")
	} else {
		var defaultValue string = ";"
		r.arraySeparator = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.separator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "separator", r.separator, "")
	} else {
		var defaultValue string = ","
		r.separator = &defaultValue
	}
	if r.skipHeader != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipHeader", r.skipHeader, "")
	} else {
		var defaultValue bool = false
		r.skipHeader = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/text", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationGetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiMessageConversationGetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiMessageConversationGetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiMessageConversationGetObjectListGistAsCsvRequest) Auto(auto string) ApiMessageConversationGetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiMessageConversationGetObjectListGistAsCsvRequest) Describe(describe bool) ApiMessageConversationGetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiMessageConversationGetObjectListGistAsCsvRequest) Fields(fields string) ApiMessageConversationGetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiMessageConversationGetObjectListGistAsCsvRequest) Filter(filter string) ApiMessageConversationGetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiMessageConversationGetObjectListGistAsCsvRequest) Headless(headless bool) ApiMessageConversationGetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiMessageConversationGetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiMessageConversationGetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiMessageConversationGetObjectListGistAsCsvRequest) Locale(locale string) ApiMessageConversationGetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiMessageConversationGetObjectListGistAsCsvRequest) Order(order string) ApiMessageConversationGetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiMessageConversationGetObjectListGistAsCsvRequest) Page(page int32) ApiMessageConversationGetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiMessageConversationGetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiMessageConversationGetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiMessageConversationGetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiMessageConversationGetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiMessageConversationGetObjectListGistAsCsvRequest) References(references bool) ApiMessageConversationGetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiMessageConversationGetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiMessageConversationGetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiMessageConversationGetObjectListGistAsCsvRequest) Total(total bool) ApiMessageConversationGetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiMessageConversationGetObjectListGistAsCsvRequest) Translate(translate bool) ApiMessageConversationGetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiMessageConversationGetObjectListGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.MessageConversationGetObjectListGistAsCsvExecute(r)
}

/*
MessageConversationGetObjectListGistAsCsv Method for MessageConversationGetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMessageConversationGetObjectListGistAsCsvRequest
*/
func (a *MessagingAPIService) MessageConversationGetObjectListGistAsCsv(ctx context.Context) ApiMessageConversationGetObjectListGistAsCsvRequest {
	return ApiMessageConversationGetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *MessagingAPIService) MessageConversationGetObjectListGistAsCsvExecute(r ApiMessageConversationGetObjectListGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationGetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/gist.csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest) Auto(auto string) ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest) Describe(describe bool) ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest) Fields(fields string) ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest) Filter(filter string) ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest) Headless(headless bool) ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest) Locale(locale string) ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest) Order(order string) ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest) Page(page int32) ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest) References(references bool) ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest) Total(total bool) ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest) Translate(translate bool) ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest) Execute() (*MessageConversationGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.MessageConversationGetObjectListGistgetObjectListGistAsCsvExecute(r)
}

/*
MessageConversationGetObjectListGistgetObjectListGistAsCsv Method for MessageConversationGetObjectListGistgetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest
*/
func (a *MessagingAPIService) MessageConversationGetObjectListGistgetObjectListGistAsCsv(ctx context.Context) ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest {
	return ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MessageConversationGetObjectListGistGetObjectListGistAsCsv200Response
func (a *MessagingAPIService) MessageConversationGetObjectListGistgetObjectListGistAsCsvExecute(r ApiMessageConversationGetObjectListGistgetObjectListGistAsCsvRequest) (*MessageConversationGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MessageConversationGetObjectListGistGetObjectListGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationGetObjectListGistgetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/gist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationGetObjectPropertyRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	property     string
	uid          string
	fields       *[]string
	locale       *string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
	translate    *bool
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiMessageConversationGetObjectPropertyRequest) Fields(fields []string) ApiMessageConversationGetObjectPropertyRequest {
	r.fields = &fields
	return r
}

// [no description yet]
func (r ApiMessageConversationGetObjectPropertyRequest) Locale(locale string) ApiMessageConversationGetObjectPropertyRequest {
	r.locale = &locale
	return r
}

// Defines which page number to return.
func (r ApiMessageConversationGetObjectPropertyRequest) Page(page int32) ApiMessageConversationGetObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiMessageConversationGetObjectPropertyRequest) PageSize(pageSize int32) ApiMessageConversationGetObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiMessageConversationGetObjectPropertyRequest) Paging(paging bool) ApiMessageConversationGetObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiMessageConversationGetObjectPropertyRequest) RootJunction(rootJunction string) ApiMessageConversationGetObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiMessageConversationGetObjectPropertyRequest) Translate(translate bool) ApiMessageConversationGetObjectPropertyRequest {
	r.translate = &translate
	return r
}

func (r ApiMessageConversationGetObjectPropertyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MessageConversationGetObjectPropertyExecute(r)
}

/*
MessageConversationGetObjectProperty Method for MessageConversationGetObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiMessageConversationGetObjectPropertyRequest
*/
func (a *MessagingAPIService) MessageConversationGetObjectProperty(ctx context.Context, property string, uid string) ApiMessageConversationGetObjectPropertyRequest {
	return ApiMessageConversationGetObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MessagingAPIService) MessageConversationGetObjectPropertyExecute(r ApiMessageConversationGetObjectPropertyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationGetObjectProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationGetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiMessageConversationGetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiMessageConversationGetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiMessageConversationGetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiMessageConversationGetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiMessageConversationGetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiMessageConversationGetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiMessageConversationGetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiMessageConversationGetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiMessageConversationGetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiMessageConversationGetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiMessageConversationGetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiMessageConversationGetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiMessageConversationGetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiMessageConversationGetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiMessageConversationGetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiMessageConversationGetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiMessageConversationGetObjectPropertyGistAsCsvRequest) Order(order string) ApiMessageConversationGetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiMessageConversationGetObjectPropertyGistAsCsvRequest) Page(page int32) ApiMessageConversationGetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiMessageConversationGetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiMessageConversationGetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiMessageConversationGetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiMessageConversationGetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiMessageConversationGetObjectPropertyGistAsCsvRequest) References(references bool) ApiMessageConversationGetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiMessageConversationGetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiMessageConversationGetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiMessageConversationGetObjectPropertyGistAsCsvRequest) Total(total bool) ApiMessageConversationGetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiMessageConversationGetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiMessageConversationGetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiMessageConversationGetObjectPropertyGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.MessageConversationGetObjectPropertyGistAsCsvExecute(r)
}

/*
MessageConversationGetObjectPropertyGistAsCsv Method for MessageConversationGetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiMessageConversationGetObjectPropertyGistAsCsvRequest
*/
func (a *MessagingAPIService) MessageConversationGetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiMessageConversationGetObjectPropertyGistAsCsvRequest {
	return ApiMessageConversationGetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *MessagingAPIService) MessageConversationGetObjectPropertyGistAsCsvExecute(r ApiMessageConversationGetObjectPropertyGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationGetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}/{property}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Order(order string) ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Page(page int32) ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) References(references bool) ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Total(total bool) ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Execute() (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.MessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r)
}

/*
MessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsv Method for MessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest
*/
func (a *MessagingAPIService) MessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	return ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
func (a *MessagingAPIService) MessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r ApiMessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationGetObjectPropertyGistgetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}/{property}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationMarkMessageConversationFollowupRequest struct {
	ctx         context.Context
	ApiService  *MessagingAPIService
	requestBody *[]string
	user        *string
}

// [no description yet]
func (r ApiMessageConversationMarkMessageConversationFollowupRequest) RequestBody(requestBody []string) ApiMessageConversationMarkMessageConversationFollowupRequest {
	r.requestBody = &requestBody
	return r
}

// [no description yet]
func (r ApiMessageConversationMarkMessageConversationFollowupRequest) User(user string) ApiMessageConversationMarkMessageConversationFollowupRequest {
	r.user = &user
	return r
}

func (r ApiMessageConversationMarkMessageConversationFollowupRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MessageConversationMarkMessageConversationFollowupExecute(r)
}

/*
MessageConversationMarkMessageConversationFollowup Method for MessageConversationMarkMessageConversationFollowup

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMessageConversationMarkMessageConversationFollowupRequest
*/
func (a *MessagingAPIService) MessageConversationMarkMessageConversationFollowup(ctx context.Context) ApiMessageConversationMarkMessageConversationFollowupRequest {
	return ApiMessageConversationMarkMessageConversationFollowupRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MessagingAPIService) MessageConversationMarkMessageConversationFollowupExecute(r ApiMessageConversationMarkMessageConversationFollowupRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationMarkMessageConversationFollowup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/followup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationMarkMessageConversationReadRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
	userUid    *string
}

// [no description yet]
func (r ApiMessageConversationMarkMessageConversationReadRequest) UserUid(userUid string) ApiMessageConversationMarkMessageConversationReadRequest {
	r.userUid = &userUid
	return r
}

func (r ApiMessageConversationMarkMessageConversationReadRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MessageConversationMarkMessageConversationReadExecute(r)
}

/*
MessageConversationMarkMessageConversationRead Method for MessageConversationMarkMessageConversationRead

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiMessageConversationMarkMessageConversationReadRequest
*/
func (a *MessagingAPIService) MessageConversationMarkMessageConversationRead(ctx context.Context, uid string) ApiMessageConversationMarkMessageConversationReadRequest {
	return ApiMessageConversationMarkMessageConversationReadRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MessagingAPIService) MessageConversationMarkMessageConversationReadExecute(r ApiMessageConversationMarkMessageConversationReadRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationMarkMessageConversationRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}/read"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userUid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userUid", r.userUid, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationMarkMessageConversationUnreadRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
	userUid    *string
}

// [no description yet]
func (r ApiMessageConversationMarkMessageConversationUnreadRequest) UserUid(userUid string) ApiMessageConversationMarkMessageConversationUnreadRequest {
	r.userUid = &userUid
	return r
}

func (r ApiMessageConversationMarkMessageConversationUnreadRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MessageConversationMarkMessageConversationUnreadExecute(r)
}

/*
MessageConversationMarkMessageConversationUnread Method for MessageConversationMarkMessageConversationUnread

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiMessageConversationMarkMessageConversationUnreadRequest
*/
func (a *MessagingAPIService) MessageConversationMarkMessageConversationUnread(ctx context.Context, uid string) ApiMessageConversationMarkMessageConversationUnreadRequest {
	return ApiMessageConversationMarkMessageConversationUnreadRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MessagingAPIService) MessageConversationMarkMessageConversationUnreadExecute(r ApiMessageConversationMarkMessageConversationUnreadRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationMarkMessageConversationUnread")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}/unread"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userUid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userUid", r.userUid, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationMarkMessageConversationsReadRequest struct {
	ctx         context.Context
	ApiService  *MessagingAPIService
	requestBody *[]string
	user        *string
}

// [no description yet]
func (r ApiMessageConversationMarkMessageConversationsReadRequest) RequestBody(requestBody []string) ApiMessageConversationMarkMessageConversationsReadRequest {
	r.requestBody = &requestBody
	return r
}

// [no description yet]
func (r ApiMessageConversationMarkMessageConversationsReadRequest) User(user string) ApiMessageConversationMarkMessageConversationsReadRequest {
	r.user = &user
	return r
}

func (r ApiMessageConversationMarkMessageConversationsReadRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MessageConversationMarkMessageConversationsReadExecute(r)
}

/*
MessageConversationMarkMessageConversationsRead Method for MessageConversationMarkMessageConversationsRead

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMessageConversationMarkMessageConversationsReadRequest
*/
func (a *MessagingAPIService) MessageConversationMarkMessageConversationsRead(ctx context.Context) ApiMessageConversationMarkMessageConversationsReadRequest {
	return ApiMessageConversationMarkMessageConversationsReadRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MessagingAPIService) MessageConversationMarkMessageConversationsReadExecute(r ApiMessageConversationMarkMessageConversationsReadRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationMarkMessageConversationsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/read"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationMarkMessageConversationsUnreadRequest struct {
	ctx         context.Context
	ApiService  *MessagingAPIService
	requestBody *[]string
	user        *string
}

// [no description yet]
func (r ApiMessageConversationMarkMessageConversationsUnreadRequest) RequestBody(requestBody []string) ApiMessageConversationMarkMessageConversationsUnreadRequest {
	r.requestBody = &requestBody
	return r
}

// [no description yet]
func (r ApiMessageConversationMarkMessageConversationsUnreadRequest) User(user string) ApiMessageConversationMarkMessageConversationsUnreadRequest {
	r.user = &user
	return r
}

func (r ApiMessageConversationMarkMessageConversationsUnreadRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MessageConversationMarkMessageConversationsUnreadExecute(r)
}

/*
MessageConversationMarkMessageConversationsUnread Method for MessageConversationMarkMessageConversationsUnread

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMessageConversationMarkMessageConversationsUnreadRequest
*/
func (a *MessagingAPIService) MessageConversationMarkMessageConversationsUnread(ctx context.Context) ApiMessageConversationMarkMessageConversationsUnreadRequest {
	return ApiMessageConversationMarkMessageConversationsUnreadRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MessagingAPIService) MessageConversationMarkMessageConversationsUnreadExecute(r ApiMessageConversationMarkMessageConversationsUnreadRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationMarkMessageConversationsUnread")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/unread"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationPatchObjectRequest struct {
	ctx                context.Context
	ApiService         *MessagingAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	jsonPatch          *JsonPatch
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiMessageConversationPatchObjectRequest) AtomicMode(atomicMode string) ApiMessageConversationPatchObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiMessageConversationPatchObjectRequest) FlushMode(flushMode string) ApiMessageConversationPatchObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiMessageConversationPatchObjectRequest) Identifier(identifier string) ApiMessageConversationPatchObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiMessageConversationPatchObjectRequest) ImportMode(importMode string) ApiMessageConversationPatchObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiMessageConversationPatchObjectRequest) ImportReportMode(importReportMode string) ApiMessageConversationPatchObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiMessageConversationPatchObjectRequest) ImportStrategy(importStrategy string) ApiMessageConversationPatchObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiMessageConversationPatchObjectRequest) MergeMode(mergeMode string) ApiMessageConversationPatchObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiMessageConversationPatchObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiMessageConversationPatchObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiMessageConversationPatchObjectRequest) Page(page int32) ApiMessageConversationPatchObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiMessageConversationPatchObjectRequest) PageSize(pageSize int32) ApiMessageConversationPatchObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiMessageConversationPatchObjectRequest) Paging(paging bool) ApiMessageConversationPatchObjectRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiMessageConversationPatchObjectRequest) PreheatMode(preheatMode string) ApiMessageConversationPatchObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiMessageConversationPatchObjectRequest) RootJunction(rootJunction string) ApiMessageConversationPatchObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiMessageConversationPatchObjectRequest) SkipSharing(skipSharing bool) ApiMessageConversationPatchObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiMessageConversationPatchObjectRequest) SkipTranslation(skipTranslation bool) ApiMessageConversationPatchObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiMessageConversationPatchObjectRequest) SkipValidation(skipValidation bool) ApiMessageConversationPatchObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiMessageConversationPatchObjectRequest) UserOverrideMode(userOverrideMode string) ApiMessageConversationPatchObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiMessageConversationPatchObjectRequest) JsonPatch(jsonPatch JsonPatch) ApiMessageConversationPatchObjectRequest {
	r.jsonPatch = &jsonPatch
	return r
}

func (r ApiMessageConversationPatchObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.MessageConversationPatchObjectExecute(r)
}

/*
MessageConversationPatchObject Method for MessageConversationPatchObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiMessageConversationPatchObjectRequest
*/
func (a *MessagingAPIService) MessageConversationPatchObject(ctx context.Context, uid string) ApiMessageConversationPatchObjectRequest {
	return ApiMessageConversationPatchObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) MessageConversationPatchObjectExecute(r ApiMessageConversationPatchObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationPatchObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationPostJsonObjectpostXmlObjectRequest struct {
	ctx                 context.Context
	ApiService          *MessagingAPIService
	atomicMode          *string
	flushMode           *string
	identifier          *string
	importMode          *string
	importReportMode    *string
	importStrategy      *string
	mergeMode           *string
	metadataSyncImport  *bool
	preheatMode         *string
	skipSharing         *bool
	skipTranslation     *bool
	skipValidation      *bool
	userOverrideMode    *string
	messageConversation *MessageConversation
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiMessageConversationPostJsonObjectpostXmlObjectRequest) AtomicMode(atomicMode string) ApiMessageConversationPostJsonObjectpostXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiMessageConversationPostJsonObjectpostXmlObjectRequest) FlushMode(flushMode string) ApiMessageConversationPostJsonObjectpostXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiMessageConversationPostJsonObjectpostXmlObjectRequest) Identifier(identifier string) ApiMessageConversationPostJsonObjectpostXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiMessageConversationPostJsonObjectpostXmlObjectRequest) ImportMode(importMode string) ApiMessageConversationPostJsonObjectpostXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiMessageConversationPostJsonObjectpostXmlObjectRequest) ImportReportMode(importReportMode string) ApiMessageConversationPostJsonObjectpostXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiMessageConversationPostJsonObjectpostXmlObjectRequest) ImportStrategy(importStrategy string) ApiMessageConversationPostJsonObjectpostXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiMessageConversationPostJsonObjectpostXmlObjectRequest) MergeMode(mergeMode string) ApiMessageConversationPostJsonObjectpostXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiMessageConversationPostJsonObjectpostXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiMessageConversationPostJsonObjectpostXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiMessageConversationPostJsonObjectpostXmlObjectRequest) PreheatMode(preheatMode string) ApiMessageConversationPostJsonObjectpostXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiMessageConversationPostJsonObjectpostXmlObjectRequest) SkipSharing(skipSharing bool) ApiMessageConversationPostJsonObjectpostXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiMessageConversationPostJsonObjectpostXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiMessageConversationPostJsonObjectpostXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiMessageConversationPostJsonObjectpostXmlObjectRequest) SkipValidation(skipValidation bool) ApiMessageConversationPostJsonObjectpostXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiMessageConversationPostJsonObjectpostXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiMessageConversationPostJsonObjectpostXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiMessageConversationPostJsonObjectpostXmlObjectRequest) MessageConversation(messageConversation MessageConversation) ApiMessageConversationPostJsonObjectpostXmlObjectRequest {
	r.messageConversation = &messageConversation
	return r
}

func (r ApiMessageConversationPostJsonObjectpostXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.MessageConversationPostJsonObjectpostXmlObjectExecute(r)
}

/*
MessageConversationPostJsonObjectpostXmlObject Method for MessageConversationPostJsonObjectpostXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMessageConversationPostJsonObjectpostXmlObjectRequest
*/
func (a *MessagingAPIService) MessageConversationPostJsonObjectpostXmlObject(ctx context.Context) ApiMessageConversationPostJsonObjectpostXmlObjectRequest {
	return ApiMessageConversationPostJsonObjectpostXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) MessageConversationPostJsonObjectpostXmlObjectExecute(r ApiMessageConversationPostJsonObjectpostXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationPostJsonObjectpostXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.messageConversation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationPostMessageConversationFeedbackRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	subject    *string
	body       *string
}

// [no description yet]
func (r ApiMessageConversationPostMessageConversationFeedbackRequest) Subject(subject string) ApiMessageConversationPostMessageConversationFeedbackRequest {
	r.subject = &subject
	return r
}

// [no description yet]
func (r ApiMessageConversationPostMessageConversationFeedbackRequest) Body(body string) ApiMessageConversationPostMessageConversationFeedbackRequest {
	r.body = &body
	return r
}

func (r ApiMessageConversationPostMessageConversationFeedbackRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.MessageConversationPostMessageConversationFeedbackExecute(r)
}

/*
MessageConversationPostMessageConversationFeedback Method for MessageConversationPostMessageConversationFeedback

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMessageConversationPostMessageConversationFeedbackRequest
*/
func (a *MessagingAPIService) MessageConversationPostMessageConversationFeedback(ctx context.Context) ApiMessageConversationPostMessageConversationFeedbackRequest {
	return ApiMessageConversationPostMessageConversationFeedbackRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) MessageConversationPostMessageConversationFeedbackExecute(r ApiMessageConversationPostMessageConversationFeedbackRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationPostMessageConversationFeedback")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/feedback"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subject == nil {
		return localVarReturnValue, nil, reportError("subject is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "subject", r.subject, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationPostMessageConversationReplyRequest struct {
	ctx         context.Context
	ApiService  *MessagingAPIService
	uid         string
	body        *string
	attachments *[]string
	internal    *bool
}

// [no description yet]
func (r ApiMessageConversationPostMessageConversationReplyRequest) Body(body string) ApiMessageConversationPostMessageConversationReplyRequest {
	r.body = &body
	return r
}

// [no description yet]
func (r ApiMessageConversationPostMessageConversationReplyRequest) Attachments(attachments []string) ApiMessageConversationPostMessageConversationReplyRequest {
	r.attachments = &attachments
	return r
}

// [no description yet]
func (r ApiMessageConversationPostMessageConversationReplyRequest) Internal(internal bool) ApiMessageConversationPostMessageConversationReplyRequest {
	r.internal = &internal
	return r
}

func (r ApiMessageConversationPostMessageConversationReplyRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.MessageConversationPostMessageConversationReplyExecute(r)
}

/*
MessageConversationPostMessageConversationReply Method for MessageConversationPostMessageConversationReply

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiMessageConversationPostMessageConversationReplyRequest
*/
func (a *MessagingAPIService) MessageConversationPostMessageConversationReply(ctx context.Context, uid string) ApiMessageConversationPostMessageConversationReplyRequest {
	return ApiMessageConversationPostMessageConversationReplyRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) MessageConversationPostMessageConversationReplyExecute(r ApiMessageConversationPostMessageConversationReplyRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationPostMessageConversationReply")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.attachments != nil {
		t := *r.attachments
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attachments", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attachments", t, "multi")
		}
	}
	if r.internal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "internal", r.internal, "")
	} else {
		var defaultValue bool = false
		r.internal = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationPutJsonObjectputXmlObjectRequest struct {
	ctx                 context.Context
	ApiService          *MessagingAPIService
	uid                 string
	atomicMode          *string
	flushMode           *string
	identifier          *string
	importMode          *string
	importReportMode    *string
	importStrategy      *string
	mergeMode           *string
	metadataSyncImport  *bool
	preheatMode         *string
	skipSharing         *bool
	skipTranslation     *bool
	skipValidation      *bool
	userOverrideMode    *string
	messageConversation *MessageConversation
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiMessageConversationPutJsonObjectputXmlObjectRequest) AtomicMode(atomicMode string) ApiMessageConversationPutJsonObjectputXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiMessageConversationPutJsonObjectputXmlObjectRequest) FlushMode(flushMode string) ApiMessageConversationPutJsonObjectputXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiMessageConversationPutJsonObjectputXmlObjectRequest) Identifier(identifier string) ApiMessageConversationPutJsonObjectputXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiMessageConversationPutJsonObjectputXmlObjectRequest) ImportMode(importMode string) ApiMessageConversationPutJsonObjectputXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiMessageConversationPutJsonObjectputXmlObjectRequest) ImportReportMode(importReportMode string) ApiMessageConversationPutJsonObjectputXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiMessageConversationPutJsonObjectputXmlObjectRequest) ImportStrategy(importStrategy string) ApiMessageConversationPutJsonObjectputXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiMessageConversationPutJsonObjectputXmlObjectRequest) MergeMode(mergeMode string) ApiMessageConversationPutJsonObjectputXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiMessageConversationPutJsonObjectputXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiMessageConversationPutJsonObjectputXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiMessageConversationPutJsonObjectputXmlObjectRequest) PreheatMode(preheatMode string) ApiMessageConversationPutJsonObjectputXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiMessageConversationPutJsonObjectputXmlObjectRequest) SkipSharing(skipSharing bool) ApiMessageConversationPutJsonObjectputXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiMessageConversationPutJsonObjectputXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiMessageConversationPutJsonObjectputXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiMessageConversationPutJsonObjectputXmlObjectRequest) SkipValidation(skipValidation bool) ApiMessageConversationPutJsonObjectputXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiMessageConversationPutJsonObjectputXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiMessageConversationPutJsonObjectputXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiMessageConversationPutJsonObjectputXmlObjectRequest) MessageConversation(messageConversation MessageConversation) ApiMessageConversationPutJsonObjectputXmlObjectRequest {
	r.messageConversation = &messageConversation
	return r
}

func (r ApiMessageConversationPutJsonObjectputXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.MessageConversationPutJsonObjectputXmlObjectExecute(r)
}

/*
MessageConversationPutJsonObjectputXmlObject Method for MessageConversationPutJsonObjectputXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiMessageConversationPutJsonObjectputXmlObjectRequest
*/
func (a *MessagingAPIService) MessageConversationPutJsonObjectputXmlObject(ctx context.Context, uid string) ApiMessageConversationPutJsonObjectputXmlObjectRequest {
	return ApiMessageConversationPutJsonObjectputXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) MessageConversationPutJsonObjectputXmlObjectExecute(r ApiMessageConversationPutJsonObjectputXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationPutJsonObjectputXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.messageConversation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationRemoveAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
}

func (r ApiMessageConversationRemoveAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.MessageConversationRemoveAsFavoriteExecute(r)
}

/*
MessageConversationRemoveAsFavorite Method for MessageConversationRemoveAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiMessageConversationRemoveAsFavoriteRequest
*/
func (a *MessagingAPIService) MessageConversationRemoveAsFavorite(ctx context.Context, uid string) ApiMessageConversationRemoveAsFavoriteRequest {
	return ApiMessageConversationRemoveAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) MessageConversationRemoveAsFavoriteExecute(r ApiMessageConversationRemoveAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationRemoveAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationRemoveUserAssignedRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
}

func (r ApiMessageConversationRemoveUserAssignedRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MessageConversationRemoveUserAssignedExecute(r)
}

/*
MessageConversationRemoveUserAssigned Method for MessageConversationRemoveUserAssigned

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiMessageConversationRemoveUserAssignedRequest
*/
func (a *MessagingAPIService) MessageConversationRemoveUserAssigned(ctx context.Context, uid string) ApiMessageConversationRemoveUserAssignedRequest {
	return ApiMessageConversationRemoveUserAssignedRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MessagingAPIService) MessageConversationRemoveUserAssignedExecute(r ApiMessageConversationRemoveUserAssignedRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationRemoveUserAssigned")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}/assign"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationRemoveUserFromMessageConversationRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	mcUid      string
	userUid    string
}

func (r ApiMessageConversationRemoveUserFromMessageConversationRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MessageConversationRemoveUserFromMessageConversationExecute(r)
}

/*
MessageConversationRemoveUserFromMessageConversation Method for MessageConversationRemoveUserFromMessageConversation

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param mcUid [no description yet]
	@param userUid [no description yet]
	@return ApiMessageConversationRemoveUserFromMessageConversationRequest
*/
func (a *MessagingAPIService) MessageConversationRemoveUserFromMessageConversation(ctx context.Context, mcUid string, userUid string) ApiMessageConversationRemoveUserFromMessageConversationRequest {
	return ApiMessageConversationRemoveUserFromMessageConversationRequest{
		ApiService: a,
		ctx:        ctx,
		mcUid:      mcUid,
		userUid:    userUid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MessagingAPIService) MessageConversationRemoveUserFromMessageConversationExecute(r ApiMessageConversationRemoveUserFromMessageConversationRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationRemoveUserFromMessageConversation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{mc-uid}/{user-uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"mc-uid"+"}", url.PathEscape(parameterValueToString(r.mcUid, "mcUid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user-uid"+"}", url.PathEscape(parameterValueToString(r.userUid, "userUid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationRemoveUserFromMessageConversationsRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	mc         *[]string
	user       *string
}

// [no description yet]
func (r ApiMessageConversationRemoveUserFromMessageConversationsRequest) Mc(mc []string) ApiMessageConversationRemoveUserFromMessageConversationsRequest {
	r.mc = &mc
	return r
}

// [no description yet]
func (r ApiMessageConversationRemoveUserFromMessageConversationsRequest) User(user string) ApiMessageConversationRemoveUserFromMessageConversationsRequest {
	r.user = &user
	return r
}

func (r ApiMessageConversationRemoveUserFromMessageConversationsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MessageConversationRemoveUserFromMessageConversationsExecute(r)
}

/*
MessageConversationRemoveUserFromMessageConversations Method for MessageConversationRemoveUserFromMessageConversations

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMessageConversationRemoveUserFromMessageConversationsRequest
*/
func (a *MessagingAPIService) MessageConversationRemoveUserFromMessageConversations(ctx context.Context) ApiMessageConversationRemoveUserFromMessageConversationsRequest {
	return ApiMessageConversationRemoveUserFromMessageConversationsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MessagingAPIService) MessageConversationRemoveUserFromMessageConversationsExecute(r ApiMessageConversationRemoveUserFromMessageConversationsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationRemoveUserFromMessageConversations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mc == nil {
		return localVarReturnValue, nil, reportError("mc is required and must be specified")
	}

	{
		t := *r.mc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mc", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mc", t, "multi")
		}
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *MessagingAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiMessageConversationReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiMessageConversationReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiMessageConversationReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.MessageConversationReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r)
}

/*
MessageConversationReplaceCollectionItemsJsonreplaceCollectionItemsXml Method for MessageConversationReplaceCollectionItemsJsonreplaceCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiMessageConversationReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest
*/
func (a *MessagingAPIService) MessageConversationReplaceCollectionItemsJsonreplaceCollectionItemsXml(ctx context.Context, property string, uid string) ApiMessageConversationReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	return ApiMessageConversationReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) MessageConversationReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r ApiMessageConversationReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationReplaceCollectionItemsJsonreplaceCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationReplaceTranslationsRequest struct {
	ctx                                             context.Context
	ApiService                                      *MessagingAPIService
	uid                                             string
	aggregateDataExchangeReplaceTranslationsRequest *AggregateDataExchangeReplaceTranslationsRequest
}

// [no description yet]
func (r ApiMessageConversationReplaceTranslationsRequest) AggregateDataExchangeReplaceTranslationsRequest(aggregateDataExchangeReplaceTranslationsRequest AggregateDataExchangeReplaceTranslationsRequest) ApiMessageConversationReplaceTranslationsRequest {
	r.aggregateDataExchangeReplaceTranslationsRequest = &aggregateDataExchangeReplaceTranslationsRequest
	return r
}

func (r ApiMessageConversationReplaceTranslationsRequest) Execute() (*http.Response, error) {
	return r.ApiService.MessageConversationReplaceTranslationsExecute(r)
}

/*
MessageConversationReplaceTranslations Method for MessageConversationReplaceTranslations

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiMessageConversationReplaceTranslationsRequest
*/
func (a *MessagingAPIService) MessageConversationReplaceTranslations(ctx context.Context, uid string) ApiMessageConversationReplaceTranslationsRequest {
	return ApiMessageConversationReplaceTranslationsRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *MessagingAPIService) MessageConversationReplaceTranslationsExecute(r ApiMessageConversationReplaceTranslationsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationReplaceTranslations")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateDataExchangeReplaceTranslationsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMessageConversationSetAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
}

func (r ApiMessageConversationSetAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.MessageConversationSetAsFavoriteExecute(r)
}

/*
MessageConversationSetAsFavorite Method for MessageConversationSetAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiMessageConversationSetAsFavoriteRequest
*/
func (a *MessagingAPIService) MessageConversationSetAsFavorite(ctx context.Context, uid string) ApiMessageConversationSetAsFavoriteRequest {
	return ApiMessageConversationSetAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) MessageConversationSetAsFavoriteExecute(r ApiMessageConversationSetAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationSetAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationSetMessagePriorityRequest struct {
	ctx                         context.Context
	ApiService                  *MessagingAPIService
	messageConversationPriority *string
	uid                         string
}

// [no description yet]
func (r ApiMessageConversationSetMessagePriorityRequest) MessageConversationPriority(messageConversationPriority string) ApiMessageConversationSetMessagePriorityRequest {
	r.messageConversationPriority = &messageConversationPriority
	return r
}

func (r ApiMessageConversationSetMessagePriorityRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MessageConversationSetMessagePriorityExecute(r)
}

/*
MessageConversationSetMessagePriority Method for MessageConversationSetMessagePriority

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiMessageConversationSetMessagePriorityRequest
*/
func (a *MessagingAPIService) MessageConversationSetMessagePriority(ctx context.Context, uid string) ApiMessageConversationSetMessagePriorityRequest {
	return ApiMessageConversationSetMessagePriorityRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MessagingAPIService) MessageConversationSetMessagePriorityExecute(r ApiMessageConversationSetMessagePriorityRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationSetMessagePriority")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}/priority"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.messageConversationPriority == nil {
		return localVarReturnValue, nil, reportError("messageConversationPriority is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "messageConversationPriority", r.messageConversationPriority, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationSetMessageStatusRequest struct {
	ctx                       context.Context
	ApiService                *MessagingAPIService
	messageConversationStatus *string
	uid                       string
}

// [no description yet]
func (r ApiMessageConversationSetMessageStatusRequest) MessageConversationStatus(messageConversationStatus string) ApiMessageConversationSetMessageStatusRequest {
	r.messageConversationStatus = &messageConversationStatus
	return r
}

func (r ApiMessageConversationSetMessageStatusRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MessageConversationSetMessageStatusExecute(r)
}

/*
MessageConversationSetMessageStatus Method for MessageConversationSetMessageStatus

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiMessageConversationSetMessageStatusRequest
*/
func (a *MessagingAPIService) MessageConversationSetMessageStatus(ctx context.Context, uid string) ApiMessageConversationSetMessageStatusRequest {
	return ApiMessageConversationSetMessageStatusRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MessagingAPIService) MessageConversationSetMessageStatusExecute(r ApiMessageConversationSetMessageStatusRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationSetMessageStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.messageConversationStatus == nil {
		return localVarReturnValue, nil, reportError("messageConversationStatus is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "messageConversationStatus", r.messageConversationStatus, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationSetSharingRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
	sharing    *Sharing
}

// [no description yet]
func (r ApiMessageConversationSetSharingRequest) Sharing(sharing Sharing) ApiMessageConversationSetSharingRequest {
	r.sharing = &sharing
	return r
}

func (r ApiMessageConversationSetSharingRequest) Execute() (*http.Response, error) {
	return r.ApiService.MessageConversationSetSharingExecute(r)
}

/*
MessageConversationSetSharing Method for MessageConversationSetSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiMessageConversationSetSharingRequest
*/
func (a *MessagingAPIService) MessageConversationSetSharing(ctx context.Context, uid string) ApiMessageConversationSetSharingRequest {
	return ApiMessageConversationSetSharingRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *MessagingAPIService) MessageConversationSetSharingExecute(r ApiMessageConversationSetSharingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationSetSharing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}/sharing"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharing
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMessageConversationSetUserAssignedRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
	userId     *string
}

// [no description yet]
func (r ApiMessageConversationSetUserAssignedRequest) UserId(userId string) ApiMessageConversationSetUserAssignedRequest {
	r.userId = &userId
	return r
}

func (r ApiMessageConversationSetUserAssignedRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MessageConversationSetUserAssignedExecute(r)
}

/*
MessageConversationSetUserAssigned Method for MessageConversationSetUserAssigned

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiMessageConversationSetUserAssignedRequest
*/
func (a *MessagingAPIService) MessageConversationSetUserAssigned(ctx context.Context, uid string) ApiMessageConversationSetUserAssignedRequest {
	return ApiMessageConversationSetUserAssignedRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MessagingAPIService) MessageConversationSetUserAssignedExecute(r ApiMessageConversationSetUserAssignedRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationSetUserAssigned")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}/assign"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationSubscribeRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
}

func (r ApiMessageConversationSubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.MessageConversationSubscribeExecute(r)
}

/*
MessageConversationSubscribe Method for MessageConversationSubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiMessageConversationSubscribeRequest
*/
func (a *MessagingAPIService) MessageConversationSubscribe(ctx context.Context, uid string) ApiMessageConversationSubscribeRequest {
	return ApiMessageConversationSubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) MessageConversationSubscribeExecute(r ApiMessageConversationSubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationSubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationUnmarkMessageConversationFollowupRequest struct {
	ctx         context.Context
	ApiService  *MessagingAPIService
	requestBody *[]string
	user        *string
}

// [no description yet]
func (r ApiMessageConversationUnmarkMessageConversationFollowupRequest) RequestBody(requestBody []string) ApiMessageConversationUnmarkMessageConversationFollowupRequest {
	r.requestBody = &requestBody
	return r
}

// [no description yet]
func (r ApiMessageConversationUnmarkMessageConversationFollowupRequest) User(user string) ApiMessageConversationUnmarkMessageConversationFollowupRequest {
	r.user = &user
	return r
}

func (r ApiMessageConversationUnmarkMessageConversationFollowupRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MessageConversationUnmarkMessageConversationFollowupExecute(r)
}

/*
MessageConversationUnmarkMessageConversationFollowup Method for MessageConversationUnmarkMessageConversationFollowup

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMessageConversationUnmarkMessageConversationFollowupRequest
*/
func (a *MessagingAPIService) MessageConversationUnmarkMessageConversationFollowup(ctx context.Context) ApiMessageConversationUnmarkMessageConversationFollowupRequest {
	return ApiMessageConversationUnmarkMessageConversationFollowupRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MessagingAPIService) MessageConversationUnmarkMessageConversationFollowupExecute(r ApiMessageConversationUnmarkMessageConversationFollowupRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationUnmarkMessageConversationFollowup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/unfollowup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationUnsubscribeRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
}

func (r ApiMessageConversationUnsubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.MessageConversationUnsubscribeExecute(r)
}

/*
MessageConversationUnsubscribe Method for MessageConversationUnsubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiMessageConversationUnsubscribeRequest
*/
func (a *MessagingAPIService) MessageConversationUnsubscribe(ctx context.Context, uid string) ApiMessageConversationUnsubscribeRequest {
	return ApiMessageConversationUnsubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) MessageConversationUnsubscribeExecute(r ApiMessageConversationUnsubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationUnsubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMessageConversationUpdateObjectPropertyRequest struct {
	ctx                 context.Context
	ApiService          *MessagingAPIService
	property            string
	uid                 string
	atomicMode          *string
	flushMode           *string
	identifier          *string
	importMode          *string
	importReportMode    *string
	importStrategy      *string
	mergeMode           *string
	metadataSyncImport  *bool
	page                *int32
	pageSize            *int32
	paging              *bool
	preheatMode         *string
	rootJunction        *string
	skipSharing         *bool
	skipTranslation     *bool
	skipValidation      *bool
	userOverrideMode    *string
	messageConversation *MessageConversation
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiMessageConversationUpdateObjectPropertyRequest) AtomicMode(atomicMode string) ApiMessageConversationUpdateObjectPropertyRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiMessageConversationUpdateObjectPropertyRequest) FlushMode(flushMode string) ApiMessageConversationUpdateObjectPropertyRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiMessageConversationUpdateObjectPropertyRequest) Identifier(identifier string) ApiMessageConversationUpdateObjectPropertyRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiMessageConversationUpdateObjectPropertyRequest) ImportMode(importMode string) ApiMessageConversationUpdateObjectPropertyRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiMessageConversationUpdateObjectPropertyRequest) ImportReportMode(importReportMode string) ApiMessageConversationUpdateObjectPropertyRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiMessageConversationUpdateObjectPropertyRequest) ImportStrategy(importStrategy string) ApiMessageConversationUpdateObjectPropertyRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiMessageConversationUpdateObjectPropertyRequest) MergeMode(mergeMode string) ApiMessageConversationUpdateObjectPropertyRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiMessageConversationUpdateObjectPropertyRequest) MetadataSyncImport(metadataSyncImport bool) ApiMessageConversationUpdateObjectPropertyRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiMessageConversationUpdateObjectPropertyRequest) Page(page int32) ApiMessageConversationUpdateObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiMessageConversationUpdateObjectPropertyRequest) PageSize(pageSize int32) ApiMessageConversationUpdateObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiMessageConversationUpdateObjectPropertyRequest) Paging(paging bool) ApiMessageConversationUpdateObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiMessageConversationUpdateObjectPropertyRequest) PreheatMode(preheatMode string) ApiMessageConversationUpdateObjectPropertyRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiMessageConversationUpdateObjectPropertyRequest) RootJunction(rootJunction string) ApiMessageConversationUpdateObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiMessageConversationUpdateObjectPropertyRequest) SkipSharing(skipSharing bool) ApiMessageConversationUpdateObjectPropertyRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiMessageConversationUpdateObjectPropertyRequest) SkipTranslation(skipTranslation bool) ApiMessageConversationUpdateObjectPropertyRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiMessageConversationUpdateObjectPropertyRequest) SkipValidation(skipValidation bool) ApiMessageConversationUpdateObjectPropertyRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiMessageConversationUpdateObjectPropertyRequest) UserOverrideMode(userOverrideMode string) ApiMessageConversationUpdateObjectPropertyRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiMessageConversationUpdateObjectPropertyRequest) MessageConversation(messageConversation MessageConversation) ApiMessageConversationUpdateObjectPropertyRequest {
	r.messageConversation = &messageConversation
	return r
}

func (r ApiMessageConversationUpdateObjectPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.MessageConversationUpdateObjectPropertyExecute(r)
}

/*
MessageConversationUpdateObjectProperty Method for MessageConversationUpdateObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiMessageConversationUpdateObjectPropertyRequest
*/
func (a *MessagingAPIService) MessageConversationUpdateObjectProperty(ctx context.Context, property string, uid string) ApiMessageConversationUpdateObjectPropertyRequest {
	return ApiMessageConversationUpdateObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
func (a *MessagingAPIService) MessageConversationUpdateObjectPropertyExecute(r ApiMessageConversationUpdateObjectPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.MessageConversationUpdateObjectProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messageConversations/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.messageConversation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSmsCommandAddCollectionItemRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiSmsCommandAddCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsCommandAddCollectionItemExecute(r)
}

/*
SmsCommandAddCollectionItem Method for SmsCommandAddCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsCommandAddCollectionItemRequest
*/
func (a *MessagingAPIService) SmsCommandAddCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiSmsCommandAddCollectionItemRequest {
	return ApiSmsCommandAddCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsCommandAddCollectionItemExecute(r ApiSmsCommandAddCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandAddCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsCommandAddCollectionItemsJsonaddCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *MessagingAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiSmsCommandAddCollectionItemsJsonaddCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiSmsCommandAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiSmsCommandAddCollectionItemsJsonaddCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsCommandAddCollectionItemsJsonaddCollectionItemsXmlExecute(r)
}

/*
SmsCommandAddCollectionItemsJsonaddCollectionItemsXml Method for SmsCommandAddCollectionItemsJsonaddCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsCommandAddCollectionItemsJsonaddCollectionItemsXmlRequest
*/
func (a *MessagingAPIService) SmsCommandAddCollectionItemsJsonaddCollectionItemsXml(ctx context.Context, property string, uid string) ApiSmsCommandAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	return ApiSmsCommandAddCollectionItemsJsonaddCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsCommandAddCollectionItemsJsonaddCollectionItemsXmlExecute(r ApiSmsCommandAddCollectionItemsJsonaddCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandAddCollectionItemsJsonaddCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsCommandBulkSharingRequest struct {
	ctx                context.Context
	ApiService         *MessagingAPIService
	atomic             *bool
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	bulkJsonPatch      *BulkJsonPatch
}

// [no description yet]
func (r ApiSmsCommandBulkSharingRequest) Atomic(atomic bool) ApiSmsCommandBulkSharingRequest {
	r.atomic = &atomic
	return r
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiSmsCommandBulkSharingRequest) AtomicMode(atomicMode string) ApiSmsCommandBulkSharingRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiSmsCommandBulkSharingRequest) FlushMode(flushMode string) ApiSmsCommandBulkSharingRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiSmsCommandBulkSharingRequest) Identifier(identifier string) ApiSmsCommandBulkSharingRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiSmsCommandBulkSharingRequest) ImportMode(importMode string) ApiSmsCommandBulkSharingRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiSmsCommandBulkSharingRequest) ImportReportMode(importReportMode string) ApiSmsCommandBulkSharingRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiSmsCommandBulkSharingRequest) ImportStrategy(importStrategy string) ApiSmsCommandBulkSharingRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiSmsCommandBulkSharingRequest) MergeMode(mergeMode string) ApiSmsCommandBulkSharingRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiSmsCommandBulkSharingRequest) MetadataSyncImport(metadataSyncImport bool) ApiSmsCommandBulkSharingRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiSmsCommandBulkSharingRequest) Page(page int32) ApiSmsCommandBulkSharingRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiSmsCommandBulkSharingRequest) PageSize(pageSize int32) ApiSmsCommandBulkSharingRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiSmsCommandBulkSharingRequest) Paging(paging bool) ApiSmsCommandBulkSharingRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiSmsCommandBulkSharingRequest) PreheatMode(preheatMode string) ApiSmsCommandBulkSharingRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiSmsCommandBulkSharingRequest) RootJunction(rootJunction string) ApiSmsCommandBulkSharingRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiSmsCommandBulkSharingRequest) SkipSharing(skipSharing bool) ApiSmsCommandBulkSharingRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiSmsCommandBulkSharingRequest) SkipTranslation(skipTranslation bool) ApiSmsCommandBulkSharingRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiSmsCommandBulkSharingRequest) SkipValidation(skipValidation bool) ApiSmsCommandBulkSharingRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiSmsCommandBulkSharingRequest) UserOverrideMode(userOverrideMode string) ApiSmsCommandBulkSharingRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiSmsCommandBulkSharingRequest) BulkJsonPatch(bulkJsonPatch BulkJsonPatch) ApiSmsCommandBulkSharingRequest {
	r.bulkJsonPatch = &bulkJsonPatch
	return r
}

func (r ApiSmsCommandBulkSharingRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsCommandBulkSharingExecute(r)
}

/*
SmsCommandBulkSharing Method for SmsCommandBulkSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsCommandBulkSharingRequest
*/
func (a *MessagingAPIService) SmsCommandBulkSharing(ctx context.Context) ApiSmsCommandBulkSharingRequest {
	return ApiSmsCommandBulkSharingRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsCommandBulkSharingExecute(r ApiSmsCommandBulkSharingRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandBulkSharing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/sharing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomic", r.atomic, "")
	} else {
		var defaultValue bool = false
		r.atomic = &defaultValue
	}
	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkJsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsCommandDeleteCollectionItemRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiSmsCommandDeleteCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsCommandDeleteCollectionItemExecute(r)
}

/*
SmsCommandDeleteCollectionItem Method for SmsCommandDeleteCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsCommandDeleteCollectionItemRequest
*/
func (a *MessagingAPIService) SmsCommandDeleteCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiSmsCommandDeleteCollectionItemRequest {
	return ApiSmsCommandDeleteCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsCommandDeleteCollectionItemExecute(r ApiSmsCommandDeleteCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandDeleteCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsCommandDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *MessagingAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiSmsCommandDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiSmsCommandDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiSmsCommandDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsCommandDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r)
}

/*
SmsCommandDeleteCollectionItemsJsondeleteCollectionItemsXml Method for SmsCommandDeleteCollectionItemsJsondeleteCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsCommandDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest
*/
func (a *MessagingAPIService) SmsCommandDeleteCollectionItemsJsondeleteCollectionItemsXml(ctx context.Context, property string, uid string) ApiSmsCommandDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	return ApiSmsCommandDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsCommandDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r ApiSmsCommandDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandDeleteCollectionItemsJsondeleteCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsCommandDeleteObjectRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
}

func (r ApiSmsCommandDeleteObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsCommandDeleteObjectExecute(r)
}

/*
SmsCommandDeleteObject Method for SmsCommandDeleteObject

Deletes the SMSCommand provided by ID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsCommandDeleteObjectRequest
*/
func (a *MessagingAPIService) SmsCommandDeleteObject(ctx context.Context, uid string) ApiSmsCommandDeleteObjectRequest {
	return ApiSmsCommandDeleteObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsCommandDeleteObjectExecute(r ApiSmsCommandDeleteObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandDeleteObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsCommandGetObjectRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	uid          string
	fields       *[]string
	filter       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiSmsCommandGetObjectRequest) Fields(fields []string) ApiSmsCommandGetObjectRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiSmsCommandGetObjectRequest) Filter(filter []string) ApiSmsCommandGetObjectRequest {
	r.filter = &filter
	return r
}

// Defines which page number to return.
func (r ApiSmsCommandGetObjectRequest) Page(page int32) ApiSmsCommandGetObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiSmsCommandGetObjectRequest) PageSize(pageSize int32) ApiSmsCommandGetObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiSmsCommandGetObjectRequest) Paging(paging bool) ApiSmsCommandGetObjectRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiSmsCommandGetObjectRequest) RootJunction(rootJunction string) ApiSmsCommandGetObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiSmsCommandGetObjectRequest) Execute() (*SMSCommand, *http.Response, error) {
	return r.ApiService.SmsCommandGetObjectExecute(r)
}

/*
SmsCommandGetObject Method for SmsCommandGetObject

View a SMSCommand

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsCommandGetObjectRequest
*/
func (a *MessagingAPIService) SmsCommandGetObject(ctx context.Context, uid string) ApiSmsCommandGetObjectRequest {
	return ApiSmsCommandGetObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return SMSCommand
func (a *MessagingAPIService) SmsCommandGetObjectExecute(r ApiSmsCommandGetObjectRequest) (*SMSCommand, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SMSCommand
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandGetObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsCommandGetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiSmsCommandGetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiSmsCommandGetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiSmsCommandGetObjectGistAsCsvRequest) Auto(auto string) ApiSmsCommandGetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiSmsCommandGetObjectGistAsCsvRequest) Describe(describe bool) ApiSmsCommandGetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiSmsCommandGetObjectGistAsCsvRequest) Fields(fields string) ApiSmsCommandGetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiSmsCommandGetObjectGistAsCsvRequest) Filter(filter string) ApiSmsCommandGetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiSmsCommandGetObjectGistAsCsvRequest) Headless(headless bool) ApiSmsCommandGetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiSmsCommandGetObjectGistAsCsvRequest) Inverse(inverse bool) ApiSmsCommandGetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiSmsCommandGetObjectGistAsCsvRequest) Locale(locale string) ApiSmsCommandGetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiSmsCommandGetObjectGistAsCsvRequest) Order(order string) ApiSmsCommandGetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiSmsCommandGetObjectGistAsCsvRequest) Page(page int32) ApiSmsCommandGetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiSmsCommandGetObjectGistAsCsvRequest) PageListName(pageListName string) ApiSmsCommandGetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiSmsCommandGetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiSmsCommandGetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiSmsCommandGetObjectGistAsCsvRequest) References(references bool) ApiSmsCommandGetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiSmsCommandGetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiSmsCommandGetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiSmsCommandGetObjectGistAsCsvRequest) Total(total bool) ApiSmsCommandGetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiSmsCommandGetObjectGistAsCsvRequest) Translate(translate bool) ApiSmsCommandGetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiSmsCommandGetObjectGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.SmsCommandGetObjectGistAsCsvExecute(r)
}

/*
SmsCommandGetObjectGistAsCsv Method for SmsCommandGetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsCommandGetObjectGistAsCsvRequest
*/
func (a *MessagingAPIService) SmsCommandGetObjectGistAsCsv(ctx context.Context, uid string) ApiSmsCommandGetObjectGistAsCsvRequest {
	return ApiSmsCommandGetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *MessagingAPIService) SmsCommandGetObjectGistAsCsvExecute(r ApiSmsCommandGetObjectGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandGetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/{uid}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest) Auto(auto string) ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest) Describe(describe bool) ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest) Fields(fields string) ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest) Filter(filter string) ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest) Headless(headless bool) ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest) Inverse(inverse bool) ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest) Locale(locale string) ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest) Order(order string) ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest) Page(page int32) ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest) PageListName(pageListName string) ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest) References(references bool) ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest) Total(total bool) ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest) Translate(translate bool) ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SmsCommandGetObjectGistgetObjectGistAsCsvExecute(r)
}

/*
SmsCommandGetObjectGistgetObjectGistAsCsv Method for SmsCommandGetObjectGistgetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest
*/
func (a *MessagingAPIService) SmsCommandGetObjectGistgetObjectGistAsCsv(ctx context.Context, uid string) ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest {
	return ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MessagingAPIService) SmsCommandGetObjectGistgetObjectGistAsCsvExecute(r ApiSmsCommandGetObjectGistgetObjectGistAsCsvRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandGetObjectGistgetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/{uid}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsCommandGetObjectListRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	fields       *[]string
	filter       *[]string
	orders       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// &#x60;&lt;field-name&gt;[,&lt;field-name&gt;...]&#x60;
func (r ApiSmsCommandGetObjectListRequest) Fields(fields []string) ApiSmsCommandGetObjectListRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiSmsCommandGetObjectListRequest) Filter(filter []string) ApiSmsCommandGetObjectListRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiSmsCommandGetObjectListRequest) Orders(orders []string) ApiSmsCommandGetObjectListRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiSmsCommandGetObjectListRequest) Page(page int32) ApiSmsCommandGetObjectListRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiSmsCommandGetObjectListRequest) PageSize(pageSize int32) ApiSmsCommandGetObjectListRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiSmsCommandGetObjectListRequest) Paging(paging bool) ApiSmsCommandGetObjectListRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiSmsCommandGetObjectListRequest) RootJunction(rootJunction string) ApiSmsCommandGetObjectListRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiSmsCommandGetObjectListRequest) Execute() (*SmsCommandGetObjectList200Response, *http.Response, error) {
	return r.ApiService.SmsCommandGetObjectListExecute(r)
}

/*
SmsCommandGetObjectList Method for SmsCommandGetObjectList

List all SMSCommands

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsCommandGetObjectListRequest
*/
func (a *MessagingAPIService) SmsCommandGetObjectList(ctx context.Context) ApiSmsCommandGetObjectListRequest {
	return ApiSmsCommandGetObjectListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SmsCommandGetObjectList200Response
func (a *MessagingAPIService) SmsCommandGetObjectListExecute(r ApiSmsCommandGetObjectListRequest) (*SmsCommandGetObjectList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SmsCommandGetObjectList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandGetObjectList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsCommandGetObjectListCsvRequest struct {
	ctx            context.Context
	ApiService     *MessagingAPIService
	arraySeparator *string
	fields         *[]string
	filter         *[]string
	orders         *[]string
	page           *int32
	pageSize       *int32
	paging         *bool
	rootJunction   *string
	separator      *string
	skipHeader     *bool
}

// [no description yet]
func (r ApiSmsCommandGetObjectListCsvRequest) ArraySeparator(arraySeparator string) ApiSmsCommandGetObjectListCsvRequest {
	r.arraySeparator = &arraySeparator
	return r
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiSmsCommandGetObjectListCsvRequest) Fields(fields []string) ApiSmsCommandGetObjectListCsvRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiSmsCommandGetObjectListCsvRequest) Filter(filter []string) ApiSmsCommandGetObjectListCsvRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiSmsCommandGetObjectListCsvRequest) Orders(orders []string) ApiSmsCommandGetObjectListCsvRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiSmsCommandGetObjectListCsvRequest) Page(page int32) ApiSmsCommandGetObjectListCsvRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiSmsCommandGetObjectListCsvRequest) PageSize(pageSize int32) ApiSmsCommandGetObjectListCsvRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiSmsCommandGetObjectListCsvRequest) Paging(paging bool) ApiSmsCommandGetObjectListCsvRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiSmsCommandGetObjectListCsvRequest) RootJunction(rootJunction string) ApiSmsCommandGetObjectListCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiSmsCommandGetObjectListCsvRequest) Separator(separator string) ApiSmsCommandGetObjectListCsvRequest {
	r.separator = &separator
	return r
}

// [no description yet]
func (r ApiSmsCommandGetObjectListCsvRequest) SkipHeader(skipHeader bool) ApiSmsCommandGetObjectListCsvRequest {
	r.skipHeader = &skipHeader
	return r
}

func (r ApiSmsCommandGetObjectListCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.SmsCommandGetObjectListCsvExecute(r)
}

/*
SmsCommandGetObjectListCsv Method for SmsCommandGetObjectListCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsCommandGetObjectListCsvRequest
*/
func (a *MessagingAPIService) SmsCommandGetObjectListCsv(ctx context.Context) ApiSmsCommandGetObjectListCsvRequest {
	return ApiSmsCommandGetObjectListCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *MessagingAPIService) SmsCommandGetObjectListCsvExecute(r ApiSmsCommandGetObjectListCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandGetObjectListCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/#getObjectListCsv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.arraySeparator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arraySeparator", r.arraySeparator, "")
	} else {
		var defaultValue string = ";"
		r.arraySeparator = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.separator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "separator", r.separator, "")
	} else {
		var defaultValue string = ","
		r.separator = &defaultValue
	}
	if r.skipHeader != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipHeader", r.skipHeader, "")
	} else {
		var defaultValue bool = false
		r.skipHeader = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/text", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsCommandGetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiSmsCommandGetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiSmsCommandGetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiSmsCommandGetObjectListGistAsCsvRequest) Auto(auto string) ApiSmsCommandGetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiSmsCommandGetObjectListGistAsCsvRequest) Describe(describe bool) ApiSmsCommandGetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiSmsCommandGetObjectListGistAsCsvRequest) Fields(fields string) ApiSmsCommandGetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiSmsCommandGetObjectListGistAsCsvRequest) Filter(filter string) ApiSmsCommandGetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiSmsCommandGetObjectListGistAsCsvRequest) Headless(headless bool) ApiSmsCommandGetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiSmsCommandGetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiSmsCommandGetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiSmsCommandGetObjectListGistAsCsvRequest) Locale(locale string) ApiSmsCommandGetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiSmsCommandGetObjectListGistAsCsvRequest) Order(order string) ApiSmsCommandGetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiSmsCommandGetObjectListGistAsCsvRequest) Page(page int32) ApiSmsCommandGetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiSmsCommandGetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiSmsCommandGetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiSmsCommandGetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiSmsCommandGetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiSmsCommandGetObjectListGistAsCsvRequest) References(references bool) ApiSmsCommandGetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiSmsCommandGetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiSmsCommandGetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiSmsCommandGetObjectListGistAsCsvRequest) Total(total bool) ApiSmsCommandGetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiSmsCommandGetObjectListGistAsCsvRequest) Translate(translate bool) ApiSmsCommandGetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiSmsCommandGetObjectListGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.SmsCommandGetObjectListGistAsCsvExecute(r)
}

/*
SmsCommandGetObjectListGistAsCsv Method for SmsCommandGetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsCommandGetObjectListGistAsCsvRequest
*/
func (a *MessagingAPIService) SmsCommandGetObjectListGistAsCsv(ctx context.Context) ApiSmsCommandGetObjectListGistAsCsvRequest {
	return ApiSmsCommandGetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *MessagingAPIService) SmsCommandGetObjectListGistAsCsvExecute(r ApiSmsCommandGetObjectListGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandGetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/gist.csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest) Auto(auto string) ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest) Describe(describe bool) ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest) Fields(fields string) ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest) Filter(filter string) ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest) Headless(headless bool) ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest) Locale(locale string) ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest) Order(order string) ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest) Page(page int32) ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest) References(references bool) ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest) Total(total bool) ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest) Translate(translate bool) ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest) Execute() (*SmsCommandGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.SmsCommandGetObjectListGistgetObjectListGistAsCsvExecute(r)
}

/*
SmsCommandGetObjectListGistgetObjectListGistAsCsv Method for SmsCommandGetObjectListGistgetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest
*/
func (a *MessagingAPIService) SmsCommandGetObjectListGistgetObjectListGistAsCsv(ctx context.Context) ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest {
	return ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SmsCommandGetObjectListGistGetObjectListGistAsCsv200Response
func (a *MessagingAPIService) SmsCommandGetObjectListGistgetObjectListGistAsCsvExecute(r ApiSmsCommandGetObjectListGistgetObjectListGistAsCsvRequest) (*SmsCommandGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SmsCommandGetObjectListGistGetObjectListGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandGetObjectListGistgetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/gist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsCommandGetObjectPropertyRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	property     string
	uid          string
	fields       *[]string
	locale       *string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
	translate    *bool
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiSmsCommandGetObjectPropertyRequest) Fields(fields []string) ApiSmsCommandGetObjectPropertyRequest {
	r.fields = &fields
	return r
}

// [no description yet]
func (r ApiSmsCommandGetObjectPropertyRequest) Locale(locale string) ApiSmsCommandGetObjectPropertyRequest {
	r.locale = &locale
	return r
}

// Defines which page number to return.
func (r ApiSmsCommandGetObjectPropertyRequest) Page(page int32) ApiSmsCommandGetObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiSmsCommandGetObjectPropertyRequest) PageSize(pageSize int32) ApiSmsCommandGetObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiSmsCommandGetObjectPropertyRequest) Paging(paging bool) ApiSmsCommandGetObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiSmsCommandGetObjectPropertyRequest) RootJunction(rootJunction string) ApiSmsCommandGetObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiSmsCommandGetObjectPropertyRequest) Translate(translate bool) ApiSmsCommandGetObjectPropertyRequest {
	r.translate = &translate
	return r
}

func (r ApiSmsCommandGetObjectPropertyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SmsCommandGetObjectPropertyExecute(r)
}

/*
SmsCommandGetObjectProperty Method for SmsCommandGetObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsCommandGetObjectPropertyRequest
*/
func (a *MessagingAPIService) SmsCommandGetObjectProperty(ctx context.Context, property string, uid string) ApiSmsCommandGetObjectPropertyRequest {
	return ApiSmsCommandGetObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MessagingAPIService) SmsCommandGetObjectPropertyExecute(r ApiSmsCommandGetObjectPropertyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandGetObjectProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsCommandGetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiSmsCommandGetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiSmsCommandGetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiSmsCommandGetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiSmsCommandGetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiSmsCommandGetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiSmsCommandGetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiSmsCommandGetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiSmsCommandGetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiSmsCommandGetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiSmsCommandGetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiSmsCommandGetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiSmsCommandGetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiSmsCommandGetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiSmsCommandGetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiSmsCommandGetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiSmsCommandGetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiSmsCommandGetObjectPropertyGistAsCsvRequest) Order(order string) ApiSmsCommandGetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiSmsCommandGetObjectPropertyGistAsCsvRequest) Page(page int32) ApiSmsCommandGetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiSmsCommandGetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiSmsCommandGetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiSmsCommandGetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiSmsCommandGetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiSmsCommandGetObjectPropertyGistAsCsvRequest) References(references bool) ApiSmsCommandGetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiSmsCommandGetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiSmsCommandGetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiSmsCommandGetObjectPropertyGistAsCsvRequest) Total(total bool) ApiSmsCommandGetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiSmsCommandGetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiSmsCommandGetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiSmsCommandGetObjectPropertyGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.SmsCommandGetObjectPropertyGistAsCsvExecute(r)
}

/*
SmsCommandGetObjectPropertyGistAsCsv Method for SmsCommandGetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsCommandGetObjectPropertyGistAsCsvRequest
*/
func (a *MessagingAPIService) SmsCommandGetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiSmsCommandGetObjectPropertyGistAsCsvRequest {
	return ApiSmsCommandGetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *MessagingAPIService) SmsCommandGetObjectPropertyGistAsCsvExecute(r ApiSmsCommandGetObjectPropertyGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandGetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/{uid}/{property}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Order(order string) ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Page(page int32) ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) References(references bool) ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Total(total bool) ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Execute() (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.SmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r)
}

/*
SmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsv Method for SmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest
*/
func (a *MessagingAPIService) SmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	return ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
func (a *MessagingAPIService) SmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r ApiSmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandGetObjectPropertyGistgetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/{uid}/{property}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsCommandPatchObjectRequest struct {
	ctx                context.Context
	ApiService         *MessagingAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	jsonPatch          *JsonPatch
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiSmsCommandPatchObjectRequest) AtomicMode(atomicMode string) ApiSmsCommandPatchObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiSmsCommandPatchObjectRequest) FlushMode(flushMode string) ApiSmsCommandPatchObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiSmsCommandPatchObjectRequest) Identifier(identifier string) ApiSmsCommandPatchObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiSmsCommandPatchObjectRequest) ImportMode(importMode string) ApiSmsCommandPatchObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiSmsCommandPatchObjectRequest) ImportReportMode(importReportMode string) ApiSmsCommandPatchObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiSmsCommandPatchObjectRequest) ImportStrategy(importStrategy string) ApiSmsCommandPatchObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiSmsCommandPatchObjectRequest) MergeMode(mergeMode string) ApiSmsCommandPatchObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiSmsCommandPatchObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiSmsCommandPatchObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiSmsCommandPatchObjectRequest) Page(page int32) ApiSmsCommandPatchObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiSmsCommandPatchObjectRequest) PageSize(pageSize int32) ApiSmsCommandPatchObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiSmsCommandPatchObjectRequest) Paging(paging bool) ApiSmsCommandPatchObjectRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiSmsCommandPatchObjectRequest) PreheatMode(preheatMode string) ApiSmsCommandPatchObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiSmsCommandPatchObjectRequest) RootJunction(rootJunction string) ApiSmsCommandPatchObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiSmsCommandPatchObjectRequest) SkipSharing(skipSharing bool) ApiSmsCommandPatchObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiSmsCommandPatchObjectRequest) SkipTranslation(skipTranslation bool) ApiSmsCommandPatchObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiSmsCommandPatchObjectRequest) SkipValidation(skipValidation bool) ApiSmsCommandPatchObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiSmsCommandPatchObjectRequest) UserOverrideMode(userOverrideMode string) ApiSmsCommandPatchObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiSmsCommandPatchObjectRequest) JsonPatch(jsonPatch JsonPatch) ApiSmsCommandPatchObjectRequest {
	r.jsonPatch = &jsonPatch
	return r
}

func (r ApiSmsCommandPatchObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsCommandPatchObjectExecute(r)
}

/*
SmsCommandPatchObject Method for SmsCommandPatchObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsCommandPatchObjectRequest
*/
func (a *MessagingAPIService) SmsCommandPatchObject(ctx context.Context, uid string) ApiSmsCommandPatchObjectRequest {
	return ApiSmsCommandPatchObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsCommandPatchObjectExecute(r ApiSmsCommandPatchObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandPatchObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsCommandPostJsonObjectpostXmlObjectRequest struct {
	ctx                context.Context
	ApiService         *MessagingAPIService
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	preheatMode        *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	sMSCommand         *SMSCommand
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiSmsCommandPostJsonObjectpostXmlObjectRequest) AtomicMode(atomicMode string) ApiSmsCommandPostJsonObjectpostXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiSmsCommandPostJsonObjectpostXmlObjectRequest) FlushMode(flushMode string) ApiSmsCommandPostJsonObjectpostXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiSmsCommandPostJsonObjectpostXmlObjectRequest) Identifier(identifier string) ApiSmsCommandPostJsonObjectpostXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiSmsCommandPostJsonObjectpostXmlObjectRequest) ImportMode(importMode string) ApiSmsCommandPostJsonObjectpostXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiSmsCommandPostJsonObjectpostXmlObjectRequest) ImportReportMode(importReportMode string) ApiSmsCommandPostJsonObjectpostXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiSmsCommandPostJsonObjectpostXmlObjectRequest) ImportStrategy(importStrategy string) ApiSmsCommandPostJsonObjectpostXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiSmsCommandPostJsonObjectpostXmlObjectRequest) MergeMode(mergeMode string) ApiSmsCommandPostJsonObjectpostXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiSmsCommandPostJsonObjectpostXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiSmsCommandPostJsonObjectpostXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiSmsCommandPostJsonObjectpostXmlObjectRequest) PreheatMode(preheatMode string) ApiSmsCommandPostJsonObjectpostXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiSmsCommandPostJsonObjectpostXmlObjectRequest) SkipSharing(skipSharing bool) ApiSmsCommandPostJsonObjectpostXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiSmsCommandPostJsonObjectpostXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiSmsCommandPostJsonObjectpostXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiSmsCommandPostJsonObjectpostXmlObjectRequest) SkipValidation(skipValidation bool) ApiSmsCommandPostJsonObjectpostXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiSmsCommandPostJsonObjectpostXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiSmsCommandPostJsonObjectpostXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiSmsCommandPostJsonObjectpostXmlObjectRequest) SMSCommand(sMSCommand SMSCommand) ApiSmsCommandPostJsonObjectpostXmlObjectRequest {
	r.sMSCommand = &sMSCommand
	return r
}

func (r ApiSmsCommandPostJsonObjectpostXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsCommandPostJsonObjectpostXmlObjectExecute(r)
}

/*
SmsCommandPostJsonObjectpostXmlObject Method for SmsCommandPostJsonObjectpostXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsCommandPostJsonObjectpostXmlObjectRequest
*/
func (a *MessagingAPIService) SmsCommandPostJsonObjectpostXmlObject(ctx context.Context) ApiSmsCommandPostJsonObjectpostXmlObjectRequest {
	return ApiSmsCommandPostJsonObjectpostXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsCommandPostJsonObjectpostXmlObjectExecute(r ApiSmsCommandPostJsonObjectpostXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandPostJsonObjectpostXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sMSCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsCommandPutJsonObjectputXmlObjectRequest struct {
	ctx                context.Context
	ApiService         *MessagingAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	preheatMode        *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	sMSCommand         *SMSCommand
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiSmsCommandPutJsonObjectputXmlObjectRequest) AtomicMode(atomicMode string) ApiSmsCommandPutJsonObjectputXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiSmsCommandPutJsonObjectputXmlObjectRequest) FlushMode(flushMode string) ApiSmsCommandPutJsonObjectputXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiSmsCommandPutJsonObjectputXmlObjectRequest) Identifier(identifier string) ApiSmsCommandPutJsonObjectputXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiSmsCommandPutJsonObjectputXmlObjectRequest) ImportMode(importMode string) ApiSmsCommandPutJsonObjectputXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiSmsCommandPutJsonObjectputXmlObjectRequest) ImportReportMode(importReportMode string) ApiSmsCommandPutJsonObjectputXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiSmsCommandPutJsonObjectputXmlObjectRequest) ImportStrategy(importStrategy string) ApiSmsCommandPutJsonObjectputXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiSmsCommandPutJsonObjectputXmlObjectRequest) MergeMode(mergeMode string) ApiSmsCommandPutJsonObjectputXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiSmsCommandPutJsonObjectputXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiSmsCommandPutJsonObjectputXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiSmsCommandPutJsonObjectputXmlObjectRequest) PreheatMode(preheatMode string) ApiSmsCommandPutJsonObjectputXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiSmsCommandPutJsonObjectputXmlObjectRequest) SkipSharing(skipSharing bool) ApiSmsCommandPutJsonObjectputXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiSmsCommandPutJsonObjectputXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiSmsCommandPutJsonObjectputXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiSmsCommandPutJsonObjectputXmlObjectRequest) SkipValidation(skipValidation bool) ApiSmsCommandPutJsonObjectputXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiSmsCommandPutJsonObjectputXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiSmsCommandPutJsonObjectputXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiSmsCommandPutJsonObjectputXmlObjectRequest) SMSCommand(sMSCommand SMSCommand) ApiSmsCommandPutJsonObjectputXmlObjectRequest {
	r.sMSCommand = &sMSCommand
	return r
}

func (r ApiSmsCommandPutJsonObjectputXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsCommandPutJsonObjectputXmlObjectExecute(r)
}

/*
SmsCommandPutJsonObjectputXmlObject Method for SmsCommandPutJsonObjectputXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsCommandPutJsonObjectputXmlObjectRequest
*/
func (a *MessagingAPIService) SmsCommandPutJsonObjectputXmlObject(ctx context.Context, uid string) ApiSmsCommandPutJsonObjectputXmlObjectRequest {
	return ApiSmsCommandPutJsonObjectputXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsCommandPutJsonObjectputXmlObjectExecute(r ApiSmsCommandPutJsonObjectputXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandPutJsonObjectputXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sMSCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsCommandRemoveAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
}

func (r ApiSmsCommandRemoveAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsCommandRemoveAsFavoriteExecute(r)
}

/*
SmsCommandRemoveAsFavorite Method for SmsCommandRemoveAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsCommandRemoveAsFavoriteRequest
*/
func (a *MessagingAPIService) SmsCommandRemoveAsFavorite(ctx context.Context, uid string) ApiSmsCommandRemoveAsFavoriteRequest {
	return ApiSmsCommandRemoveAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsCommandRemoveAsFavoriteExecute(r ApiSmsCommandRemoveAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandRemoveAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsCommandReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *MessagingAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiSmsCommandReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiSmsCommandReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiSmsCommandReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsCommandReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r)
}

/*
SmsCommandReplaceCollectionItemsJsonreplaceCollectionItemsXml Method for SmsCommandReplaceCollectionItemsJsonreplaceCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsCommandReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest
*/
func (a *MessagingAPIService) SmsCommandReplaceCollectionItemsJsonreplaceCollectionItemsXml(ctx context.Context, property string, uid string) ApiSmsCommandReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	return ApiSmsCommandReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsCommandReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r ApiSmsCommandReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandReplaceCollectionItemsJsonreplaceCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsCommandReplaceTranslationsRequest struct {
	ctx                                             context.Context
	ApiService                                      *MessagingAPIService
	uid                                             string
	aggregateDataExchangeReplaceTranslationsRequest *AggregateDataExchangeReplaceTranslationsRequest
}

// [no description yet]
func (r ApiSmsCommandReplaceTranslationsRequest) AggregateDataExchangeReplaceTranslationsRequest(aggregateDataExchangeReplaceTranslationsRequest AggregateDataExchangeReplaceTranslationsRequest) ApiSmsCommandReplaceTranslationsRequest {
	r.aggregateDataExchangeReplaceTranslationsRequest = &aggregateDataExchangeReplaceTranslationsRequest
	return r
}

func (r ApiSmsCommandReplaceTranslationsRequest) Execute() (*http.Response, error) {
	return r.ApiService.SmsCommandReplaceTranslationsExecute(r)
}

/*
SmsCommandReplaceTranslations Method for SmsCommandReplaceTranslations

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsCommandReplaceTranslationsRequest
*/
func (a *MessagingAPIService) SmsCommandReplaceTranslations(ctx context.Context, uid string) ApiSmsCommandReplaceTranslationsRequest {
	return ApiSmsCommandReplaceTranslationsRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *MessagingAPIService) SmsCommandReplaceTranslationsExecute(r ApiSmsCommandReplaceTranslationsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandReplaceTranslations")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/{uid}/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateDataExchangeReplaceTranslationsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSmsCommandSetAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
}

func (r ApiSmsCommandSetAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsCommandSetAsFavoriteExecute(r)
}

/*
SmsCommandSetAsFavorite Method for SmsCommandSetAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsCommandSetAsFavoriteRequest
*/
func (a *MessagingAPIService) SmsCommandSetAsFavorite(ctx context.Context, uid string) ApiSmsCommandSetAsFavoriteRequest {
	return ApiSmsCommandSetAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsCommandSetAsFavoriteExecute(r ApiSmsCommandSetAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandSetAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsCommandSetSharingRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
	sharing    *Sharing
}

// [no description yet]
func (r ApiSmsCommandSetSharingRequest) Sharing(sharing Sharing) ApiSmsCommandSetSharingRequest {
	r.sharing = &sharing
	return r
}

func (r ApiSmsCommandSetSharingRequest) Execute() (*http.Response, error) {
	return r.ApiService.SmsCommandSetSharingExecute(r)
}

/*
SmsCommandSetSharing Method for SmsCommandSetSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsCommandSetSharingRequest
*/
func (a *MessagingAPIService) SmsCommandSetSharing(ctx context.Context, uid string) ApiSmsCommandSetSharingRequest {
	return ApiSmsCommandSetSharingRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *MessagingAPIService) SmsCommandSetSharingExecute(r ApiSmsCommandSetSharingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandSetSharing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/{uid}/sharing"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharing
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSmsCommandSubscribeRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
}

func (r ApiSmsCommandSubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsCommandSubscribeExecute(r)
}

/*
SmsCommandSubscribe Method for SmsCommandSubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsCommandSubscribeRequest
*/
func (a *MessagingAPIService) SmsCommandSubscribe(ctx context.Context, uid string) ApiSmsCommandSubscribeRequest {
	return ApiSmsCommandSubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsCommandSubscribeExecute(r ApiSmsCommandSubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandSubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsCommandUnsubscribeRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
}

func (r ApiSmsCommandUnsubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsCommandUnsubscribeExecute(r)
}

/*
SmsCommandUnsubscribe Method for SmsCommandUnsubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsCommandUnsubscribeRequest
*/
func (a *MessagingAPIService) SmsCommandUnsubscribe(ctx context.Context, uid string) ApiSmsCommandUnsubscribeRequest {
	return ApiSmsCommandUnsubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsCommandUnsubscribeExecute(r ApiSmsCommandUnsubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandUnsubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsCommandUpdateObjectPropertyRequest struct {
	ctx                context.Context
	ApiService         *MessagingAPIService
	property           string
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	sMSCommand         *SMSCommand
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiSmsCommandUpdateObjectPropertyRequest) AtomicMode(atomicMode string) ApiSmsCommandUpdateObjectPropertyRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiSmsCommandUpdateObjectPropertyRequest) FlushMode(flushMode string) ApiSmsCommandUpdateObjectPropertyRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiSmsCommandUpdateObjectPropertyRequest) Identifier(identifier string) ApiSmsCommandUpdateObjectPropertyRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiSmsCommandUpdateObjectPropertyRequest) ImportMode(importMode string) ApiSmsCommandUpdateObjectPropertyRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiSmsCommandUpdateObjectPropertyRequest) ImportReportMode(importReportMode string) ApiSmsCommandUpdateObjectPropertyRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiSmsCommandUpdateObjectPropertyRequest) ImportStrategy(importStrategy string) ApiSmsCommandUpdateObjectPropertyRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiSmsCommandUpdateObjectPropertyRequest) MergeMode(mergeMode string) ApiSmsCommandUpdateObjectPropertyRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiSmsCommandUpdateObjectPropertyRequest) MetadataSyncImport(metadataSyncImport bool) ApiSmsCommandUpdateObjectPropertyRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiSmsCommandUpdateObjectPropertyRequest) Page(page int32) ApiSmsCommandUpdateObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiSmsCommandUpdateObjectPropertyRequest) PageSize(pageSize int32) ApiSmsCommandUpdateObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiSmsCommandUpdateObjectPropertyRequest) Paging(paging bool) ApiSmsCommandUpdateObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiSmsCommandUpdateObjectPropertyRequest) PreheatMode(preheatMode string) ApiSmsCommandUpdateObjectPropertyRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiSmsCommandUpdateObjectPropertyRequest) RootJunction(rootJunction string) ApiSmsCommandUpdateObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiSmsCommandUpdateObjectPropertyRequest) SkipSharing(skipSharing bool) ApiSmsCommandUpdateObjectPropertyRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiSmsCommandUpdateObjectPropertyRequest) SkipTranslation(skipTranslation bool) ApiSmsCommandUpdateObjectPropertyRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiSmsCommandUpdateObjectPropertyRequest) SkipValidation(skipValidation bool) ApiSmsCommandUpdateObjectPropertyRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiSmsCommandUpdateObjectPropertyRequest) UserOverrideMode(userOverrideMode string) ApiSmsCommandUpdateObjectPropertyRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiSmsCommandUpdateObjectPropertyRequest) SMSCommand(sMSCommand SMSCommand) ApiSmsCommandUpdateObjectPropertyRequest {
	r.sMSCommand = &sMSCommand
	return r
}

func (r ApiSmsCommandUpdateObjectPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.SmsCommandUpdateObjectPropertyExecute(r)
}

/*
SmsCommandUpdateObjectProperty Method for SmsCommandUpdateObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsCommandUpdateObjectPropertyRequest
*/
func (a *MessagingAPIService) SmsCommandUpdateObjectProperty(ctx context.Context, property string, uid string) ApiSmsCommandUpdateObjectPropertyRequest {
	return ApiSmsCommandUpdateObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
func (a *MessagingAPIService) SmsCommandUpdateObjectPropertyExecute(r ApiSmsCommandUpdateObjectPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsCommandUpdateObjectProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smsCommands/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sMSCommand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSmsGatewayAddGatewayRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
}

func (r ApiSmsGatewayAddGatewayRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsGatewayAddGatewayExecute(r)
}

/*
SmsGatewayAddGateway Method for SmsGatewayAddGateway

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsGatewayAddGatewayRequest
*/
func (a *MessagingAPIService) SmsGatewayAddGateway(ctx context.Context) ApiSmsGatewayAddGatewayRequest {
	return ApiSmsGatewayAddGatewayRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsGatewayAddGatewayExecute(r ApiSmsGatewayAddGatewayRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsGatewayAddGateway")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateways/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsGatewayGetGatewayConfigurationRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
	fields     *[]FieldPath
}

// [no description yet]
func (r ApiSmsGatewayGetGatewayConfigurationRequest) Fields(fields []FieldPath) ApiSmsGatewayGetGatewayConfigurationRequest {
	r.fields = &fields
	return r
}

func (r ApiSmsGatewayGetGatewayConfigurationRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SmsGatewayGetGatewayConfigurationExecute(r)
}

/*
SmsGatewayGetGatewayConfiguration Method for SmsGatewayGetGatewayConfiguration

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsGatewayGetGatewayConfigurationRequest
*/
func (a *MessagingAPIService) SmsGatewayGetGatewayConfiguration(ctx context.Context, uid string) ApiSmsGatewayGetGatewayConfigurationRequest {
	return ApiSmsGatewayGetGatewayConfigurationRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MessagingAPIService) SmsGatewayGetGatewayConfigurationExecute(r ApiSmsGatewayGetGatewayConfigurationRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsGatewayGetGatewayConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateways/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsGatewayGetGatewaysRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	fields     *[]string
}

// [no description yet]
func (r ApiSmsGatewayGetGatewaysRequest) Fields(fields []string) ApiSmsGatewayGetGatewaysRequest {
	r.fields = &fields
	return r
}

func (r ApiSmsGatewayGetGatewaysRequest) Execute() (*JsonRoot, *http.Response, error) {
	return r.ApiService.SmsGatewayGetGatewaysExecute(r)
}

/*
SmsGatewayGetGateways Method for SmsGatewayGetGateways

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsGatewayGetGatewaysRequest
*/
func (a *MessagingAPIService) SmsGatewayGetGateways(ctx context.Context) ApiSmsGatewayGetGatewaysRequest {
	return ApiSmsGatewayGetGatewaysRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return JsonRoot
func (a *MessagingAPIService) SmsGatewayGetGatewaysExecute(r ApiSmsGatewayGetGatewaysRequest) (*JsonRoot, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *JsonRoot
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsGatewayGetGateways")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateways/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsGatewayRemoveGatewayRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
}

func (r ApiSmsGatewayRemoveGatewayRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsGatewayRemoveGatewayExecute(r)
}

/*
SmsGatewayRemoveGateway Method for SmsGatewayRemoveGateway

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsGatewayRemoveGatewayRequest
*/
func (a *MessagingAPIService) SmsGatewayRemoveGateway(ctx context.Context, uid string) ApiSmsGatewayRemoveGatewayRequest {
	return ApiSmsGatewayRemoveGatewayRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsGatewayRemoveGatewayExecute(r ApiSmsGatewayRemoveGatewayRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsGatewayRemoveGateway")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateways/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsGatewaySetDefaultRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
}

func (r ApiSmsGatewaySetDefaultRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsGatewaySetDefaultExecute(r)
}

/*
SmsGatewaySetDefault Method for SmsGatewaySetDefault

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsGatewaySetDefaultRequest
*/
func (a *MessagingAPIService) SmsGatewaySetDefault(ctx context.Context, uid string) ApiSmsGatewaySetDefaultRequest {
	return ApiSmsGatewaySetDefaultRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsGatewaySetDefaultExecute(r ApiSmsGatewaySetDefaultRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsGatewaySetDefault")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateways/default/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsGatewayUpdateGatewayRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
}

func (r ApiSmsGatewayUpdateGatewayRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsGatewayUpdateGatewayExecute(r)
}

/*
SmsGatewayUpdateGateway Method for SmsGatewayUpdateGateway

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsGatewayUpdateGatewayRequest
*/
func (a *MessagingAPIService) SmsGatewayUpdateGateway(ctx context.Context, uid string) ApiSmsGatewayUpdateGatewayRequest {
	return ApiSmsGatewayUpdateGatewayRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsGatewayUpdateGatewayExecute(r ApiSmsGatewayUpdateGatewayRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsGatewayUpdateGateway")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gateways/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundAddCollectionItemRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiSmsInboundAddCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsInboundAddCollectionItemExecute(r)
}

/*
SmsInboundAddCollectionItem Method for SmsInboundAddCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsInboundAddCollectionItemRequest
*/
func (a *MessagingAPIService) SmsInboundAddCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiSmsInboundAddCollectionItemRequest {
	return ApiSmsInboundAddCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsInboundAddCollectionItemExecute(r ApiSmsInboundAddCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundAddCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundAddCollectionItemsJsonaddCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *MessagingAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiSmsInboundAddCollectionItemsJsonaddCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiSmsInboundAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiSmsInboundAddCollectionItemsJsonaddCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsInboundAddCollectionItemsJsonaddCollectionItemsXmlExecute(r)
}

/*
SmsInboundAddCollectionItemsJsonaddCollectionItemsXml Method for SmsInboundAddCollectionItemsJsonaddCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsInboundAddCollectionItemsJsonaddCollectionItemsXmlRequest
*/
func (a *MessagingAPIService) SmsInboundAddCollectionItemsJsonaddCollectionItemsXml(ctx context.Context, property string, uid string) ApiSmsInboundAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	return ApiSmsInboundAddCollectionItemsJsonaddCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsInboundAddCollectionItemsJsonaddCollectionItemsXmlExecute(r ApiSmsInboundAddCollectionItemsJsonaddCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundAddCollectionItemsJsonaddCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundBulkSharingRequest struct {
	ctx                context.Context
	ApiService         *MessagingAPIService
	atomic             *bool
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	bulkJsonPatch      *BulkJsonPatch
}

// [no description yet]
func (r ApiSmsInboundBulkSharingRequest) Atomic(atomic bool) ApiSmsInboundBulkSharingRequest {
	r.atomic = &atomic
	return r
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiSmsInboundBulkSharingRequest) AtomicMode(atomicMode string) ApiSmsInboundBulkSharingRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiSmsInboundBulkSharingRequest) FlushMode(flushMode string) ApiSmsInboundBulkSharingRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiSmsInboundBulkSharingRequest) Identifier(identifier string) ApiSmsInboundBulkSharingRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiSmsInboundBulkSharingRequest) ImportMode(importMode string) ApiSmsInboundBulkSharingRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiSmsInboundBulkSharingRequest) ImportReportMode(importReportMode string) ApiSmsInboundBulkSharingRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiSmsInboundBulkSharingRequest) ImportStrategy(importStrategy string) ApiSmsInboundBulkSharingRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiSmsInboundBulkSharingRequest) MergeMode(mergeMode string) ApiSmsInboundBulkSharingRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiSmsInboundBulkSharingRequest) MetadataSyncImport(metadataSyncImport bool) ApiSmsInboundBulkSharingRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiSmsInboundBulkSharingRequest) Page(page int32) ApiSmsInboundBulkSharingRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiSmsInboundBulkSharingRequest) PageSize(pageSize int32) ApiSmsInboundBulkSharingRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiSmsInboundBulkSharingRequest) Paging(paging bool) ApiSmsInboundBulkSharingRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiSmsInboundBulkSharingRequest) PreheatMode(preheatMode string) ApiSmsInboundBulkSharingRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiSmsInboundBulkSharingRequest) RootJunction(rootJunction string) ApiSmsInboundBulkSharingRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiSmsInboundBulkSharingRequest) SkipSharing(skipSharing bool) ApiSmsInboundBulkSharingRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiSmsInboundBulkSharingRequest) SkipTranslation(skipTranslation bool) ApiSmsInboundBulkSharingRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiSmsInboundBulkSharingRequest) SkipValidation(skipValidation bool) ApiSmsInboundBulkSharingRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiSmsInboundBulkSharingRequest) UserOverrideMode(userOverrideMode string) ApiSmsInboundBulkSharingRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiSmsInboundBulkSharingRequest) BulkJsonPatch(bulkJsonPatch BulkJsonPatch) ApiSmsInboundBulkSharingRequest {
	r.bulkJsonPatch = &bulkJsonPatch
	return r
}

func (r ApiSmsInboundBulkSharingRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsInboundBulkSharingExecute(r)
}

/*
SmsInboundBulkSharing Method for SmsInboundBulkSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsInboundBulkSharingRequest
*/
func (a *MessagingAPIService) SmsInboundBulkSharing(ctx context.Context) ApiSmsInboundBulkSharingRequest {
	return ApiSmsInboundBulkSharingRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsInboundBulkSharingExecute(r ApiSmsInboundBulkSharingRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundBulkSharing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/sharing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomic", r.atomic, "")
	} else {
		var defaultValue bool = false
		r.atomic = &defaultValue
	}
	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkJsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundDeleteCollectionItemRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiSmsInboundDeleteCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsInboundDeleteCollectionItemExecute(r)
}

/*
SmsInboundDeleteCollectionItem Method for SmsInboundDeleteCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsInboundDeleteCollectionItemRequest
*/
func (a *MessagingAPIService) SmsInboundDeleteCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiSmsInboundDeleteCollectionItemRequest {
	return ApiSmsInboundDeleteCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsInboundDeleteCollectionItemExecute(r ApiSmsInboundDeleteCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundDeleteCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *MessagingAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiSmsInboundDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiSmsInboundDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiSmsInboundDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsInboundDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r)
}

/*
SmsInboundDeleteCollectionItemsJsondeleteCollectionItemsXml Method for SmsInboundDeleteCollectionItemsJsondeleteCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsInboundDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest
*/
func (a *MessagingAPIService) SmsInboundDeleteCollectionItemsJsondeleteCollectionItemsXml(ctx context.Context, property string, uid string) ApiSmsInboundDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	return ApiSmsInboundDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsInboundDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r ApiSmsInboundDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundDeleteCollectionItemsJsondeleteCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundDeleteInboundMessagesRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	ids        *[]string
}

// [no description yet]
func (r ApiSmsInboundDeleteInboundMessagesRequest) Ids(ids []string) ApiSmsInboundDeleteInboundMessagesRequest {
	r.ids = &ids
	return r
}

func (r ApiSmsInboundDeleteInboundMessagesRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsInboundDeleteInboundMessagesExecute(r)
}

/*
SmsInboundDeleteInboundMessages Method for SmsInboundDeleteInboundMessages

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsInboundDeleteInboundMessagesRequest
*/
func (a *MessagingAPIService) SmsInboundDeleteInboundMessages(ctx context.Context) ApiSmsInboundDeleteInboundMessagesRequest {
	return ApiSmsInboundDeleteInboundMessagesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsInboundDeleteInboundMessagesExecute(r ApiSmsInboundDeleteInboundMessagesRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundDeleteInboundMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	{
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundDeleteObjectdeleteInboundMessageRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
}

func (r ApiSmsInboundDeleteObjectdeleteInboundMessageRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsInboundDeleteObjectdeleteInboundMessageExecute(r)
}

/*
SmsInboundDeleteObjectdeleteInboundMessage Method for SmsInboundDeleteObjectdeleteInboundMessage

Deletes the IncomingSms provided by ID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsInboundDeleteObjectdeleteInboundMessageRequest
*/
func (a *MessagingAPIService) SmsInboundDeleteObjectdeleteInboundMessage(ctx context.Context, uid string) ApiSmsInboundDeleteObjectdeleteInboundMessageRequest {
	return ApiSmsInboundDeleteObjectdeleteInboundMessageRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsInboundDeleteObjectdeleteInboundMessageExecute(r ApiSmsInboundDeleteObjectdeleteInboundMessageRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundDeleteObjectdeleteInboundMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundGetObjectRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	uid          string
	fields       *[]string
	filter       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiSmsInboundGetObjectRequest) Fields(fields []string) ApiSmsInboundGetObjectRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiSmsInboundGetObjectRequest) Filter(filter []string) ApiSmsInboundGetObjectRequest {
	r.filter = &filter
	return r
}

// Defines which page number to return.
func (r ApiSmsInboundGetObjectRequest) Page(page int32) ApiSmsInboundGetObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiSmsInboundGetObjectRequest) PageSize(pageSize int32) ApiSmsInboundGetObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiSmsInboundGetObjectRequest) Paging(paging bool) ApiSmsInboundGetObjectRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiSmsInboundGetObjectRequest) RootJunction(rootJunction string) ApiSmsInboundGetObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiSmsInboundGetObjectRequest) Execute() (*IncomingSms, *http.Response, error) {
	return r.ApiService.SmsInboundGetObjectExecute(r)
}

/*
SmsInboundGetObject Method for SmsInboundGetObject

View a IncomingSms

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsInboundGetObjectRequest
*/
func (a *MessagingAPIService) SmsInboundGetObject(ctx context.Context, uid string) ApiSmsInboundGetObjectRequest {
	return ApiSmsInboundGetObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return IncomingSms
func (a *MessagingAPIService) SmsInboundGetObjectExecute(r ApiSmsInboundGetObjectRequest) (*IncomingSms, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IncomingSms
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundGetObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundGetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiSmsInboundGetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiSmsInboundGetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiSmsInboundGetObjectGistAsCsvRequest) Auto(auto string) ApiSmsInboundGetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiSmsInboundGetObjectGistAsCsvRequest) Describe(describe bool) ApiSmsInboundGetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiSmsInboundGetObjectGistAsCsvRequest) Fields(fields string) ApiSmsInboundGetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiSmsInboundGetObjectGistAsCsvRequest) Filter(filter string) ApiSmsInboundGetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiSmsInboundGetObjectGistAsCsvRequest) Headless(headless bool) ApiSmsInboundGetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiSmsInboundGetObjectGistAsCsvRequest) Inverse(inverse bool) ApiSmsInboundGetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiSmsInboundGetObjectGistAsCsvRequest) Locale(locale string) ApiSmsInboundGetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiSmsInboundGetObjectGistAsCsvRequest) Order(order string) ApiSmsInboundGetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiSmsInboundGetObjectGistAsCsvRequest) Page(page int32) ApiSmsInboundGetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiSmsInboundGetObjectGistAsCsvRequest) PageListName(pageListName string) ApiSmsInboundGetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiSmsInboundGetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiSmsInboundGetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiSmsInboundGetObjectGistAsCsvRequest) References(references bool) ApiSmsInboundGetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiSmsInboundGetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiSmsInboundGetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiSmsInboundGetObjectGistAsCsvRequest) Total(total bool) ApiSmsInboundGetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiSmsInboundGetObjectGistAsCsvRequest) Translate(translate bool) ApiSmsInboundGetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiSmsInboundGetObjectGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.SmsInboundGetObjectGistAsCsvExecute(r)
}

/*
SmsInboundGetObjectGistAsCsv Method for SmsInboundGetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsInboundGetObjectGistAsCsvRequest
*/
func (a *MessagingAPIService) SmsInboundGetObjectGistAsCsv(ctx context.Context, uid string) ApiSmsInboundGetObjectGistAsCsvRequest {
	return ApiSmsInboundGetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *MessagingAPIService) SmsInboundGetObjectGistAsCsvExecute(r ApiSmsInboundGetObjectGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundGetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/{uid}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest) Auto(auto string) ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest) Describe(describe bool) ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest) Fields(fields string) ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest) Filter(filter string) ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest) Headless(headless bool) ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest) Inverse(inverse bool) ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest) Locale(locale string) ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest) Order(order string) ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest) Page(page int32) ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest) PageListName(pageListName string) ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest) References(references bool) ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest) Total(total bool) ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest) Translate(translate bool) ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SmsInboundGetObjectGistgetObjectGistAsCsvExecute(r)
}

/*
SmsInboundGetObjectGistgetObjectGistAsCsv Method for SmsInboundGetObjectGistgetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest
*/
func (a *MessagingAPIService) SmsInboundGetObjectGistgetObjectGistAsCsv(ctx context.Context, uid string) ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest {
	return ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MessagingAPIService) SmsInboundGetObjectGistgetObjectGistAsCsvExecute(r ApiSmsInboundGetObjectGistgetObjectGistAsCsvRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundGetObjectGistgetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/{uid}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundGetObjectListRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	fields       *[]string
	filter       *[]string
	orders       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// &#x60;&lt;field-name&gt;[,&lt;field-name&gt;...]&#x60;
func (r ApiSmsInboundGetObjectListRequest) Fields(fields []string) ApiSmsInboundGetObjectListRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiSmsInboundGetObjectListRequest) Filter(filter []string) ApiSmsInboundGetObjectListRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiSmsInboundGetObjectListRequest) Orders(orders []string) ApiSmsInboundGetObjectListRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiSmsInboundGetObjectListRequest) Page(page int32) ApiSmsInboundGetObjectListRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiSmsInboundGetObjectListRequest) PageSize(pageSize int32) ApiSmsInboundGetObjectListRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiSmsInboundGetObjectListRequest) Paging(paging bool) ApiSmsInboundGetObjectListRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiSmsInboundGetObjectListRequest) RootJunction(rootJunction string) ApiSmsInboundGetObjectListRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiSmsInboundGetObjectListRequest) Execute() (*SmsInboundGetObjectList200Response, *http.Response, error) {
	return r.ApiService.SmsInboundGetObjectListExecute(r)
}

/*
SmsInboundGetObjectList Method for SmsInboundGetObjectList

List all IncomingSmss

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsInboundGetObjectListRequest
*/
func (a *MessagingAPIService) SmsInboundGetObjectList(ctx context.Context) ApiSmsInboundGetObjectListRequest {
	return ApiSmsInboundGetObjectListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SmsInboundGetObjectList200Response
func (a *MessagingAPIService) SmsInboundGetObjectListExecute(r ApiSmsInboundGetObjectListRequest) (*SmsInboundGetObjectList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SmsInboundGetObjectList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundGetObjectList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundGetObjectListCsvRequest struct {
	ctx            context.Context
	ApiService     *MessagingAPIService
	arraySeparator *string
	fields         *[]string
	filter         *[]string
	orders         *[]string
	page           *int32
	pageSize       *int32
	paging         *bool
	rootJunction   *string
	separator      *string
	skipHeader     *bool
}

// [no description yet]
func (r ApiSmsInboundGetObjectListCsvRequest) ArraySeparator(arraySeparator string) ApiSmsInboundGetObjectListCsvRequest {
	r.arraySeparator = &arraySeparator
	return r
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiSmsInboundGetObjectListCsvRequest) Fields(fields []string) ApiSmsInboundGetObjectListCsvRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiSmsInboundGetObjectListCsvRequest) Filter(filter []string) ApiSmsInboundGetObjectListCsvRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiSmsInboundGetObjectListCsvRequest) Orders(orders []string) ApiSmsInboundGetObjectListCsvRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiSmsInboundGetObjectListCsvRequest) Page(page int32) ApiSmsInboundGetObjectListCsvRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiSmsInboundGetObjectListCsvRequest) PageSize(pageSize int32) ApiSmsInboundGetObjectListCsvRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiSmsInboundGetObjectListCsvRequest) Paging(paging bool) ApiSmsInboundGetObjectListCsvRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiSmsInboundGetObjectListCsvRequest) RootJunction(rootJunction string) ApiSmsInboundGetObjectListCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiSmsInboundGetObjectListCsvRequest) Separator(separator string) ApiSmsInboundGetObjectListCsvRequest {
	r.separator = &separator
	return r
}

// [no description yet]
func (r ApiSmsInboundGetObjectListCsvRequest) SkipHeader(skipHeader bool) ApiSmsInboundGetObjectListCsvRequest {
	r.skipHeader = &skipHeader
	return r
}

func (r ApiSmsInboundGetObjectListCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.SmsInboundGetObjectListCsvExecute(r)
}

/*
SmsInboundGetObjectListCsv Method for SmsInboundGetObjectListCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsInboundGetObjectListCsvRequest
*/
func (a *MessagingAPIService) SmsInboundGetObjectListCsv(ctx context.Context) ApiSmsInboundGetObjectListCsvRequest {
	return ApiSmsInboundGetObjectListCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *MessagingAPIService) SmsInboundGetObjectListCsvExecute(r ApiSmsInboundGetObjectListCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundGetObjectListCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/#getObjectListCsv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.arraySeparator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arraySeparator", r.arraySeparator, "")
	} else {
		var defaultValue string = ";"
		r.arraySeparator = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.separator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "separator", r.separator, "")
	} else {
		var defaultValue string = ","
		r.separator = &defaultValue
	}
	if r.skipHeader != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipHeader", r.skipHeader, "")
	} else {
		var defaultValue bool = false
		r.skipHeader = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/text", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundGetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiSmsInboundGetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiSmsInboundGetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiSmsInboundGetObjectListGistAsCsvRequest) Auto(auto string) ApiSmsInboundGetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiSmsInboundGetObjectListGistAsCsvRequest) Describe(describe bool) ApiSmsInboundGetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiSmsInboundGetObjectListGistAsCsvRequest) Fields(fields string) ApiSmsInboundGetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiSmsInboundGetObjectListGistAsCsvRequest) Filter(filter string) ApiSmsInboundGetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiSmsInboundGetObjectListGistAsCsvRequest) Headless(headless bool) ApiSmsInboundGetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiSmsInboundGetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiSmsInboundGetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiSmsInboundGetObjectListGistAsCsvRequest) Locale(locale string) ApiSmsInboundGetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiSmsInboundGetObjectListGistAsCsvRequest) Order(order string) ApiSmsInboundGetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiSmsInboundGetObjectListGistAsCsvRequest) Page(page int32) ApiSmsInboundGetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiSmsInboundGetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiSmsInboundGetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiSmsInboundGetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiSmsInboundGetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiSmsInboundGetObjectListGistAsCsvRequest) References(references bool) ApiSmsInboundGetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiSmsInboundGetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiSmsInboundGetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiSmsInboundGetObjectListGistAsCsvRequest) Total(total bool) ApiSmsInboundGetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiSmsInboundGetObjectListGistAsCsvRequest) Translate(translate bool) ApiSmsInboundGetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiSmsInboundGetObjectListGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.SmsInboundGetObjectListGistAsCsvExecute(r)
}

/*
SmsInboundGetObjectListGistAsCsv Method for SmsInboundGetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsInboundGetObjectListGistAsCsvRequest
*/
func (a *MessagingAPIService) SmsInboundGetObjectListGistAsCsv(ctx context.Context) ApiSmsInboundGetObjectListGistAsCsvRequest {
	return ApiSmsInboundGetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *MessagingAPIService) SmsInboundGetObjectListGistAsCsvExecute(r ApiSmsInboundGetObjectListGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundGetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/gist.csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest) Auto(auto string) ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest) Describe(describe bool) ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest) Fields(fields string) ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest) Filter(filter string) ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest) Headless(headless bool) ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest) Locale(locale string) ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest) Order(order string) ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest) Page(page int32) ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest) References(references bool) ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest) Total(total bool) ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest) Translate(translate bool) ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest) Execute() (*SmsInboundGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.SmsInboundGetObjectListGistgetObjectListGistAsCsvExecute(r)
}

/*
SmsInboundGetObjectListGistgetObjectListGistAsCsv Method for SmsInboundGetObjectListGistgetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest
*/
func (a *MessagingAPIService) SmsInboundGetObjectListGistgetObjectListGistAsCsv(ctx context.Context) ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest {
	return ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SmsInboundGetObjectListGistGetObjectListGistAsCsv200Response
func (a *MessagingAPIService) SmsInboundGetObjectListGistgetObjectListGistAsCsvExecute(r ApiSmsInboundGetObjectListGistgetObjectListGistAsCsvRequest) (*SmsInboundGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SmsInboundGetObjectListGistGetObjectListGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundGetObjectListGistgetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/gist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundGetObjectPropertyRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	property     string
	uid          string
	fields       *[]string
	locale       *string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
	translate    *bool
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiSmsInboundGetObjectPropertyRequest) Fields(fields []string) ApiSmsInboundGetObjectPropertyRequest {
	r.fields = &fields
	return r
}

// [no description yet]
func (r ApiSmsInboundGetObjectPropertyRequest) Locale(locale string) ApiSmsInboundGetObjectPropertyRequest {
	r.locale = &locale
	return r
}

// Defines which page number to return.
func (r ApiSmsInboundGetObjectPropertyRequest) Page(page int32) ApiSmsInboundGetObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiSmsInboundGetObjectPropertyRequest) PageSize(pageSize int32) ApiSmsInboundGetObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiSmsInboundGetObjectPropertyRequest) Paging(paging bool) ApiSmsInboundGetObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiSmsInboundGetObjectPropertyRequest) RootJunction(rootJunction string) ApiSmsInboundGetObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiSmsInboundGetObjectPropertyRequest) Translate(translate bool) ApiSmsInboundGetObjectPropertyRequest {
	r.translate = &translate
	return r
}

func (r ApiSmsInboundGetObjectPropertyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SmsInboundGetObjectPropertyExecute(r)
}

/*
SmsInboundGetObjectProperty Method for SmsInboundGetObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsInboundGetObjectPropertyRequest
*/
func (a *MessagingAPIService) SmsInboundGetObjectProperty(ctx context.Context, property string, uid string) ApiSmsInboundGetObjectPropertyRequest {
	return ApiSmsInboundGetObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MessagingAPIService) SmsInboundGetObjectPropertyExecute(r ApiSmsInboundGetObjectPropertyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundGetObjectProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundGetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiSmsInboundGetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiSmsInboundGetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiSmsInboundGetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiSmsInboundGetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiSmsInboundGetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiSmsInboundGetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiSmsInboundGetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiSmsInboundGetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiSmsInboundGetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiSmsInboundGetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiSmsInboundGetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiSmsInboundGetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiSmsInboundGetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiSmsInboundGetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiSmsInboundGetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiSmsInboundGetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiSmsInboundGetObjectPropertyGistAsCsvRequest) Order(order string) ApiSmsInboundGetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiSmsInboundGetObjectPropertyGistAsCsvRequest) Page(page int32) ApiSmsInboundGetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiSmsInboundGetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiSmsInboundGetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiSmsInboundGetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiSmsInboundGetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiSmsInboundGetObjectPropertyGistAsCsvRequest) References(references bool) ApiSmsInboundGetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiSmsInboundGetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiSmsInboundGetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiSmsInboundGetObjectPropertyGistAsCsvRequest) Total(total bool) ApiSmsInboundGetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiSmsInboundGetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiSmsInboundGetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiSmsInboundGetObjectPropertyGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.SmsInboundGetObjectPropertyGistAsCsvExecute(r)
}

/*
SmsInboundGetObjectPropertyGistAsCsv Method for SmsInboundGetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsInboundGetObjectPropertyGistAsCsvRequest
*/
func (a *MessagingAPIService) SmsInboundGetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiSmsInboundGetObjectPropertyGistAsCsvRequest {
	return ApiSmsInboundGetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *MessagingAPIService) SmsInboundGetObjectPropertyGistAsCsvExecute(r ApiSmsInboundGetObjectPropertyGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundGetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/{uid}/{property}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Order(order string) ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Page(page int32) ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) References(references bool) ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Total(total bool) ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Execute() (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.SmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r)
}

/*
SmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsv Method for SmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest
*/
func (a *MessagingAPIService) SmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	return ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
func (a *MessagingAPIService) SmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r ApiSmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundGetObjectPropertyGistgetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/{uid}/{property}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundImportUnparsedSMSMessagesRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
}

func (r ApiSmsInboundImportUnparsedSMSMessagesRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsInboundImportUnparsedSMSMessagesExecute(r)
}

/*
SmsInboundImportUnparsedSMSMessages Method for SmsInboundImportUnparsedSMSMessages

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsInboundImportUnparsedSMSMessagesRequest
*/
func (a *MessagingAPIService) SmsInboundImportUnparsedSMSMessages(ctx context.Context) ApiSmsInboundImportUnparsedSMSMessagesRequest {
	return ApiSmsInboundImportUnparsedSMSMessagesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsInboundImportUnparsedSMSMessagesExecute(r ApiSmsInboundImportUnparsedSMSMessagesRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundImportUnparsedSMSMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/import"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundPatchObjectRequest struct {
	ctx                context.Context
	ApiService         *MessagingAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	jsonPatch          *JsonPatch
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiSmsInboundPatchObjectRequest) AtomicMode(atomicMode string) ApiSmsInboundPatchObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiSmsInboundPatchObjectRequest) FlushMode(flushMode string) ApiSmsInboundPatchObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiSmsInboundPatchObjectRequest) Identifier(identifier string) ApiSmsInboundPatchObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiSmsInboundPatchObjectRequest) ImportMode(importMode string) ApiSmsInboundPatchObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiSmsInboundPatchObjectRequest) ImportReportMode(importReportMode string) ApiSmsInboundPatchObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiSmsInboundPatchObjectRequest) ImportStrategy(importStrategy string) ApiSmsInboundPatchObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiSmsInboundPatchObjectRequest) MergeMode(mergeMode string) ApiSmsInboundPatchObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiSmsInboundPatchObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiSmsInboundPatchObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiSmsInboundPatchObjectRequest) Page(page int32) ApiSmsInboundPatchObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiSmsInboundPatchObjectRequest) PageSize(pageSize int32) ApiSmsInboundPatchObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiSmsInboundPatchObjectRequest) Paging(paging bool) ApiSmsInboundPatchObjectRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiSmsInboundPatchObjectRequest) PreheatMode(preheatMode string) ApiSmsInboundPatchObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiSmsInboundPatchObjectRequest) RootJunction(rootJunction string) ApiSmsInboundPatchObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiSmsInboundPatchObjectRequest) SkipSharing(skipSharing bool) ApiSmsInboundPatchObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiSmsInboundPatchObjectRequest) SkipTranslation(skipTranslation bool) ApiSmsInboundPatchObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiSmsInboundPatchObjectRequest) SkipValidation(skipValidation bool) ApiSmsInboundPatchObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiSmsInboundPatchObjectRequest) UserOverrideMode(userOverrideMode string) ApiSmsInboundPatchObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiSmsInboundPatchObjectRequest) JsonPatch(jsonPatch JsonPatch) ApiSmsInboundPatchObjectRequest {
	r.jsonPatch = &jsonPatch
	return r
}

func (r ApiSmsInboundPatchObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsInboundPatchObjectExecute(r)
}

/*
SmsInboundPatchObject Method for SmsInboundPatchObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsInboundPatchObjectRequest
*/
func (a *MessagingAPIService) SmsInboundPatchObject(ctx context.Context, uid string) ApiSmsInboundPatchObjectRequest {
	return ApiSmsInboundPatchObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsInboundPatchObjectExecute(r ApiSmsInboundPatchObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundPatchObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundPostJsonObjectRequest struct {
	ctx                context.Context
	ApiService         *MessagingAPIService
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	preheatMode        *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	incomingSms        *IncomingSms
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiSmsInboundPostJsonObjectRequest) AtomicMode(atomicMode string) ApiSmsInboundPostJsonObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiSmsInboundPostJsonObjectRequest) FlushMode(flushMode string) ApiSmsInboundPostJsonObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiSmsInboundPostJsonObjectRequest) Identifier(identifier string) ApiSmsInboundPostJsonObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiSmsInboundPostJsonObjectRequest) ImportMode(importMode string) ApiSmsInboundPostJsonObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiSmsInboundPostJsonObjectRequest) ImportReportMode(importReportMode string) ApiSmsInboundPostJsonObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiSmsInboundPostJsonObjectRequest) ImportStrategy(importStrategy string) ApiSmsInboundPostJsonObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiSmsInboundPostJsonObjectRequest) MergeMode(mergeMode string) ApiSmsInboundPostJsonObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiSmsInboundPostJsonObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiSmsInboundPostJsonObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiSmsInboundPostJsonObjectRequest) PreheatMode(preheatMode string) ApiSmsInboundPostJsonObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiSmsInboundPostJsonObjectRequest) SkipSharing(skipSharing bool) ApiSmsInboundPostJsonObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiSmsInboundPostJsonObjectRequest) SkipTranslation(skipTranslation bool) ApiSmsInboundPostJsonObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiSmsInboundPostJsonObjectRequest) SkipValidation(skipValidation bool) ApiSmsInboundPostJsonObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiSmsInboundPostJsonObjectRequest) UserOverrideMode(userOverrideMode string) ApiSmsInboundPostJsonObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiSmsInboundPostJsonObjectRequest) IncomingSms(incomingSms IncomingSms) ApiSmsInboundPostJsonObjectRequest {
	r.incomingSms = &incomingSms
	return r
}

func (r ApiSmsInboundPostJsonObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsInboundPostJsonObjectExecute(r)
}

/*
SmsInboundPostJsonObject Method for SmsInboundPostJsonObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsInboundPostJsonObjectRequest
*/
func (a *MessagingAPIService) SmsInboundPostJsonObject(ctx context.Context) ApiSmsInboundPostJsonObjectRequest {
	return ApiSmsInboundPostJsonObjectRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsInboundPostJsonObjectExecute(r ApiSmsInboundPostJsonObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundPostJsonObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/#postJsonObject"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.incomingSms
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundPostXmlObjectRequest struct {
	ctx                context.Context
	ApiService         *MessagingAPIService
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	preheatMode        *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	incomingSms        *IncomingSms
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiSmsInboundPostXmlObjectRequest) AtomicMode(atomicMode string) ApiSmsInboundPostXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiSmsInboundPostXmlObjectRequest) FlushMode(flushMode string) ApiSmsInboundPostXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiSmsInboundPostXmlObjectRequest) Identifier(identifier string) ApiSmsInboundPostXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiSmsInboundPostXmlObjectRequest) ImportMode(importMode string) ApiSmsInboundPostXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiSmsInboundPostXmlObjectRequest) ImportReportMode(importReportMode string) ApiSmsInboundPostXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiSmsInboundPostXmlObjectRequest) ImportStrategy(importStrategy string) ApiSmsInboundPostXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiSmsInboundPostXmlObjectRequest) MergeMode(mergeMode string) ApiSmsInboundPostXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiSmsInboundPostXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiSmsInboundPostXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiSmsInboundPostXmlObjectRequest) PreheatMode(preheatMode string) ApiSmsInboundPostXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiSmsInboundPostXmlObjectRequest) SkipSharing(skipSharing bool) ApiSmsInboundPostXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiSmsInboundPostXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiSmsInboundPostXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiSmsInboundPostXmlObjectRequest) SkipValidation(skipValidation bool) ApiSmsInboundPostXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiSmsInboundPostXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiSmsInboundPostXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiSmsInboundPostXmlObjectRequest) IncomingSms(incomingSms IncomingSms) ApiSmsInboundPostXmlObjectRequest {
	r.incomingSms = &incomingSms
	return r
}

func (r ApiSmsInboundPostXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsInboundPostXmlObjectExecute(r)
}

/*
SmsInboundPostXmlObject Method for SmsInboundPostXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsInboundPostXmlObjectRequest
*/
func (a *MessagingAPIService) SmsInboundPostXmlObject(ctx context.Context) ApiSmsInboundPostXmlObjectRequest {
	return ApiSmsInboundPostXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsInboundPostXmlObjectExecute(r ApiSmsInboundPostXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundPostXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/#postXmlObject"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.incomingSms
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundPutJsonObjectputXmlObjectRequest struct {
	ctx                context.Context
	ApiService         *MessagingAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	preheatMode        *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	incomingSms        *IncomingSms
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiSmsInboundPutJsonObjectputXmlObjectRequest) AtomicMode(atomicMode string) ApiSmsInboundPutJsonObjectputXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiSmsInboundPutJsonObjectputXmlObjectRequest) FlushMode(flushMode string) ApiSmsInboundPutJsonObjectputXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiSmsInboundPutJsonObjectputXmlObjectRequest) Identifier(identifier string) ApiSmsInboundPutJsonObjectputXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiSmsInboundPutJsonObjectputXmlObjectRequest) ImportMode(importMode string) ApiSmsInboundPutJsonObjectputXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiSmsInboundPutJsonObjectputXmlObjectRequest) ImportReportMode(importReportMode string) ApiSmsInboundPutJsonObjectputXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiSmsInboundPutJsonObjectputXmlObjectRequest) ImportStrategy(importStrategy string) ApiSmsInboundPutJsonObjectputXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiSmsInboundPutJsonObjectputXmlObjectRequest) MergeMode(mergeMode string) ApiSmsInboundPutJsonObjectputXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiSmsInboundPutJsonObjectputXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiSmsInboundPutJsonObjectputXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiSmsInboundPutJsonObjectputXmlObjectRequest) PreheatMode(preheatMode string) ApiSmsInboundPutJsonObjectputXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiSmsInboundPutJsonObjectputXmlObjectRequest) SkipSharing(skipSharing bool) ApiSmsInboundPutJsonObjectputXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiSmsInboundPutJsonObjectputXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiSmsInboundPutJsonObjectputXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiSmsInboundPutJsonObjectputXmlObjectRequest) SkipValidation(skipValidation bool) ApiSmsInboundPutJsonObjectputXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiSmsInboundPutJsonObjectputXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiSmsInboundPutJsonObjectputXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiSmsInboundPutJsonObjectputXmlObjectRequest) IncomingSms(incomingSms IncomingSms) ApiSmsInboundPutJsonObjectputXmlObjectRequest {
	r.incomingSms = &incomingSms
	return r
}

func (r ApiSmsInboundPutJsonObjectputXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsInboundPutJsonObjectputXmlObjectExecute(r)
}

/*
SmsInboundPutJsonObjectputXmlObject Method for SmsInboundPutJsonObjectputXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsInboundPutJsonObjectputXmlObjectRequest
*/
func (a *MessagingAPIService) SmsInboundPutJsonObjectputXmlObject(ctx context.Context, uid string) ApiSmsInboundPutJsonObjectputXmlObjectRequest {
	return ApiSmsInboundPutJsonObjectputXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsInboundPutJsonObjectputXmlObjectExecute(r ApiSmsInboundPutJsonObjectputXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundPutJsonObjectputXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.incomingSms
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundReceiveSMSMessageRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	message      *string
	originator   *string
	gateway      *string
	receivedTime *time.Time
}

// [no description yet]
func (r ApiSmsInboundReceiveSMSMessageRequest) Message(message string) ApiSmsInboundReceiveSMSMessageRequest {
	r.message = &message
	return r
}

// [no description yet]
func (r ApiSmsInboundReceiveSMSMessageRequest) Originator(originator string) ApiSmsInboundReceiveSMSMessageRequest {
	r.originator = &originator
	return r
}

// [no description yet]
func (r ApiSmsInboundReceiveSMSMessageRequest) Gateway(gateway string) ApiSmsInboundReceiveSMSMessageRequest {
	r.gateway = &gateway
	return r
}

// [no description yet]
func (r ApiSmsInboundReceiveSMSMessageRequest) ReceivedTime(receivedTime time.Time) ApiSmsInboundReceiveSMSMessageRequest {
	r.receivedTime = &receivedTime
	return r
}

func (r ApiSmsInboundReceiveSMSMessageRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsInboundReceiveSMSMessageExecute(r)
}

/*
SmsInboundReceiveSMSMessage Method for SmsInboundReceiveSMSMessage

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsInboundReceiveSMSMessageRequest
*/
func (a *MessagingAPIService) SmsInboundReceiveSMSMessage(ctx context.Context) ApiSmsInboundReceiveSMSMessageRequest {
	return ApiSmsInboundReceiveSMSMessageRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsInboundReceiveSMSMessageExecute(r ApiSmsInboundReceiveSMSMessageRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundReceiveSMSMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.message == nil {
		return localVarReturnValue, nil, reportError("message is required and must be specified")
	}
	if r.originator == nil {
		return localVarReturnValue, nil, reportError("originator is required and must be specified")
	}

	if r.gateway != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gateway", r.gateway, "")
	} else {
		var defaultValue string = "Unknown"
		r.gateway = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "message", r.message, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "originator", r.originator, "")
	if r.receivedTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "receivedTime", r.receivedTime, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundRemoveAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
}

func (r ApiSmsInboundRemoveAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsInboundRemoveAsFavoriteExecute(r)
}

/*
SmsInboundRemoveAsFavorite Method for SmsInboundRemoveAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsInboundRemoveAsFavoriteRequest
*/
func (a *MessagingAPIService) SmsInboundRemoveAsFavorite(ctx context.Context, uid string) ApiSmsInboundRemoveAsFavoriteRequest {
	return ApiSmsInboundRemoveAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsInboundRemoveAsFavoriteExecute(r ApiSmsInboundRemoveAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundRemoveAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *MessagingAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiSmsInboundReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiSmsInboundReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiSmsInboundReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsInboundReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r)
}

/*
SmsInboundReplaceCollectionItemsJsonreplaceCollectionItemsXml Method for SmsInboundReplaceCollectionItemsJsonreplaceCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsInboundReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest
*/
func (a *MessagingAPIService) SmsInboundReplaceCollectionItemsJsonreplaceCollectionItemsXml(ctx context.Context, property string, uid string) ApiSmsInboundReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	return ApiSmsInboundReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsInboundReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r ApiSmsInboundReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundReplaceCollectionItemsJsonreplaceCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundReplaceTranslationsRequest struct {
	ctx                                             context.Context
	ApiService                                      *MessagingAPIService
	uid                                             string
	aggregateDataExchangeReplaceTranslationsRequest *AggregateDataExchangeReplaceTranslationsRequest
}

// [no description yet]
func (r ApiSmsInboundReplaceTranslationsRequest) AggregateDataExchangeReplaceTranslationsRequest(aggregateDataExchangeReplaceTranslationsRequest AggregateDataExchangeReplaceTranslationsRequest) ApiSmsInboundReplaceTranslationsRequest {
	r.aggregateDataExchangeReplaceTranslationsRequest = &aggregateDataExchangeReplaceTranslationsRequest
	return r
}

func (r ApiSmsInboundReplaceTranslationsRequest) Execute() (*http.Response, error) {
	return r.ApiService.SmsInboundReplaceTranslationsExecute(r)
}

/*
SmsInboundReplaceTranslations Method for SmsInboundReplaceTranslations

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsInboundReplaceTranslationsRequest
*/
func (a *MessagingAPIService) SmsInboundReplaceTranslations(ctx context.Context, uid string) ApiSmsInboundReplaceTranslationsRequest {
	return ApiSmsInboundReplaceTranslationsRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *MessagingAPIService) SmsInboundReplaceTranslationsExecute(r ApiSmsInboundReplaceTranslationsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundReplaceTranslations")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/{uid}/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateDataExchangeReplaceTranslationsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSmsInboundSetAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
}

func (r ApiSmsInboundSetAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsInboundSetAsFavoriteExecute(r)
}

/*
SmsInboundSetAsFavorite Method for SmsInboundSetAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsInboundSetAsFavoriteRequest
*/
func (a *MessagingAPIService) SmsInboundSetAsFavorite(ctx context.Context, uid string) ApiSmsInboundSetAsFavoriteRequest {
	return ApiSmsInboundSetAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsInboundSetAsFavoriteExecute(r ApiSmsInboundSetAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundSetAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundSetSharingRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
	sharing    *Sharing
}

// [no description yet]
func (r ApiSmsInboundSetSharingRequest) Sharing(sharing Sharing) ApiSmsInboundSetSharingRequest {
	r.sharing = &sharing
	return r
}

func (r ApiSmsInboundSetSharingRequest) Execute() (*http.Response, error) {
	return r.ApiService.SmsInboundSetSharingExecute(r)
}

/*
SmsInboundSetSharing Method for SmsInboundSetSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsInboundSetSharingRequest
*/
func (a *MessagingAPIService) SmsInboundSetSharing(ctx context.Context, uid string) ApiSmsInboundSetSharingRequest {
	return ApiSmsInboundSetSharingRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *MessagingAPIService) SmsInboundSetSharingExecute(r ApiSmsInboundSetSharingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundSetSharing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/{uid}/sharing"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharing
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSmsInboundSubscribeRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
}

func (r ApiSmsInboundSubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsInboundSubscribeExecute(r)
}

/*
SmsInboundSubscribe Method for SmsInboundSubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsInboundSubscribeRequest
*/
func (a *MessagingAPIService) SmsInboundSubscribe(ctx context.Context, uid string) ApiSmsInboundSubscribeRequest {
	return ApiSmsInboundSubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsInboundSubscribeExecute(r ApiSmsInboundSubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundSubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundUnsubscribeRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
}

func (r ApiSmsInboundUnsubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsInboundUnsubscribeExecute(r)
}

/*
SmsInboundUnsubscribe Method for SmsInboundUnsubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsInboundUnsubscribeRequest
*/
func (a *MessagingAPIService) SmsInboundUnsubscribe(ctx context.Context, uid string) ApiSmsInboundUnsubscribeRequest {
	return ApiSmsInboundUnsubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsInboundUnsubscribeExecute(r ApiSmsInboundUnsubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundUnsubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsInboundUpdateObjectPropertyRequest struct {
	ctx                context.Context
	ApiService         *MessagingAPIService
	property           string
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	incomingSms        *IncomingSms
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiSmsInboundUpdateObjectPropertyRequest) AtomicMode(atomicMode string) ApiSmsInboundUpdateObjectPropertyRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiSmsInboundUpdateObjectPropertyRequest) FlushMode(flushMode string) ApiSmsInboundUpdateObjectPropertyRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiSmsInboundUpdateObjectPropertyRequest) Identifier(identifier string) ApiSmsInboundUpdateObjectPropertyRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiSmsInboundUpdateObjectPropertyRequest) ImportMode(importMode string) ApiSmsInboundUpdateObjectPropertyRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiSmsInboundUpdateObjectPropertyRequest) ImportReportMode(importReportMode string) ApiSmsInboundUpdateObjectPropertyRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiSmsInboundUpdateObjectPropertyRequest) ImportStrategy(importStrategy string) ApiSmsInboundUpdateObjectPropertyRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiSmsInboundUpdateObjectPropertyRequest) MergeMode(mergeMode string) ApiSmsInboundUpdateObjectPropertyRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiSmsInboundUpdateObjectPropertyRequest) MetadataSyncImport(metadataSyncImport bool) ApiSmsInboundUpdateObjectPropertyRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiSmsInboundUpdateObjectPropertyRequest) Page(page int32) ApiSmsInboundUpdateObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiSmsInboundUpdateObjectPropertyRequest) PageSize(pageSize int32) ApiSmsInboundUpdateObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiSmsInboundUpdateObjectPropertyRequest) Paging(paging bool) ApiSmsInboundUpdateObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiSmsInboundUpdateObjectPropertyRequest) PreheatMode(preheatMode string) ApiSmsInboundUpdateObjectPropertyRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiSmsInboundUpdateObjectPropertyRequest) RootJunction(rootJunction string) ApiSmsInboundUpdateObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiSmsInboundUpdateObjectPropertyRequest) SkipSharing(skipSharing bool) ApiSmsInboundUpdateObjectPropertyRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiSmsInboundUpdateObjectPropertyRequest) SkipTranslation(skipTranslation bool) ApiSmsInboundUpdateObjectPropertyRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiSmsInboundUpdateObjectPropertyRequest) SkipValidation(skipValidation bool) ApiSmsInboundUpdateObjectPropertyRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiSmsInboundUpdateObjectPropertyRequest) UserOverrideMode(userOverrideMode string) ApiSmsInboundUpdateObjectPropertyRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiSmsInboundUpdateObjectPropertyRequest) IncomingSms(incomingSms IncomingSms) ApiSmsInboundUpdateObjectPropertyRequest {
	r.incomingSms = &incomingSms
	return r
}

func (r ApiSmsInboundUpdateObjectPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.SmsInboundUpdateObjectPropertyExecute(r)
}

/*
SmsInboundUpdateObjectProperty Method for SmsInboundUpdateObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsInboundUpdateObjectPropertyRequest
*/
func (a *MessagingAPIService) SmsInboundUpdateObjectProperty(ctx context.Context, property string, uid string) ApiSmsInboundUpdateObjectPropertyRequest {
	return ApiSmsInboundUpdateObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
func (a *MessagingAPIService) SmsInboundUpdateObjectPropertyExecute(r ApiSmsInboundUpdateObjectPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsInboundUpdateObjectProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/inbound/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.incomingSms
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSmsOutboundAddCollectionItemRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiSmsOutboundAddCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsOutboundAddCollectionItemExecute(r)
}

/*
SmsOutboundAddCollectionItem Method for SmsOutboundAddCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsOutboundAddCollectionItemRequest
*/
func (a *MessagingAPIService) SmsOutboundAddCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiSmsOutboundAddCollectionItemRequest {
	return ApiSmsOutboundAddCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsOutboundAddCollectionItemExecute(r ApiSmsOutboundAddCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundAddCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundAddCollectionItemsJsonaddCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *MessagingAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiSmsOutboundAddCollectionItemsJsonaddCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiSmsOutboundAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiSmsOutboundAddCollectionItemsJsonaddCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsOutboundAddCollectionItemsJsonaddCollectionItemsXmlExecute(r)
}

/*
SmsOutboundAddCollectionItemsJsonaddCollectionItemsXml Method for SmsOutboundAddCollectionItemsJsonaddCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsOutboundAddCollectionItemsJsonaddCollectionItemsXmlRequest
*/
func (a *MessagingAPIService) SmsOutboundAddCollectionItemsJsonaddCollectionItemsXml(ctx context.Context, property string, uid string) ApiSmsOutboundAddCollectionItemsJsonaddCollectionItemsXmlRequest {
	return ApiSmsOutboundAddCollectionItemsJsonaddCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsOutboundAddCollectionItemsJsonaddCollectionItemsXmlExecute(r ApiSmsOutboundAddCollectionItemsJsonaddCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundAddCollectionItemsJsonaddCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundBulkSharingRequest struct {
	ctx                context.Context
	ApiService         *MessagingAPIService
	atomic             *bool
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	bulkJsonPatch      *BulkJsonPatch
}

// [no description yet]
func (r ApiSmsOutboundBulkSharingRequest) Atomic(atomic bool) ApiSmsOutboundBulkSharingRequest {
	r.atomic = &atomic
	return r
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiSmsOutboundBulkSharingRequest) AtomicMode(atomicMode string) ApiSmsOutboundBulkSharingRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiSmsOutboundBulkSharingRequest) FlushMode(flushMode string) ApiSmsOutboundBulkSharingRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiSmsOutboundBulkSharingRequest) Identifier(identifier string) ApiSmsOutboundBulkSharingRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiSmsOutboundBulkSharingRequest) ImportMode(importMode string) ApiSmsOutboundBulkSharingRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiSmsOutboundBulkSharingRequest) ImportReportMode(importReportMode string) ApiSmsOutboundBulkSharingRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiSmsOutboundBulkSharingRequest) ImportStrategy(importStrategy string) ApiSmsOutboundBulkSharingRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiSmsOutboundBulkSharingRequest) MergeMode(mergeMode string) ApiSmsOutboundBulkSharingRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiSmsOutboundBulkSharingRequest) MetadataSyncImport(metadataSyncImport bool) ApiSmsOutboundBulkSharingRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiSmsOutboundBulkSharingRequest) Page(page int32) ApiSmsOutboundBulkSharingRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiSmsOutboundBulkSharingRequest) PageSize(pageSize int32) ApiSmsOutboundBulkSharingRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiSmsOutboundBulkSharingRequest) Paging(paging bool) ApiSmsOutboundBulkSharingRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiSmsOutboundBulkSharingRequest) PreheatMode(preheatMode string) ApiSmsOutboundBulkSharingRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiSmsOutboundBulkSharingRequest) RootJunction(rootJunction string) ApiSmsOutboundBulkSharingRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiSmsOutboundBulkSharingRequest) SkipSharing(skipSharing bool) ApiSmsOutboundBulkSharingRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiSmsOutboundBulkSharingRequest) SkipTranslation(skipTranslation bool) ApiSmsOutboundBulkSharingRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiSmsOutboundBulkSharingRequest) SkipValidation(skipValidation bool) ApiSmsOutboundBulkSharingRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiSmsOutboundBulkSharingRequest) UserOverrideMode(userOverrideMode string) ApiSmsOutboundBulkSharingRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiSmsOutboundBulkSharingRequest) BulkJsonPatch(bulkJsonPatch BulkJsonPatch) ApiSmsOutboundBulkSharingRequest {
	r.bulkJsonPatch = &bulkJsonPatch
	return r
}

func (r ApiSmsOutboundBulkSharingRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsOutboundBulkSharingExecute(r)
}

/*
SmsOutboundBulkSharing Method for SmsOutboundBulkSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsOutboundBulkSharingRequest
*/
func (a *MessagingAPIService) SmsOutboundBulkSharing(ctx context.Context) ApiSmsOutboundBulkSharingRequest {
	return ApiSmsOutboundBulkSharingRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsOutboundBulkSharingExecute(r ApiSmsOutboundBulkSharingRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundBulkSharing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/sharing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomic", r.atomic, "")
	} else {
		var defaultValue bool = false
		r.atomic = &defaultValue
	}
	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkJsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundDeleteCollectionItemRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	itemId     string
	property   string
	uid        string
}

func (r ApiSmsOutboundDeleteCollectionItemRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsOutboundDeleteCollectionItemExecute(r)
}

/*
SmsOutboundDeleteCollectionItem Method for SmsOutboundDeleteCollectionItem

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId [no description yet]
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsOutboundDeleteCollectionItemRequest
*/
func (a *MessagingAPIService) SmsOutboundDeleteCollectionItem(ctx context.Context, itemId string, property string, uid string) ApiSmsOutboundDeleteCollectionItemRequest {
	return ApiSmsOutboundDeleteCollectionItemRequest{
		ApiService: a,
		ctx:        ctx,
		itemId:     itemId,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsOutboundDeleteCollectionItemExecute(r ApiSmsOutboundDeleteCollectionItemRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundDeleteCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/{uid}/{property}/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *MessagingAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiSmsOutboundDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiSmsOutboundDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiSmsOutboundDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsOutboundDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r)
}

/*
SmsOutboundDeleteCollectionItemsJsondeleteCollectionItemsXml Method for SmsOutboundDeleteCollectionItemsJsondeleteCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsOutboundDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest
*/
func (a *MessagingAPIService) SmsOutboundDeleteCollectionItemsJsondeleteCollectionItemsXml(ctx context.Context, property string, uid string) ApiSmsOutboundDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest {
	return ApiSmsOutboundDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsOutboundDeleteCollectionItemsJsondeleteCollectionItemsXmlExecute(r ApiSmsOutboundDeleteCollectionItemsJsondeleteCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundDeleteCollectionItemsJsondeleteCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundDeleteObjectdeleteOutboundMessageRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
}

func (r ApiSmsOutboundDeleteObjectdeleteOutboundMessageRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsOutboundDeleteObjectdeleteOutboundMessageExecute(r)
}

/*
SmsOutboundDeleteObjectdeleteOutboundMessage Method for SmsOutboundDeleteObjectdeleteOutboundMessage

Deletes the OutboundSms provided by ID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsOutboundDeleteObjectdeleteOutboundMessageRequest
*/
func (a *MessagingAPIService) SmsOutboundDeleteObjectdeleteOutboundMessage(ctx context.Context, uid string) ApiSmsOutboundDeleteObjectdeleteOutboundMessageRequest {
	return ApiSmsOutboundDeleteObjectdeleteOutboundMessageRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsOutboundDeleteObjectdeleteOutboundMessageExecute(r ApiSmsOutboundDeleteObjectdeleteOutboundMessageRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundDeleteObjectdeleteOutboundMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundDeleteOutboundMessagesRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	ids        *[]string
}

// [no description yet]
func (r ApiSmsOutboundDeleteOutboundMessagesRequest) Ids(ids []string) ApiSmsOutboundDeleteOutboundMessagesRequest {
	r.ids = &ids
	return r
}

func (r ApiSmsOutboundDeleteOutboundMessagesRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsOutboundDeleteOutboundMessagesExecute(r)
}

/*
SmsOutboundDeleteOutboundMessages Method for SmsOutboundDeleteOutboundMessages

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsOutboundDeleteOutboundMessagesRequest
*/
func (a *MessagingAPIService) SmsOutboundDeleteOutboundMessages(ctx context.Context) ApiSmsOutboundDeleteOutboundMessagesRequest {
	return ApiSmsOutboundDeleteOutboundMessagesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsOutboundDeleteOutboundMessagesExecute(r ApiSmsOutboundDeleteOutboundMessagesRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundDeleteOutboundMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	{
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundGetObjectRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	uid          string
	fields       *[]string
	filter       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiSmsOutboundGetObjectRequest) Fields(fields []string) ApiSmsOutboundGetObjectRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiSmsOutboundGetObjectRequest) Filter(filter []string) ApiSmsOutboundGetObjectRequest {
	r.filter = &filter
	return r
}

// Defines which page number to return.
func (r ApiSmsOutboundGetObjectRequest) Page(page int32) ApiSmsOutboundGetObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiSmsOutboundGetObjectRequest) PageSize(pageSize int32) ApiSmsOutboundGetObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiSmsOutboundGetObjectRequest) Paging(paging bool) ApiSmsOutboundGetObjectRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiSmsOutboundGetObjectRequest) RootJunction(rootJunction string) ApiSmsOutboundGetObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiSmsOutboundGetObjectRequest) Execute() (*OutboundSms, *http.Response, error) {
	return r.ApiService.SmsOutboundGetObjectExecute(r)
}

/*
SmsOutboundGetObject Method for SmsOutboundGetObject

View a OutboundSms

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsOutboundGetObjectRequest
*/
func (a *MessagingAPIService) SmsOutboundGetObject(ctx context.Context, uid string) ApiSmsOutboundGetObjectRequest {
	return ApiSmsOutboundGetObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return OutboundSms
func (a *MessagingAPIService) SmsOutboundGetObjectExecute(r ApiSmsOutboundGetObjectRequest) (*OutboundSms, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OutboundSms
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundGetObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundGetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiSmsOutboundGetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiSmsOutboundGetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiSmsOutboundGetObjectGistAsCsvRequest) Auto(auto string) ApiSmsOutboundGetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiSmsOutboundGetObjectGistAsCsvRequest) Describe(describe bool) ApiSmsOutboundGetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiSmsOutboundGetObjectGistAsCsvRequest) Fields(fields string) ApiSmsOutboundGetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiSmsOutboundGetObjectGistAsCsvRequest) Filter(filter string) ApiSmsOutboundGetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiSmsOutboundGetObjectGistAsCsvRequest) Headless(headless bool) ApiSmsOutboundGetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiSmsOutboundGetObjectGistAsCsvRequest) Inverse(inverse bool) ApiSmsOutboundGetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiSmsOutboundGetObjectGistAsCsvRequest) Locale(locale string) ApiSmsOutboundGetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiSmsOutboundGetObjectGistAsCsvRequest) Order(order string) ApiSmsOutboundGetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiSmsOutboundGetObjectGistAsCsvRequest) Page(page int32) ApiSmsOutboundGetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiSmsOutboundGetObjectGistAsCsvRequest) PageListName(pageListName string) ApiSmsOutboundGetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiSmsOutboundGetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiSmsOutboundGetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiSmsOutboundGetObjectGistAsCsvRequest) References(references bool) ApiSmsOutboundGetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiSmsOutboundGetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiSmsOutboundGetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiSmsOutboundGetObjectGistAsCsvRequest) Total(total bool) ApiSmsOutboundGetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiSmsOutboundGetObjectGistAsCsvRequest) Translate(translate bool) ApiSmsOutboundGetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiSmsOutboundGetObjectGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.SmsOutboundGetObjectGistAsCsvExecute(r)
}

/*
SmsOutboundGetObjectGistAsCsv Method for SmsOutboundGetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsOutboundGetObjectGistAsCsvRequest
*/
func (a *MessagingAPIService) SmsOutboundGetObjectGistAsCsv(ctx context.Context, uid string) ApiSmsOutboundGetObjectGistAsCsvRequest {
	return ApiSmsOutboundGetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *MessagingAPIService) SmsOutboundGetObjectGistAsCsvExecute(r ApiSmsOutboundGetObjectGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundGetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/{uid}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest) Auto(auto string) ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest) Describe(describe bool) ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest) Fields(fields string) ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest) Filter(filter string) ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest) Headless(headless bool) ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest) Inverse(inverse bool) ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest) Locale(locale string) ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest) Order(order string) ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest) Page(page int32) ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest) PageListName(pageListName string) ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest) PageSize(pageSize int32) ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest) References(references bool) ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest) RootJunction(rootJunction string) ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest) Total(total bool) ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest) Translate(translate bool) ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SmsOutboundGetObjectGistgetObjectGistAsCsvExecute(r)
}

/*
SmsOutboundGetObjectGistgetObjectGistAsCsv Method for SmsOutboundGetObjectGistgetObjectGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest
*/
func (a *MessagingAPIService) SmsOutboundGetObjectGistgetObjectGistAsCsv(ctx context.Context, uid string) ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest {
	return ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MessagingAPIService) SmsOutboundGetObjectGistgetObjectGistAsCsvExecute(r ApiSmsOutboundGetObjectGistgetObjectGistAsCsvRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundGetObjectGistgetObjectGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/{uid}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundGetObjectListRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	fields       *[]string
	filter       *[]string
	orders       *[]string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
}

// &#x60;&lt;field-name&gt;[,&lt;field-name&gt;...]&#x60;
func (r ApiSmsOutboundGetObjectListRequest) Fields(fields []string) ApiSmsOutboundGetObjectListRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiSmsOutboundGetObjectListRequest) Filter(filter []string) ApiSmsOutboundGetObjectListRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiSmsOutboundGetObjectListRequest) Orders(orders []string) ApiSmsOutboundGetObjectListRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiSmsOutboundGetObjectListRequest) Page(page int32) ApiSmsOutboundGetObjectListRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiSmsOutboundGetObjectListRequest) PageSize(pageSize int32) ApiSmsOutboundGetObjectListRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiSmsOutboundGetObjectListRequest) Paging(paging bool) ApiSmsOutboundGetObjectListRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiSmsOutboundGetObjectListRequest) RootJunction(rootJunction string) ApiSmsOutboundGetObjectListRequest {
	r.rootJunction = &rootJunction
	return r
}

func (r ApiSmsOutboundGetObjectListRequest) Execute() (*SmsOutboundGetObjectList200Response, *http.Response, error) {
	return r.ApiService.SmsOutboundGetObjectListExecute(r)
}

/*
SmsOutboundGetObjectList Method for SmsOutboundGetObjectList

List all OutboundSmss

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsOutboundGetObjectListRequest
*/
func (a *MessagingAPIService) SmsOutboundGetObjectList(ctx context.Context) ApiSmsOutboundGetObjectListRequest {
	return ApiSmsOutboundGetObjectListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SmsOutboundGetObjectList200Response
func (a *MessagingAPIService) SmsOutboundGetObjectListExecute(r ApiSmsOutboundGetObjectListRequest) (*SmsOutboundGetObjectList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SmsOutboundGetObjectList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundGetObjectList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundGetObjectListCsvRequest struct {
	ctx            context.Context
	ApiService     *MessagingAPIService
	arraySeparator *string
	fields         *[]string
	filter         *[]string
	orders         *[]string
	page           *int32
	pageSize       *int32
	paging         *bool
	rootJunction   *string
	separator      *string
	skipHeader     *bool
}

// [no description yet]
func (r ApiSmsOutboundGetObjectListCsvRequest) ArraySeparator(arraySeparator string) ApiSmsOutboundGetObjectListCsvRequest {
	r.arraySeparator = &arraySeparator
	return r
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiSmsOutboundGetObjectListCsvRequest) Fields(fields []string) ApiSmsOutboundGetObjectListCsvRequest {
	r.fields = &fields
	return r
}

// Apply filter operations to the returned list of metadata.    See [Metadata-object-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_object_filter).
func (r ApiSmsOutboundGetObjectListCsvRequest) Filter(filter []string) ApiSmsOutboundGetObjectListCsvRequest {
	r.filter = &filter
	return r
}

// [no description yet]
func (r ApiSmsOutboundGetObjectListCsvRequest) Orders(orders []string) ApiSmsOutboundGetObjectListCsvRequest {
	r.orders = &orders
	return r
}

// Defines which page number to return.
func (r ApiSmsOutboundGetObjectListCsvRequest) Page(page int32) ApiSmsOutboundGetObjectListCsvRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiSmsOutboundGetObjectListCsvRequest) PageSize(pageSize int32) ApiSmsOutboundGetObjectListCsvRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiSmsOutboundGetObjectListCsvRequest) Paging(paging bool) ApiSmsOutboundGetObjectListCsvRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiSmsOutboundGetObjectListCsvRequest) RootJunction(rootJunction string) ApiSmsOutboundGetObjectListCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiSmsOutboundGetObjectListCsvRequest) Separator(separator string) ApiSmsOutboundGetObjectListCsvRequest {
	r.separator = &separator
	return r
}

// [no description yet]
func (r ApiSmsOutboundGetObjectListCsvRequest) SkipHeader(skipHeader bool) ApiSmsOutboundGetObjectListCsvRequest {
	r.skipHeader = &skipHeader
	return r
}

func (r ApiSmsOutboundGetObjectListCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.SmsOutboundGetObjectListCsvExecute(r)
}

/*
SmsOutboundGetObjectListCsv Method for SmsOutboundGetObjectListCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsOutboundGetObjectListCsvRequest
*/
func (a *MessagingAPIService) SmsOutboundGetObjectListCsv(ctx context.Context) ApiSmsOutboundGetObjectListCsvRequest {
	return ApiSmsOutboundGetObjectListCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *MessagingAPIService) SmsOutboundGetObjectListCsvExecute(r ApiSmsOutboundGetObjectListCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundGetObjectListCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/#getObjectListCsv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.arraySeparator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arraySeparator", r.arraySeparator, "")
	} else {
		var defaultValue string = ";"
		r.arraySeparator = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		t := *r.filter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter", t, "multi")
		}
	}
	if r.orders != nil {
		t := *r.orders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orders", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orders", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.separator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "separator", r.separator, "")
	} else {
		var defaultValue string = ","
		r.separator = &defaultValue
	}
	if r.skipHeader != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipHeader", r.skipHeader, "")
	} else {
		var defaultValue bool = false
		r.skipHeader = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/text", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundGetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiSmsOutboundGetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiSmsOutboundGetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiSmsOutboundGetObjectListGistAsCsvRequest) Auto(auto string) ApiSmsOutboundGetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiSmsOutboundGetObjectListGistAsCsvRequest) Describe(describe bool) ApiSmsOutboundGetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiSmsOutboundGetObjectListGistAsCsvRequest) Fields(fields string) ApiSmsOutboundGetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiSmsOutboundGetObjectListGistAsCsvRequest) Filter(filter string) ApiSmsOutboundGetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiSmsOutboundGetObjectListGistAsCsvRequest) Headless(headless bool) ApiSmsOutboundGetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiSmsOutboundGetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiSmsOutboundGetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiSmsOutboundGetObjectListGistAsCsvRequest) Locale(locale string) ApiSmsOutboundGetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiSmsOutboundGetObjectListGistAsCsvRequest) Order(order string) ApiSmsOutboundGetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiSmsOutboundGetObjectListGistAsCsvRequest) Page(page int32) ApiSmsOutboundGetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiSmsOutboundGetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiSmsOutboundGetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiSmsOutboundGetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiSmsOutboundGetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiSmsOutboundGetObjectListGistAsCsvRequest) References(references bool) ApiSmsOutboundGetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiSmsOutboundGetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiSmsOutboundGetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiSmsOutboundGetObjectListGistAsCsvRequest) Total(total bool) ApiSmsOutboundGetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiSmsOutboundGetObjectListGistAsCsvRequest) Translate(translate bool) ApiSmsOutboundGetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiSmsOutboundGetObjectListGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.SmsOutboundGetObjectListGistAsCsvExecute(r)
}

/*
SmsOutboundGetObjectListGistAsCsv Method for SmsOutboundGetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsOutboundGetObjectListGistAsCsvRequest
*/
func (a *MessagingAPIService) SmsOutboundGetObjectListGistAsCsv(ctx context.Context) ApiSmsOutboundGetObjectListGistAsCsvRequest {
	return ApiSmsOutboundGetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *MessagingAPIService) SmsOutboundGetObjectListGistAsCsvExecute(r ApiSmsOutboundGetObjectListGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundGetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/gist.csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest) Auto(auto string) ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest) Describe(describe bool) ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest) Fields(fields string) ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest) Filter(filter string) ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest) Headless(headless bool) ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest) Inverse(inverse bool) ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest) Locale(locale string) ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest) Order(order string) ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest) Page(page int32) ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest) PageListName(pageListName string) ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest) PageSize(pageSize int32) ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest) References(references bool) ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest) RootJunction(rootJunction string) ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest) Total(total bool) ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest) Translate(translate bool) ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest) Execute() (*SmsOutboundGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.SmsOutboundGetObjectListGistgetObjectListGistAsCsvExecute(r)
}

/*
SmsOutboundGetObjectListGistgetObjectListGistAsCsv Method for SmsOutboundGetObjectListGistgetObjectListGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest
*/
func (a *MessagingAPIService) SmsOutboundGetObjectListGistgetObjectListGistAsCsv(ctx context.Context) ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest {
	return ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SmsOutboundGetObjectListGistGetObjectListGistAsCsv200Response
func (a *MessagingAPIService) SmsOutboundGetObjectListGistgetObjectListGistAsCsvExecute(r ApiSmsOutboundGetObjectListGistgetObjectListGistAsCsvRequest) (*SmsOutboundGetObjectListGistGetObjectListGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SmsOutboundGetObjectListGistGetObjectListGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundGetObjectListGistgetObjectListGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/gist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundGetObjectPropertyRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	property     string
	uid          string
	fields       *[]string
	locale       *string
	page         *int32
	pageSize     *int32
	paging       *bool
	rootJunction *string
	translate    *bool
}

// Limit the response to specific field(s).    See [Metadata-field-filter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata.html#webapi_metadata_field_filter).
func (r ApiSmsOutboundGetObjectPropertyRequest) Fields(fields []string) ApiSmsOutboundGetObjectPropertyRequest {
	r.fields = &fields
	return r
}

// [no description yet]
func (r ApiSmsOutboundGetObjectPropertyRequest) Locale(locale string) ApiSmsOutboundGetObjectPropertyRequest {
	r.locale = &locale
	return r
}

// Defines which page number to return.
func (r ApiSmsOutboundGetObjectPropertyRequest) Page(page int32) ApiSmsOutboundGetObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiSmsOutboundGetObjectPropertyRequest) PageSize(pageSize int32) ApiSmsOutboundGetObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiSmsOutboundGetObjectPropertyRequest) Paging(paging bool) ApiSmsOutboundGetObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiSmsOutboundGetObjectPropertyRequest) RootJunction(rootJunction string) ApiSmsOutboundGetObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// [no description yet]
func (r ApiSmsOutboundGetObjectPropertyRequest) Translate(translate bool) ApiSmsOutboundGetObjectPropertyRequest {
	r.translate = &translate
	return r
}

func (r ApiSmsOutboundGetObjectPropertyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SmsOutboundGetObjectPropertyExecute(r)
}

/*
SmsOutboundGetObjectProperty Method for SmsOutboundGetObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsOutboundGetObjectPropertyRequest
*/
func (a *MessagingAPIService) SmsOutboundGetObjectProperty(ctx context.Context, property string, uid string) ApiSmsOutboundGetObjectPropertyRequest {
	return ApiSmsOutboundGetObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MessagingAPIService) SmsOutboundGetObjectPropertyExecute(r ApiSmsOutboundGetObjectPropertyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundGetObjectProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundGetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiSmsOutboundGetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiSmsOutboundGetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiSmsOutboundGetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiSmsOutboundGetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiSmsOutboundGetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiSmsOutboundGetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiSmsOutboundGetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiSmsOutboundGetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiSmsOutboundGetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiSmsOutboundGetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiSmsOutboundGetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiSmsOutboundGetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiSmsOutboundGetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiSmsOutboundGetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiSmsOutboundGetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiSmsOutboundGetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiSmsOutboundGetObjectPropertyGistAsCsvRequest) Order(order string) ApiSmsOutboundGetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiSmsOutboundGetObjectPropertyGistAsCsvRequest) Page(page int32) ApiSmsOutboundGetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiSmsOutboundGetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiSmsOutboundGetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiSmsOutboundGetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiSmsOutboundGetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiSmsOutboundGetObjectPropertyGistAsCsvRequest) References(references bool) ApiSmsOutboundGetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiSmsOutboundGetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiSmsOutboundGetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiSmsOutboundGetObjectPropertyGistAsCsvRequest) Total(total bool) ApiSmsOutboundGetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiSmsOutboundGetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiSmsOutboundGetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiSmsOutboundGetObjectPropertyGistAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.SmsOutboundGetObjectPropertyGistAsCsvExecute(r)
}

/*
SmsOutboundGetObjectPropertyGistAsCsv Method for SmsOutboundGetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsOutboundGetObjectPropertyGistAsCsvRequest
*/
func (a *MessagingAPIService) SmsOutboundGetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiSmsOutboundGetObjectPropertyGistAsCsvRequest {
	return ApiSmsOutboundGetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return string
func (a *MessagingAPIService) SmsOutboundGetObjectPropertyGistAsCsvExecute(r ApiSmsOutboundGetObjectPropertyGistAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundGetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/{uid}/{property}/gist.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest struct {
	ctx          context.Context
	ApiService   *MessagingAPIService
	property     string
	uid          string
	absoluteUrls *bool
	auto         *string
	describe     *bool
	fields       *string
	filter       *string
	headless     *bool
	inverse      *bool
	locale       *string
	order        *string
	page         *int32
	pageListName *string
	pageSize     *int32
	references   *bool
	rootJunction *string
	total        *bool
	translate    *bool
}

// Use absolute (&#x60;true&#x60;) or relative URLs (&#x60;false&#x60;, default) when linking to other objects.   See [Gist absoluteUrls parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_absoluteUrls).
func (r ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) AbsoluteUrls(absoluteUrls bool) ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.absoluteUrls = &absoluteUrls
	return r
}

// The extent of fields to include when no specific list of fields is provided using &#x60;fields&#x60; so that  that listed fields are automatically determined.   See [Gist auto parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-auto-parameter).
func (r ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Auto(auto string) ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.auto = &auto
	return r
}

// When &#x60;true&#x60; the query is not executed but the planned execution is described back similar to using _describe_ in SQL/database context.
func (r ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Describe(describe bool) ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.describe = &describe
	return r
}

// A comma seperated list of fields to include in the response. &#x60;*&#x60; includes all &#x60;auto&#x60; detected fields.   See [Gist fields parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_fields).
func (r ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Fields(fields string) ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.fields = &fields
	return r
}

// A comma seperated list of filters.   See [Gist filter parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_filter).
func (r ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Filter(filter string) ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.filter = &filter
	return r
}

// Endpoints returning a list by default wrap the items with an envelope containing the pager and the list, which is named according to the type of object listed.   See [Gist headless parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_headless).
func (r ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Headless(headless bool) ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.headless = &headless
	return r
}

// Inverse can be used in context of a collection field gist of the form /api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;/gist to not list all items that are contained in the member collection but all items that are not contained in the member collection.   See [Gist inverse parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#the-inverse-parameter).
func (r ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Inverse(inverse bool) ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.inverse = &inverse
	return r
}

// Switch translation language of display names. If not specified the translation language is the one configured in the users account settings.   See [Gist locale parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_locale).
func (r ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Locale(locale string) ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.locale = &locale
	return r
}

// To sort the list of items - one or more order expressions can be given.   See [Gist order parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_order).
func (r ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Order(order string) ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.order = &order
	return r
}

// The viewed page in paged list starting with 1 for the first page   See [Gist page parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_page).
func (r ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Page(page int32) ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.page = &page
	return r
}

// [no description yet]
func (r ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageListName(pageListName string) ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageListName = &pageListName
	return r
}

// The number of items on a page. Maximum is 1000 items.   See [Gist pageSize parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_pageSize).
func (r ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) PageSize(pageSize int32) ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.pageSize = &pageSize
	return r
}

// By default, the Gist API includes links to referenced objects. This can be disabled by using &#x60;references&#x3D;false&#x60;.
func (r ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) References(references bool) ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.references = &references
	return r
}

// Combine &#x60;filter&#x60;s with &#x60;AND&#x60; (default) or &#x60;OR&#x60; logic combinator   See [Gist rootJunction parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_rootJunction).
func (r ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) RootJunction(rootJunction string) ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.rootJunction = &rootJunction
	return r
}

// By default, a gist query will not count the total number of matches should those exceed the &#x60;pageSize&#x60; limit.   Using &#x60;total&#x3D;true&#x60; the pager includes the total number of matches.   See [Gist total parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_total).
func (r ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Total(total bool) ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.total = &total
	return r
}

// Fields like _name_ or _shortName_ can be translated (internationalised).   By default, any translatable field that has a translation is returned translated given that the user requesting the gist has an interface language configured.   To return the plain non-translated field use &#x60;translate&#x3D;false&#x60;.   See [Gist translate parameter](https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/metadata-gist.html#gist_parameters_translate).
func (r ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Translate(translate bool) ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	r.translate = &translate
	return r
}

func (r ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) Execute() (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	return r.ApiService.SmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r)
}

/*
SmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsv Method for SmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsv

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest
*/
func (a *MessagingAPIService) SmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsv(ctx context.Context, property string, uid string) ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest {
	return ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
func (a *MessagingAPIService) SmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvExecute(r ApiSmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsvRequest) (*AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AggregateDataExchangeGetObjectPropertyGistGetObjectPropertyGistAsCsv200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundGetObjectPropertyGistgetObjectPropertyGistAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/{uid}/{property}/gist"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.absoluteUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "absoluteUrls", r.absoluteUrls, "")
	} else {
		var defaultValue bool = false
		r.absoluteUrls = &defaultValue
	}
	if r.auto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto", r.auto, "")
	}
	if r.describe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe", r.describe, "")
	} else {
		var defaultValue bool = false
		r.describe = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.headless != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "headless", r.headless, "")
	} else {
		var defaultValue bool = false
		r.headless = &defaultValue
	}
	if r.inverse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inverse", r.inverse, "")
	} else {
		var defaultValue bool = false
		r.inverse = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = ""
		r.locale = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageListName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageListName", r.pageListName, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "")
	} else {
		var defaultValue bool = true
		r.references = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	} else {
		var defaultValue string = "AND"
		r.rootJunction = &defaultValue
	}
	if r.total != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "total", r.total, "")
	} else {
		var defaultValue bool = false
		r.total = &defaultValue
	}
	if r.translate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "translate", r.translate, "")
	} else {
		var defaultValue bool = true
		r.translate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundPatchObjectRequest struct {
	ctx                context.Context
	ApiService         *MessagingAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	jsonPatch          *JsonPatch
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiSmsOutboundPatchObjectRequest) AtomicMode(atomicMode string) ApiSmsOutboundPatchObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiSmsOutboundPatchObjectRequest) FlushMode(flushMode string) ApiSmsOutboundPatchObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiSmsOutboundPatchObjectRequest) Identifier(identifier string) ApiSmsOutboundPatchObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiSmsOutboundPatchObjectRequest) ImportMode(importMode string) ApiSmsOutboundPatchObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiSmsOutboundPatchObjectRequest) ImportReportMode(importReportMode string) ApiSmsOutboundPatchObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiSmsOutboundPatchObjectRequest) ImportStrategy(importStrategy string) ApiSmsOutboundPatchObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiSmsOutboundPatchObjectRequest) MergeMode(mergeMode string) ApiSmsOutboundPatchObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiSmsOutboundPatchObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiSmsOutboundPatchObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiSmsOutboundPatchObjectRequest) Page(page int32) ApiSmsOutboundPatchObjectRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiSmsOutboundPatchObjectRequest) PageSize(pageSize int32) ApiSmsOutboundPatchObjectRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiSmsOutboundPatchObjectRequest) Paging(paging bool) ApiSmsOutboundPatchObjectRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiSmsOutboundPatchObjectRequest) PreheatMode(preheatMode string) ApiSmsOutboundPatchObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiSmsOutboundPatchObjectRequest) RootJunction(rootJunction string) ApiSmsOutboundPatchObjectRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiSmsOutboundPatchObjectRequest) SkipSharing(skipSharing bool) ApiSmsOutboundPatchObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiSmsOutboundPatchObjectRequest) SkipTranslation(skipTranslation bool) ApiSmsOutboundPatchObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiSmsOutboundPatchObjectRequest) SkipValidation(skipValidation bool) ApiSmsOutboundPatchObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiSmsOutboundPatchObjectRequest) UserOverrideMode(userOverrideMode string) ApiSmsOutboundPatchObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiSmsOutboundPatchObjectRequest) JsonPatch(jsonPatch JsonPatch) ApiSmsOutboundPatchObjectRequest {
	r.jsonPatch = &jsonPatch
	return r
}

func (r ApiSmsOutboundPatchObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsOutboundPatchObjectExecute(r)
}

/*
SmsOutboundPatchObject Method for SmsOutboundPatchObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsOutboundPatchObjectRequest
*/
func (a *MessagingAPIService) SmsOutboundPatchObject(ctx context.Context, uid string) ApiSmsOutboundPatchObjectRequest {
	return ApiSmsOutboundPatchObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsOutboundPatchObjectExecute(r ApiSmsOutboundPatchObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundPatchObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundPostJsonObjectRequest struct {
	ctx                context.Context
	ApiService         *MessagingAPIService
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	preheatMode        *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	outboundSms        *OutboundSms
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiSmsOutboundPostJsonObjectRequest) AtomicMode(atomicMode string) ApiSmsOutboundPostJsonObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiSmsOutboundPostJsonObjectRequest) FlushMode(flushMode string) ApiSmsOutboundPostJsonObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiSmsOutboundPostJsonObjectRequest) Identifier(identifier string) ApiSmsOutboundPostJsonObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiSmsOutboundPostJsonObjectRequest) ImportMode(importMode string) ApiSmsOutboundPostJsonObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiSmsOutboundPostJsonObjectRequest) ImportReportMode(importReportMode string) ApiSmsOutboundPostJsonObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiSmsOutboundPostJsonObjectRequest) ImportStrategy(importStrategy string) ApiSmsOutboundPostJsonObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiSmsOutboundPostJsonObjectRequest) MergeMode(mergeMode string) ApiSmsOutboundPostJsonObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiSmsOutboundPostJsonObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiSmsOutboundPostJsonObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiSmsOutboundPostJsonObjectRequest) PreheatMode(preheatMode string) ApiSmsOutboundPostJsonObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiSmsOutboundPostJsonObjectRequest) SkipSharing(skipSharing bool) ApiSmsOutboundPostJsonObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiSmsOutboundPostJsonObjectRequest) SkipTranslation(skipTranslation bool) ApiSmsOutboundPostJsonObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiSmsOutboundPostJsonObjectRequest) SkipValidation(skipValidation bool) ApiSmsOutboundPostJsonObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiSmsOutboundPostJsonObjectRequest) UserOverrideMode(userOverrideMode string) ApiSmsOutboundPostJsonObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiSmsOutboundPostJsonObjectRequest) OutboundSms(outboundSms OutboundSms) ApiSmsOutboundPostJsonObjectRequest {
	r.outboundSms = &outboundSms
	return r
}

func (r ApiSmsOutboundPostJsonObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsOutboundPostJsonObjectExecute(r)
}

/*
SmsOutboundPostJsonObject Method for SmsOutboundPostJsonObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsOutboundPostJsonObjectRequest
*/
func (a *MessagingAPIService) SmsOutboundPostJsonObject(ctx context.Context) ApiSmsOutboundPostJsonObjectRequest {
	return ApiSmsOutboundPostJsonObjectRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsOutboundPostJsonObjectExecute(r ApiSmsOutboundPostJsonObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundPostJsonObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/#postJsonObject"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.outboundSms
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundPostXmlObjectRequest struct {
	ctx                context.Context
	ApiService         *MessagingAPIService
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	preheatMode        *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	outboundSms        *OutboundSms
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiSmsOutboundPostXmlObjectRequest) AtomicMode(atomicMode string) ApiSmsOutboundPostXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiSmsOutboundPostXmlObjectRequest) FlushMode(flushMode string) ApiSmsOutboundPostXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiSmsOutboundPostXmlObjectRequest) Identifier(identifier string) ApiSmsOutboundPostXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiSmsOutboundPostXmlObjectRequest) ImportMode(importMode string) ApiSmsOutboundPostXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiSmsOutboundPostXmlObjectRequest) ImportReportMode(importReportMode string) ApiSmsOutboundPostXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiSmsOutboundPostXmlObjectRequest) ImportStrategy(importStrategy string) ApiSmsOutboundPostXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiSmsOutboundPostXmlObjectRequest) MergeMode(mergeMode string) ApiSmsOutboundPostXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiSmsOutboundPostXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiSmsOutboundPostXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiSmsOutboundPostXmlObjectRequest) PreheatMode(preheatMode string) ApiSmsOutboundPostXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiSmsOutboundPostXmlObjectRequest) SkipSharing(skipSharing bool) ApiSmsOutboundPostXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiSmsOutboundPostXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiSmsOutboundPostXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiSmsOutboundPostXmlObjectRequest) SkipValidation(skipValidation bool) ApiSmsOutboundPostXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiSmsOutboundPostXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiSmsOutboundPostXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiSmsOutboundPostXmlObjectRequest) OutboundSms(outboundSms OutboundSms) ApiSmsOutboundPostXmlObjectRequest {
	r.outboundSms = &outboundSms
	return r
}

func (r ApiSmsOutboundPostXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsOutboundPostXmlObjectExecute(r)
}

/*
SmsOutboundPostXmlObject Method for SmsOutboundPostXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsOutboundPostXmlObjectRequest
*/
func (a *MessagingAPIService) SmsOutboundPostXmlObject(ctx context.Context) ApiSmsOutboundPostXmlObjectRequest {
	return ApiSmsOutboundPostXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsOutboundPostXmlObjectExecute(r ApiSmsOutboundPostXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundPostXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/#postXmlObject"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.outboundSms
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundPutJsonObjectputXmlObjectRequest struct {
	ctx                context.Context
	ApiService         *MessagingAPIService
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	preheatMode        *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	outboundSms        *OutboundSms
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiSmsOutboundPutJsonObjectputXmlObjectRequest) AtomicMode(atomicMode string) ApiSmsOutboundPutJsonObjectputXmlObjectRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiSmsOutboundPutJsonObjectputXmlObjectRequest) FlushMode(flushMode string) ApiSmsOutboundPutJsonObjectputXmlObjectRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiSmsOutboundPutJsonObjectputXmlObjectRequest) Identifier(identifier string) ApiSmsOutboundPutJsonObjectputXmlObjectRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiSmsOutboundPutJsonObjectputXmlObjectRequest) ImportMode(importMode string) ApiSmsOutboundPutJsonObjectputXmlObjectRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiSmsOutboundPutJsonObjectputXmlObjectRequest) ImportReportMode(importReportMode string) ApiSmsOutboundPutJsonObjectputXmlObjectRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiSmsOutboundPutJsonObjectputXmlObjectRequest) ImportStrategy(importStrategy string) ApiSmsOutboundPutJsonObjectputXmlObjectRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiSmsOutboundPutJsonObjectputXmlObjectRequest) MergeMode(mergeMode string) ApiSmsOutboundPutJsonObjectputXmlObjectRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiSmsOutboundPutJsonObjectputXmlObjectRequest) MetadataSyncImport(metadataSyncImport bool) ApiSmsOutboundPutJsonObjectputXmlObjectRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiSmsOutboundPutJsonObjectputXmlObjectRequest) PreheatMode(preheatMode string) ApiSmsOutboundPutJsonObjectputXmlObjectRequest {
	r.preheatMode = &preheatMode
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiSmsOutboundPutJsonObjectputXmlObjectRequest) SkipSharing(skipSharing bool) ApiSmsOutboundPutJsonObjectputXmlObjectRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiSmsOutboundPutJsonObjectputXmlObjectRequest) SkipTranslation(skipTranslation bool) ApiSmsOutboundPutJsonObjectputXmlObjectRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiSmsOutboundPutJsonObjectputXmlObjectRequest) SkipValidation(skipValidation bool) ApiSmsOutboundPutJsonObjectputXmlObjectRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiSmsOutboundPutJsonObjectputXmlObjectRequest) UserOverrideMode(userOverrideMode string) ApiSmsOutboundPutJsonObjectputXmlObjectRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiSmsOutboundPutJsonObjectputXmlObjectRequest) OutboundSms(outboundSms OutboundSms) ApiSmsOutboundPutJsonObjectputXmlObjectRequest {
	r.outboundSms = &outboundSms
	return r
}

func (r ApiSmsOutboundPutJsonObjectputXmlObjectRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsOutboundPutJsonObjectputXmlObjectExecute(r)
}

/*
SmsOutboundPutJsonObjectputXmlObject Method for SmsOutboundPutJsonObjectputXmlObject

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsOutboundPutJsonObjectputXmlObjectRequest
*/
func (a *MessagingAPIService) SmsOutboundPutJsonObjectputXmlObject(ctx context.Context, uid string) ApiSmsOutboundPutJsonObjectputXmlObjectRequest {
	return ApiSmsOutboundPutJsonObjectputXmlObjectRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsOutboundPutJsonObjectputXmlObjectExecute(r ApiSmsOutboundPutJsonObjectputXmlObjectRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundPutJsonObjectputXmlObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.outboundSms
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundRemoveAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
}

func (r ApiSmsOutboundRemoveAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsOutboundRemoveAsFavoriteExecute(r)
}

/*
SmsOutboundRemoveAsFavorite Method for SmsOutboundRemoveAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsOutboundRemoveAsFavoriteRequest
*/
func (a *MessagingAPIService) SmsOutboundRemoveAsFavorite(ctx context.Context, uid string) ApiSmsOutboundRemoveAsFavoriteRequest {
	return ApiSmsOutboundRemoveAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsOutboundRemoveAsFavoriteExecute(r ApiSmsOutboundRemoveAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundRemoveAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest struct {
	ctx                 context.Context
	ApiService          *MessagingAPIService
	property            string
	uid                 string
	identifiableObjects *IdentifiableObjects
}

// [no description yet]
func (r ApiSmsOutboundReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) IdentifiableObjects(identifiableObjects IdentifiableObjects) ApiSmsOutboundReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	r.identifiableObjects = &identifiableObjects
	return r
}

func (r ApiSmsOutboundReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsOutboundReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r)
}

/*
SmsOutboundReplaceCollectionItemsJsonreplaceCollectionItemsXml Method for SmsOutboundReplaceCollectionItemsJsonreplaceCollectionItemsXml

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsOutboundReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest
*/
func (a *MessagingAPIService) SmsOutboundReplaceCollectionItemsJsonreplaceCollectionItemsXml(ctx context.Context, property string, uid string) ApiSmsOutboundReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest {
	return ApiSmsOutboundReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsOutboundReplaceCollectionItemsJsonreplaceCollectionItemsXmlExecute(r ApiSmsOutboundReplaceCollectionItemsJsonreplaceCollectionItemsXmlRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundReplaceCollectionItemsJsonreplaceCollectionItemsXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifiableObjects
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundReplaceTranslationsRequest struct {
	ctx                                             context.Context
	ApiService                                      *MessagingAPIService
	uid                                             string
	aggregateDataExchangeReplaceTranslationsRequest *AggregateDataExchangeReplaceTranslationsRequest
}

// [no description yet]
func (r ApiSmsOutboundReplaceTranslationsRequest) AggregateDataExchangeReplaceTranslationsRequest(aggregateDataExchangeReplaceTranslationsRequest AggregateDataExchangeReplaceTranslationsRequest) ApiSmsOutboundReplaceTranslationsRequest {
	r.aggregateDataExchangeReplaceTranslationsRequest = &aggregateDataExchangeReplaceTranslationsRequest
	return r
}

func (r ApiSmsOutboundReplaceTranslationsRequest) Execute() (*http.Response, error) {
	return r.ApiService.SmsOutboundReplaceTranslationsExecute(r)
}

/*
SmsOutboundReplaceTranslations Method for SmsOutboundReplaceTranslations

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsOutboundReplaceTranslationsRequest
*/
func (a *MessagingAPIService) SmsOutboundReplaceTranslations(ctx context.Context, uid string) ApiSmsOutboundReplaceTranslationsRequest {
	return ApiSmsOutboundReplaceTranslationsRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *MessagingAPIService) SmsOutboundReplaceTranslationsExecute(r ApiSmsOutboundReplaceTranslationsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundReplaceTranslations")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/{uid}/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateDataExchangeReplaceTranslationsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSmsOutboundSendSMSMessageRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
}

func (r ApiSmsOutboundSendSMSMessageRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsOutboundSendSMSMessageExecute(r)
}

/*
SmsOutboundSendSMSMessage Method for SmsOutboundSendSMSMessage

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmsOutboundSendSMSMessageRequest
*/
func (a *MessagingAPIService) SmsOutboundSendSMSMessage(ctx context.Context) ApiSmsOutboundSendSMSMessageRequest {
	return ApiSmsOutboundSendSMSMessageRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsOutboundSendSMSMessageExecute(r ApiSmsOutboundSendSMSMessageRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundSendSMSMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundSetAsFavoriteRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
}

func (r ApiSmsOutboundSetAsFavoriteRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsOutboundSetAsFavoriteExecute(r)
}

/*
SmsOutboundSetAsFavorite Method for SmsOutboundSetAsFavorite

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsOutboundSetAsFavoriteRequest
*/
func (a *MessagingAPIService) SmsOutboundSetAsFavorite(ctx context.Context, uid string) ApiSmsOutboundSetAsFavoriteRequest {
	return ApiSmsOutboundSetAsFavoriteRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsOutboundSetAsFavoriteExecute(r ApiSmsOutboundSetAsFavoriteRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundSetAsFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/{uid}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundSetSharingRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
	sharing    *Sharing
}

// [no description yet]
func (r ApiSmsOutboundSetSharingRequest) Sharing(sharing Sharing) ApiSmsOutboundSetSharingRequest {
	r.sharing = &sharing
	return r
}

func (r ApiSmsOutboundSetSharingRequest) Execute() (*http.Response, error) {
	return r.ApiService.SmsOutboundSetSharingExecute(r)
}

/*
SmsOutboundSetSharing Method for SmsOutboundSetSharing

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsOutboundSetSharingRequest
*/
func (a *MessagingAPIService) SmsOutboundSetSharing(ctx context.Context, uid string) ApiSmsOutboundSetSharingRequest {
	return ApiSmsOutboundSetSharingRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
func (a *MessagingAPIService) SmsOutboundSetSharingExecute(r ApiSmsOutboundSetSharingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundSetSharing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/{uid}/sharing"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharing
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSmsOutboundSubscribeRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
}

func (r ApiSmsOutboundSubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsOutboundSubscribeExecute(r)
}

/*
SmsOutboundSubscribe Method for SmsOutboundSubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsOutboundSubscribeRequest
*/
func (a *MessagingAPIService) SmsOutboundSubscribe(ctx context.Context, uid string) ApiSmsOutboundSubscribeRequest {
	return ApiSmsOutboundSubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsOutboundSubscribeExecute(r ApiSmsOutboundSubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundSubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundUnsubscribeRequest struct {
	ctx        context.Context
	ApiService *MessagingAPIService
	uid        string
}

func (r ApiSmsOutboundUnsubscribeRequest) Execute() (*WebMessage, *http.Response, error) {
	return r.ApiService.SmsOutboundUnsubscribeExecute(r)
}

/*
SmsOutboundUnsubscribe Method for SmsOutboundUnsubscribe

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uid [no description yet]
	@return ApiSmsOutboundUnsubscribeRequest
*/
func (a *MessagingAPIService) SmsOutboundUnsubscribe(ctx context.Context, uid string) ApiSmsOutboundUnsubscribeRequest {
	return ApiSmsOutboundUnsubscribeRequest{
		ApiService: a,
		ctx:        ctx,
		uid:        uid,
	}
}

// Execute executes the request
//
//	@return WebMessage
func (a *MessagingAPIService) SmsOutboundUnsubscribeExecute(r ApiSmsOutboundUnsubscribeRequest) (*WebMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundUnsubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/{uid}/subscriber"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return localVarReturnValue, nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return localVarReturnValue, nil, reportError("uid must have less than 11 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSmsOutboundUpdateObjectPropertyRequest struct {
	ctx                context.Context
	ApiService         *MessagingAPIService
	property           string
	uid                string
	atomicMode         *string
	flushMode          *string
	identifier         *string
	importMode         *string
	importReportMode   *string
	importStrategy     *string
	mergeMode          *string
	metadataSyncImport *bool
	page               *int32
	pageSize           *int32
	paging             *bool
	preheatMode        *string
	rootJunction       *string
	skipSharing        *bool
	skipTranslation    *bool
	skipValidation     *bool
	userOverrideMode   *string
	outboundSms        *OutboundSms
}

// Sets atomic mode, in the old importer we always did a best effort import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the &#x60;NONE&#x60; mode emulated the old behavior.
func (r ApiSmsOutboundUpdateObjectPropertyRequest) AtomicMode(atomicMode string) ApiSmsOutboundUpdateObjectPropertyRequest {
	r.atomicMode = &atomicMode
	return r
}

// Sets the flush mode, which controls when to flush the internal cache. It is strongly recommended to keep this to &#x60;AUTO&#x60; (which is the default). Only use &#x60;OBJECT&#x60; for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).
func (r ApiSmsOutboundUpdateObjectPropertyRequest) FlushMode(flushMode string) ApiSmsOutboundUpdateObjectPropertyRequest {
	r.flushMode = &flushMode
	return r
}

// Sets the identifier scheme to use for reference matching. &#x60;AUTO&#x60; means try &#x60;UID&#x60; first, then &#x60;CODE&#x60;.
func (r ApiSmsOutboundUpdateObjectPropertyRequest) Identifier(identifier string) ApiSmsOutboundUpdateObjectPropertyRequest {
	r.identifier = &identifier
	return r
}

// Sets overall import mode, decides whether or not to only &#x60;VALIDATE&#x60; or also &#x60;COMMIT&#x60; the metadata, this has similar functionality as our old dryRun flag.
func (r ApiSmsOutboundUpdateObjectPropertyRequest) ImportMode(importMode string) ApiSmsOutboundUpdateObjectPropertyRequest {
	r.importMode = &importMode
	return r
}

// Sets the &#x60;ImportReport&#x60; mode, controls how much is reported back after the import is done. &#x60;ERRORS&#x60; only includes ObjectReports for object which has errors. &#x60;FULL&#x60; returns an ObjectReport for all objects imported, and &#x60;DEBUG&#x60; returns the same plus a name for the object (if available).
func (r ApiSmsOutboundUpdateObjectPropertyRequest) ImportReportMode(importReportMode string) ApiSmsOutboundUpdateObjectPropertyRequest {
	r.importReportMode = &importReportMode
	return r
}

// Sets import strategy, &#x60;CREATE_AND_UPDATE&#x60; will try and match on identifier, if it doesn&#39;t exist, it will create the object.
func (r ApiSmsOutboundUpdateObjectPropertyRequest) ImportStrategy(importStrategy string) ApiSmsOutboundUpdateObjectPropertyRequest {
	r.importStrategy = &importStrategy
	return r
}

// Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, &#x60;MERGE&#x60; mode will only overwrite the old property if the new one is not-null, for &#x60;REPLACE&#x60; mode all properties are overwritten regardless of null or not. (*)
func (r ApiSmsOutboundUpdateObjectPropertyRequest) MergeMode(mergeMode string) ApiSmsOutboundUpdateObjectPropertyRequest {
	r.mergeMode = &mergeMode
	return r
}

// [no description yet]
func (r ApiSmsOutboundUpdateObjectPropertyRequest) MetadataSyncImport(metadataSyncImport bool) ApiSmsOutboundUpdateObjectPropertyRequest {
	r.metadataSyncImport = &metadataSyncImport
	return r
}

// Defines which page number to return.
func (r ApiSmsOutboundUpdateObjectPropertyRequest) Page(page int32) ApiSmsOutboundUpdateObjectPropertyRequest {
	r.page = &page
	return r
}

// Defines the number of elements to return for each page.
func (r ApiSmsOutboundUpdateObjectPropertyRequest) PageSize(pageSize int32) ApiSmsOutboundUpdateObjectPropertyRequest {
	r.pageSize = &pageSize
	return r
}

// Indicates whether to return lists of elements in pages.
func (r ApiSmsOutboundUpdateObjectPropertyRequest) Paging(paging bool) ApiSmsOutboundUpdateObjectPropertyRequest {
	r.paging = &paging
	return r
}

// Sets the preheater mode, used to signal if preheating should be done for &#x60;ALL&#x60; (as it was before with &#x60;preheatCache&#x3D;true&#x60;) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to &#x60;NONE&#x60; is not recommended.
func (r ApiSmsOutboundUpdateObjectPropertyRequest) PreheatMode(preheatMode string) ApiSmsOutboundUpdateObjectPropertyRequest {
	r.preheatMode = &preheatMode
	return r
}

// Combine filters with &#x60;AND&#x60; (default) or &#x60;OR&#x60;
func (r ApiSmsOutboundUpdateObjectPropertyRequest) RootJunction(rootJunction string) ApiSmsOutboundUpdateObjectPropertyRequest {
	r.rootJunction = &rootJunction
	return r
}

// Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.
func (r ApiSmsOutboundUpdateObjectPropertyRequest) SkipSharing(skipSharing bool) ApiSmsOutboundUpdateObjectPropertyRequest {
	r.skipSharing = &skipSharing
	return r
}

// [no description yet]
func (r ApiSmsOutboundUpdateObjectPropertyRequest) SkipTranslation(skipTranslation bool) ApiSmsOutboundUpdateObjectPropertyRequest {
	r.skipTranslation = &skipTranslation
	return r
}

// Skip validation for import. **NOT RECOMMENDED**
func (r ApiSmsOutboundUpdateObjectPropertyRequest) SkipValidation(skipValidation bool) ApiSmsOutboundUpdateObjectPropertyRequest {
	r.skipValidation = &skipValidation
	return r
}

// Allows you to override the user property of every object you are importing, the options are &#x60;NONE&#x60; (do nothing), &#x60;CURRENT&#x60; (use import user), &#x60;SELECTED&#x60; (select a specific user using overrideUser&#x3D;X)
func (r ApiSmsOutboundUpdateObjectPropertyRequest) UserOverrideMode(userOverrideMode string) ApiSmsOutboundUpdateObjectPropertyRequest {
	r.userOverrideMode = &userOverrideMode
	return r
}

// [no description yet]
func (r ApiSmsOutboundUpdateObjectPropertyRequest) OutboundSms(outboundSms OutboundSms) ApiSmsOutboundUpdateObjectPropertyRequest {
	r.outboundSms = &outboundSms
	return r
}

func (r ApiSmsOutboundUpdateObjectPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.SmsOutboundUpdateObjectPropertyExecute(r)
}

/*
SmsOutboundUpdateObjectProperty Method for SmsOutboundUpdateObjectProperty

[no description yet]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param property [no description yet]
	@param uid [no description yet]
	@return ApiSmsOutboundUpdateObjectPropertyRequest
*/
func (a *MessagingAPIService) SmsOutboundUpdateObjectProperty(ctx context.Context, property string, uid string) ApiSmsOutboundUpdateObjectPropertyRequest {
	return ApiSmsOutboundUpdateObjectPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		property:   property,
		uid:        uid,
	}
}

// Execute executes the request
func (a *MessagingAPIService) SmsOutboundUpdateObjectPropertyExecute(r ApiSmsOutboundUpdateObjectPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagingAPIService.SmsOutboundUpdateObjectProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sms/outbound/{uid}/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", url.PathEscape(parameterValueToString(r.uid, "uid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.uid) < 11 {
		return nil, reportError("uid must have at least 11 elements")
	}
	if strlen(r.uid) > 11 {
		return nil, reportError("uid must have less than 11 elements")
	}

	if r.atomicMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atomicMode", r.atomicMode, "")
	} else {
		var defaultValue string = "ALL"
		r.atomicMode = &defaultValue
	}
	if r.flushMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flushMode", r.flushMode, "")
	} else {
		var defaultValue string = "AUTO"
		r.flushMode = &defaultValue
	}
	if r.identifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "")
	} else {
		var defaultValue string = "UID"
		r.identifier = &defaultValue
	}
	if r.importMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importMode", r.importMode, "")
	} else {
		var defaultValue string = "COMMIT"
		r.importMode = &defaultValue
	}
	if r.importReportMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importReportMode", r.importReportMode, "")
	} else {
		var defaultValue string = "ERRORS"
		r.importReportMode = &defaultValue
	}
	if r.importStrategy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importStrategy", r.importStrategy, "")
	} else {
		var defaultValue string = "CREATE_AND_UPDATE"
		r.importStrategy = &defaultValue
	}
	if r.mergeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mergeMode", r.mergeMode, "")
	} else {
		var defaultValue string = "REPLACE"
		r.mergeMode = &defaultValue
	}
	if r.metadataSyncImport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataSyncImport", r.metadataSyncImport, "")
	} else {
		var defaultValue bool = false
		r.metadataSyncImport = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.paging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging", r.paging, "")
	}
	if r.preheatMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preheatMode", r.preheatMode, "")
	} else {
		var defaultValue string = "REFERENCE"
		r.preheatMode = &defaultValue
	}
	if r.rootJunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootJunction", r.rootJunction, "")
	}
	if r.skipSharing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipSharing", r.skipSharing, "")
	} else {
		var defaultValue bool = false
		r.skipSharing = &defaultValue
	}
	if r.skipTranslation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipTranslation", r.skipTranslation, "")
	} else {
		var defaultValue bool = false
		r.skipTranslation = &defaultValue
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipValidation", r.skipValidation, "")
	} else {
		var defaultValue bool = false
		r.skipValidation = &defaultValue
	}
	if r.userOverrideMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userOverrideMode", r.userOverrideMode, "")
	} else {
		var defaultValue string = "NONE"
		r.userOverrideMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.outboundSms
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v WebMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
